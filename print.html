<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Labyte Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/style1.css">
        <link rel="stylesheet" href="theme/css/table.css">
        <link rel="stylesheet" href="assets/mermaid.css">
        <link rel="stylesheet" href="assets/print.css">
        <link rel="stylesheet" href="assets/all-page.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Introduction.html">首页</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> DotNet</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dotnet/c-sharp.html"><strong aria-hidden="true">1.1.</strong> CSharp</a></li><li class="chapter-item "><a href="dotnet/nuget.html"><strong aria-hidden="true">1.2.</strong> Nuget</a></li><li class="chapter-item "><a href="dotnet/packages/messagepack.html"><strong aria-hidden="true">1.3.</strong> 包：Messagepack</a></li><li class="chapter-item "><a href="dotnet/packages/memorypack.html"><strong aria-hidden="true">1.4.</strong> 包：MemoryPack</a></li><li class="chapter-item "><a href="dotnet/packages/dotnetty.html"><strong aria-hidden="true">1.5.</strong> 包：DotNetty</a></li><li class="chapter-item "><a href="dotnet/packages/stackexchange-redis.html"><strong aria-hidden="true">1.6.</strong> 包：StackExchange.Redis</a></li><li class="chapter-item "><a href="dotnet/packages/epplus.html"><strong aria-hidden="true">1.7.</strong> 包：EPPlus</a></li></ol></li><li class="chapter-item expanded "><a href="dotnet/wpf/index.html"><strong aria-hidden="true">2.</strong> WPF</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dotnet/wpf/listbox.html"><strong aria-hidden="true">2.1.</strong> ListBox</a></li><li class="chapter-item "><a href="dotnet/wpf/listview.html"><strong aria-hidden="true">2.2.</strong> ListView</a></li><li class="chapter-item "><a href="dotnet/wpf/项目版本号.html"><strong aria-hidden="true">2.3.</strong> 项目版本号</a></li><li class="chapter-item "><a href="dotnet/wpf/资源引用.html"><strong aria-hidden="true">2.4.</strong> 资源引用</a></li><li class="chapter-item "><a href="dotnet/wpf/devexpress.html"><strong aria-hidden="true">2.5.</strong> DevExpress</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> WinForm</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dotnet/winform/tray.html"><strong aria-hidden="true">3.1.</strong> 托盘开发</a></li></ol></li><li class="chapter-item expanded "><a href="dotnet/aspnet/aspnet.html"><strong aria-hidden="true">4.</strong> Asp.Net</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dotnet/aspnet/aspnet-signalr.html"><strong aria-hidden="true">4.1.</strong> SignalR</a></li><li class="chapter-item "><a href="dotnet/aspnet/aspnet-证书.html"><strong aria-hidden="true">4.2.</strong> 证书</a></li><li class="chapter-item "><a href="dotnet/aspnet/aspnet-jwt.html"><strong aria-hidden="true">4.3.</strong> Jwt</a></li><li class="chapter-item "><a href="dotnet/aspnet/aspnet-blazor.html"><strong aria-hidden="true">4.4.</strong> Blazor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dotnet/aspnet/aspnet-bootstrap-blazor.html"><strong aria-hidden="true">4.4.1.</strong> BootstrapBlazor</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="unity/unity.html"><strong aria-hidden="true">5.</strong> Unity</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unity/ui.html"><strong aria-hidden="true">5.1.</strong> UI</a></li><li class="chapter-item "><a href="unity/animation.html"><strong aria-hidden="true">5.2.</strong> 动画</a></li><li class="chapter-item "><a href="unity/camera.html"><strong aria-hidden="true">5.3.</strong> 相机</a></li><li class="chapter-item "><a href="unity/vector.html"><strong aria-hidden="true">5.4.</strong> 向量</a></li><li class="chapter-item "><a href="unity/lighting.html"><strong aria-hidden="true">5.5.</strong> 灯光</a></li><li class="chapter-item "><a href="unity/material-shader.html"><strong aria-hidden="true">5.6.</strong> 材质</a></li><li class="chapter-item "><a href="unity/monobehavior.html"><strong aria-hidden="true">5.7.</strong> 行为脚本</a></li><li class="chapter-item "><a href="unity/timeline.html"><strong aria-hidden="true">5.8.</strong> Timeline</a></li><li class="chapter-item "><a href="unity/vr/SteamVR.html"><strong aria-hidden="true">5.9.</strong> Steam VR</a></li><li class="chapter-item "><a href="unity/优化/资源优化.html"><strong aria-hidden="true">5.10.</strong> 资源优化</a></li><li class="chapter-item "><a href="unity/特殊文件夹.html"><strong aria-hidden="true">5.11.</strong> 特殊文件夹</a></li><li class="chapter-item "><a href="unity/build-window.html"><strong aria-hidden="true">5.12.</strong> 发布 Window 平台</a></li><li class="chapter-item "><a href="unity/build-webgl.html"><strong aria-hidden="true">5.13.</strong> 发布 WebGL 平台</a></li><li class="chapter-item "><a href="unity/build-android.html"><strong aria-hidden="true">5.14.</strong> 发布 安卓 平台</a></li><li class="chapter-item "><a href="unity/build-ios.html"><strong aria-hidden="true">5.15.</strong> 发布 IOS 平台</a></li><li class="chapter-item "><a href="unity/packages/UniTask.html"><strong aria-hidden="true">5.16.</strong> 包：UniTask</a></li><li class="chapter-item "><a href="unity/packages/sqlite.html"><strong aria-hidden="true">5.17.</strong> 包：Sqlite</a></li><li class="chapter-item "><a href="unity/packages/StarterAssets.html"><strong aria-hidden="true">5.18.</strong> 包：StarterAssets</a></li><li class="chapter-item "><a href="unity/packages/Addressables.html"><strong aria-hidden="true">5.19.</strong> 包：Addressables</a></li><li class="chapter-item "><a href="unity/packages/CurvySpine.html"><strong aria-hidden="true">5.20.</strong> 包：CurvySpine</a></li><li class="chapter-item "><a href="unity/packages/DoTween.html"><strong aria-hidden="true">5.21.</strong> 包：DoTween</a></li><li class="chapter-item "><a href="unity/packages/EasySave.html"><strong aria-hidden="true">5.22.</strong> 包：EasySave</a></li><li class="chapter-item "><a href="unity/packages/ET网络框架.html"><strong aria-hidden="true">5.23.</strong> 包：ET网络框架</a></li><li class="chapter-item "><a href="unity/packages/InputSystemPackage.html"><strong aria-hidden="true">5.24.</strong> 包：InputSystemPackage</a></li><li class="chapter-item "><a href="unity/packages/MagicOnion.html"><strong aria-hidden="true">5.25.</strong> 包：MagicOnion</a></li><li class="chapter-item "><a href="unity/packages/NativeShare.html"><strong aria-hidden="true">5.26.</strong> 包：Nativefileso</a></li><li class="chapter-item "><a href="unity/packages/Nativefileso.html"><strong aria-hidden="true">5.27.</strong> 包：Nativefileso</a></li><li class="chapter-item "><a href="unity/packages/Newtonsoft.html"><strong aria-hidden="true">5.28.</strong> 包：Newtonsoft</a></li><li class="chapter-item "><a href="unity/packages/NewUIWidgets.html"><strong aria-hidden="true">5.29.</strong> 包：NewUIWidgets</a></li><li class="chapter-item "><a href="unity/packages/NodeGraphProcessor.html"><strong aria-hidden="true">5.30.</strong> 包：NodeGraphProcessor</a></li><li class="chapter-item "><a href="unity/packages/PDF插件.html"><strong aria-hidden="true">5.31.</strong> 包：PDF插件</a></li><li class="chapter-item "><a href="unity/ide-vscode.html"><strong aria-hidden="true">5.32.</strong> IDE：VS Code</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="rust/rust.html"><strong aria-hidden="true">6.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rust/tauri.html"><strong aria-hidden="true">6.1.</strong> Tauri</a></li><li class="chapter-item "><a href="rust/slint.html"><strong aria-hidden="true">6.2.</strong> Slint</a></li><li class="chapter-item "><a href="rust/iced.html"><strong aria-hidden="true">6.3.</strong> Iced</a></li><li class="chapter-item "><a href="rust/ecs.html"><strong aria-hidden="true">6.4.</strong> ECS</a></li><li class="chapter-item "><a href="rust/mdbook.html"><strong aria-hidden="true">6.5.</strong> mdBook</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="python/python.html"><strong aria-hidden="true">7.</strong> Python</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 数据库</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="database/sql-server.html"><strong aria-hidden="true">8.1.</strong> SQL Server</a></li><li class="chapter-item "><a href="database/my-sql.html"><strong aria-hidden="true">8.2.</strong> MySql</a></li><li class="chapter-item "><a href="database/redis.html"><strong aria-hidden="true">8.3.</strong> Redis</a></li><li class="chapter-item "><a href="database/mongodb.html"><strong aria-hidden="true">8.4.</strong> MongoDb</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="synology/synology.html"><strong aria-hidden="true">9.</strong> 群晖</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="synology/certficate.html"><strong aria-hidden="true">9.1.</strong> 证书</a></li><li class="chapter-item "><a href="synology/drive.html"><strong aria-hidden="true">9.2.</strong> Drive</a></li><li class="chapter-item "><a href="synology/反向代理服务器.html"><strong aria-hidden="true">9.3.</strong> 反向代理服务器</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="windows/index.html"><strong aria-hidden="true">10.</strong> Windows系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="windows/winsw.html"><strong aria-hidden="true">10.1.</strong> WinSW</a></li><li class="chapter-item "><a href="windows/windows-commands.html"><strong aria-hidden="true">10.2.</strong> Windows 命令行</a></li><li class="chapter-item "><a href="windows/mbr-gpt.html"><strong aria-hidden="true">10.3.</strong> 分区MBR格式转GPT格式</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="mac/mac.html"><strong aria-hidden="true">11.</strong> MacOS</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mac/xcode.html"><strong aria-hidden="true">11.1.</strong> XCode</a></li><li class="chapter-item "><a href="mac/testflight.html"><strong aria-hidden="true">11.2.</strong> TestFlight</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Google</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Google/download-apk.html"><strong aria-hidden="true">12.1.</strong> 下载Google商店中的APK</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> 技术栈</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="technology-stack/nginx.html"><strong aria-hidden="true">13.1.</strong> Nginx</a></li><li class="chapter-item "><a href="technology-stack/rabbitmq.html"><strong aria-hidden="true">13.2.</strong> RabbitMQ</a></li><li class="chapter-item "><a href="technology-stack/git.html"><strong aria-hidden="true">13.3.</strong> Git</a></li><li class="chapter-item "><a href="technology-stack/svn.html"><strong aria-hidden="true">13.4.</strong> SVN</a></li><li class="chapter-item "><a href="technology-stack/vim.html"><strong aria-hidden="true">13.5.</strong> Vim</a></li><li class="chapter-item "><a href="technology-stack/npm.html"><strong aria-hidden="true">13.6.</strong> Npm</a></li><li class="chapter-item "><a href="technology-stack/pip.html"><strong aria-hidden="true">13.7.</strong> PIP</a></li><li class="chapter-item "><a href="technology-stack/ssh.html"><strong aria-hidden="true">13.8.</strong> SSH</a></li><li class="chapter-item "><a href="technology-stack/docker.html"><strong aria-hidden="true">13.9.</strong> Docker</a></li><li class="chapter-item "><a href="technology-stack/regular-expression.html"><strong aria-hidden="true">13.10.</strong> 正则表达式</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> 云服务</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cloud-service/ali-cloud.html"><strong aria-hidden="true">14.1.</strong> 阿里云</a></li><li class="chapter-item "><a href="cloud-service/self-built-server.html"><strong aria-hidden="true">14.2.</strong> 自建服务器</a></li><li class="chapter-item "><a href="cloud-service/let-s-encrypt.html"><strong aria-hidden="true">14.3.</strong> Let's Encrypt</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> 软件</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="softs/typora.html"><strong aria-hidden="true">15.1.</strong> Typora</a></li><li class="chapter-item "><a href="softs/xournalpp.html"><strong aria-hidden="true">15.2.</strong> Xournal++</a></li><li class="chapter-item "><a href="softs/bulk-rename-utility.html"><strong aria-hidden="true">15.3.</strong> Bulk Rename Utility</a></li><li class="chapter-item "><a href="softs/exif-tool.html"><strong aria-hidden="true">15.4.</strong> ExifTool</a></li><li class="chapter-item "><a href="softs/telegram.html"><strong aria-hidden="true">15.5.</strong> Telegram</a></li><li class="chapter-item "><a href="softs/excel.html"><strong aria-hidden="true">15.6.</strong> Excel</a></li><li class="chapter-item "><a href="softs/visual-studio.html"><strong aria-hidden="true">15.7.</strong> Visual Studio</a></li><li class="chapter-item "><a href="softs/visual-studio-code.html"><strong aria-hidden="true">15.8.</strong> Visual Studio Code</a></li><li class="chapter-item "><a href="softs/jetbrains-rider.html"><strong aria-hidden="true">15.9.</strong> JetBrains Rider</a></li><li class="chapter-item "><a href="softs/others.html"><strong aria-hidden="true">15.10.</strong> 其他</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="markdown.html"><strong aria-hidden="true">16.</strong> Markdown</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>
        
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="章节" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="主题" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="搜索. (快捷键: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Labyte Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="打印" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/labyte/book" title="Git 仓库" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="搜索 ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 12px;
    text-align: left;
    vertical-align: top; 
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.excel-table tr:nth-child(even), table tr:nth-child(odd) {
    background-color: transparent; /* 确保所有行背景色一致 */
}

.excel-table tr:hover {
    background-color: inherit;
}
/*

.excel-table tr:nth-child(even) {
    background-color: #f9f9f9;
}

.excel-table tr:hover {
    background-color: #e9e9e9;
}
*/
.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    /* width: 30%; */
    width:50px;
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 30%;
}

.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width: 70%;
}
</style>
<h2 id="工具网站"><a class="header" href="#工具网站">工具网站</a></h2>
<p><strong>常用工具</strong></p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>序号</th>
                <th>名称</th>
                <th>说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td><a  target="_blank"  href="https://js.design/workspace">即使设计</a></td>
                <td>国内的UI设计，其他在线PS等网站很垃圾</td>
            </tr>
              <tr>
                <td>2</td>
                <td><a  target="_blank"  href="https://www.aconvert.com/">转换工具</a></td>
                <td>支持图像Ico（点击下载按钮无法下载时，双击图片名称，将图片另存为即可），电子书，视频，声音等，少量广告</td>
            </tr>
        </tbody>
    </table>
</div>
<p><strong>阅读</strong></p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>序号</th>
                <th>名称</th>
                <th>说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td><a  target="_blank"  href="https://zh.go-to-library.sk/">Z-Library</a></td>
                <td>
                    拷贝到设备Kindle（已经不支持邮箱发送到设备Kindle），支持 <b>azw3</b> 格式，<del>不支持 <b>EPUB</b> 格式 </del>
                </td>
            </tr>
              <tr>
                <td>2</td>
                <td><a  target="_blank" href="https://calibre-ebook.com/download">电子书格式转换工具-calibre</a></td>
                <td>电子书制作、格式转换工具</td>
            </tr>
        </tbody>
    </table>
</div>
<p><strong>音乐</strong></p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>序号</th>
                <th>网址</th>
                <th>说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td><a  target="_blank" href="https://ghyinyue.com/">果核音乐</a></td>
                <td>输入歌曲名称，搜索后进行下载，可下载无损版本，每天下载20首</td>
            </tr>
        </tbody>
    </table>
</div>
<div style="break-before: page; page-break-before: always;"></div><style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 12px;
    text-align: left;
    vertical-align: top; 
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.excel-table tr:nth-child(even), table tr:nth-child(odd) {
    background-color: transparent; /* 确保所有行背景色一致 */
}

.excel-table tr:hover {
    background-color: inherit;
}

.excel-table tr:hover {
    background-color: #e9e9e9;
}
.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    width:200px;
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 50%;
}
.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width: 50%;
}

</style>
<h1 id="csharp"><a class="header" href="#csharp">CSharp</a></h1>
<h2 id="项目设置"><a class="header" href="#项目设置">项目设置</a></h2>
<h3 id="应用程序设置settingssettings"><a class="header" href="#应用程序设置settingssettings">应用程序设置（Settings.settings）</a></h3>
<p>在WPF、Winform、Web项目中都有应用程序设置，以下以WPF为例。</p>
<p><strong>创建和打开配置文件</strong></p>
<p><img src="dotnet/image/c-sharp/1722478718891.png" alt="1722478718891" /></p>
<p><strong>配置文件设计窗口</strong></p>
<p><img src="dotnet/image/c-sharp/1722478766425.png" alt="1722478766425" /></p>
<ul>
<li><strong>名称</strong>：变量名</li>
<li><strong>类型</strong>：字符串、整数、布尔值、集合等。</li>
<li><strong>范围</strong>：应用程序和用户</li>
<li><strong>值</strong>：默认值</li>
</ul>
<p>程序发布后，设置的数据存储在：<code>程序集.exe.config</code> 文件中，如你的程序集为 <code>MyTool</code>，对应的文件名为：<code>MyTool.exe.config</code>，内容如下：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
    //...
    &lt;userSettings&gt;
        &lt;MyTool.Properties.Settings&gt;
            &lt;setting name="Number" serializeAs="String"&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;/setting&gt;    
        &lt;/MyTool.Properties.Settings&gt;
    &lt;/userSettings&gt;
    &lt;applicationSettings&gt;
    &lt;MyTool.Properties.Settings&gt;
        &lt;setting name="Count" serializeAs="String"&gt;
        &lt;value&gt;10&lt;/value&gt;
        &lt;/setting&gt;   
    &lt;/MyTool.Properties.Settings&gt;
    &lt;/applicationSettings&gt;
&lt;/configuration&gt;
</code></pre>
<p>分别设置了用户范围的变量 <code>Number</code>，和应用程序范围的变量 <code>Count</code>，<strong>注意这里面修改用户设置的数据无效，但是可以修改应用程序的设置</strong>。</p>
<p><strong>用户范围设置</strong>：默认情况下，用户特定的设置保存在用户配置文件目录下的 user.config 文件中。这个文件的位置因操作系统不同而有所不同，一般情况下会在以下路径中找到：</p>
<pre><code>Windows 7/8/10: C:\Users\&lt;用户名&gt;\AppData\Local\&lt;公司名&gt;\&lt;应用程序名&gt;\&lt;版本号&gt;\user.config

Windows XP: C:\Documents and Settings\&lt;用户名&gt;\Local Settings\Application Data\&lt;公司名&gt;\&lt;应用程序名&gt;\&lt;版本号&gt;\user.config
</code></pre>
<p><strong>❕ 注：公司名通过项目属性查看。</strong></p>
<blockquote>
<p>⚠️ <code>&lt;span style="color:red;font-weight:bold;"&gt;</code>注：修改程序根目录下的 “MyTool.exe.config” 配置文件无效</p>
</blockquote>
<p><strong>应用程序范围设置</strong>：如果设置是应用程序范围的（而不是用户特定的），那么它们会保存在应用程序的配置文件中，通常是 <code>App.config(程序集.exe.config)</code> 或 <code>Web.config</code>（对于 Web 应用程序）。不过，这些文件中的设置是只读的，运行时的修改不会保存回这些文件。</p>
<p><strong>修改设置</strong>：</p>
<pre><code class="language-c#">
// 读取设置值
int number = Properties.Settings.Default.Number;

// 修改设置值
Properties.Settings.Default.Number = 2;

// 保存设置值
Properties.Settings.Default.Save();
</code></pre>
<p>保存后，新的设置值会写入 user.config 文件中，下次启动应用程序时会读取这个值。</p>
<p><strong>总结</strong>：</p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>对比</th>
                <th>应用程序范围</th>
                <th>用户范围</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>存储位置</td>
                <td>程序根目录：<code>App.config(程序集.exe.config)</code> 或 <code>Web.config</code>（对于 Web 应用程序）</td>
                <td><code>C:\Users\<用户名>\AppData\Local\<公司名>\<应用程序名>\<版本号>\user.config</code></td>
            </tr>
            <tr>
                <td>修改 <code>App.config</code> 文件有效</td>
                <td>✔️</td>
                <td>❌</td>
            </tr>
             <tr>
                <td>可读</td>
                <td>✔️</td>
                <td>✔️</td>
            </tr>
              <tr>
                <td>可写</td>
                <td>❌</td>
                <td>✔️</td>
            </tr>
        </tbody>
    </table>
</div>
<p><strong>使用场景</strong> ：</p>
<p>动态配置数据，如用户偏好、应用程序配置参数等。</p>
<h3 id="应用程序资源resourcesresx"><a class="header" href="#应用程序资源resourcesresx">应用程序资源（Resources.resx）</a></h3>
<p><strong>用途</strong>：管理应用程序的静态资源和多语言资源。</p>
<p><strong>存储位置</strong>：通常定义在 .resx 文件中，这些文件可以包含字符串、图像、图标、文件等资源。</p>
<p><strong>类型</strong>：可以包含各种类型的资源，如字符串、图像、图标、文件等。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>存储应用程序的静态文本，支持多语言本地化。</li>
<li>存储应用程序所需的图像、图标等静态资源。</li>
<li>组织和管理资源文件，方便维护和更新。</li>
</ul>
<p><code>.resx</code> 文件示例</p>
<p><strong>定义资源</strong></p>
<p>你可以在 Visual Studio 中添加 <code>.resx</code> 文件并定义资源。例如，添加一个名为 <code>Resources.resx</code> 的资源文件，然后添加一些字符串资源：</p>
<ul>
<li><code>Greeting</code> -&gt; <code>Hello</code></li>
<li><code>Farewell</code> -&gt; <code>Goodbye</code></li>
</ul>
<p><strong>生成资源类</strong></p>
<p>Visual Studio 会自动生成一个与 <code>.resx</code> 文件对应的资源类，你可以在代码中使用这些资源。假设你的命名空间是 MyApp，你可以这样使用：</p>
<pre><code class="language-csharp">using MyApp.Properties;

// 读取资源值
string greeting = Resources.Greeting;//注：若文件名称为：Resources.xx.resx  那么读取时为：Resources_xx.Greeting
string farewell = Resources.Farewell;
</code></pre>
<p><strong>多语言支持（本地化）</strong>
为了支持多语言，你可以创建多个 .resx 文件，每个文件对应一种语言。例如：</p>
<ul>
<li><code>Resources.resx</code>（默认资源文件）</li>
<li><code>Resources.en-US.resx</code>（美国英语资源文件）</li>
<li><code>Resources.fr-FR.resx</code>（法国法语资源文件）</li>
</ul>
<p>在不同语言的资源文件中，定义相同的键但值为对应语言的翻译。</p>
<p>运行时切换语言
通过更改应用程序的文化信息，可以在运行时切换语言：</p>
<pre><code class="language-csharp">using System.Globalization;
using System.Threading;
using MyApp.Properties;

// 切换到法国法语
Thread.CurrentThread.CurrentUICulture = new CultureInfo("fr-FR");

// 读取资源值
string greeting = Resources.Greeting; // 将会返回法语的问候语
</code></pre>
<p><strong>应用程序资源与设置的区别总结</strong></p>
<p>应用程序资源（Resources）:</p>
<ul>
<li>用途：管理静态资源和支持多语言。</li>
<li>存储位置：.resx 文件。</li>
<li>类型：字符串、图像、图标、文件等。</li>
<li>使用场景：静态文本、图像、图标、多语言支持等。</li>
</ul>
<p>应用程序设置（Settings）：</p>
<ul>
<li>用途：存储和管理应用程序配置数据和用户设置。</li>
<li>存储位置：配置文件（如 App.config 或 user.config）。</li>
<li>类型：字符串、整数、布尔值、集合等。</li>
<li>使用场景：动态配置数据，如用户偏好、应用程序配置参数等。</li>
<li>通过理解这些区别，你可以更好地管理和组织 WPF 应用程序中的资源和设置，确保应用程序的灵活性和可维护性。</li>
</ul>
<h2 id="时间格式化"><a class="header" href="#时间格式化">时间格式化</a></h2>
<p><strong>DateTime 格式化</strong></p>
<pre><code class="language-C#">dateTime.ToString("yyyy-MM-DD hh:mm:ss");
</code></pre>
<p><strong>TimeSpan 格式化</strong></p>
<p><code>常用：timeSpan.ToString(@"dd\.hh\:mm\:ss");</code> 或则 <code>timeSpan.ToString("dd\\.hh\\:mm\\:ss");</code>区别是否使用转义符号。</p>
<pre><code class="language-C#">using System;

public class Example
{
   public static void Main()
   {
      TimeSpan duration = new TimeSpan(1, 12, 23, 62);

      string output = null;
      output = "Time of Travel: " + duration.ToString("%d") + " days";
      Console.WriteLine(output);
      output = "Time of Travel: " + duration.ToString(@"dd\.hh\:mm\:ss");
      Console.WriteLine(output);

      Console.WriteLine("Time of Travel: {0:%d} day(s)", duration);
      Console.WriteLine("Time of Travel: {0:dd\\.hh\\:mm\\:ss} days", duration);
   }
}
// The example displays the following output:
//       Time of Travel: 1 days
//       Time of Travel: 01.12:24:02
//       Time of Travel: 1 day(s)
//       Time of Travel: 01.12:24:02 days
</code></pre>
<h2 id="linq"><a class="header" href="#linq">Linq</a></h2>
<h3 id="多个属性具有相同处理逻辑"><a class="header" href="#多个属性具有相同处理逻辑">多个属性具有相同处理逻辑</a></h3>
<p>使用 Expression 来实现</p>
<blockquote>
<p>Expression：将强类型lambda表达式表示为表达式树形式的数据结构。该类不能被继承，当一个对象存在多个相同类型的属性，且这些属性控制的功能相同时,可以使用 Expression 来实现</p>
</blockquote>
<ul>
<li>有一组 Person, 需要遍历每个person，根据属性  <strong>A</strong> 或者  <strong>B</strong>，判断是说 <code>Hello</code> 还是 <code>Bye</code></li>
<li>Person</li>
</ul>
<pre><code>    public class Person
    {
        public string Name { get; set; }
        public bool pA { get; set; }
        public bool pB { get; set; }
    }

</code></pre>
<ul>
<li>创建 Person List</li>
</ul>
<pre><code>    class ExpressionTest
    {
        List&lt;Person&gt; persons = new List&lt;Person&gt;();
        public ExpressionTest()
        {
            persons.Add(new Person { Name = "Jerry", pA = true, pB = false });
            persons.Add(new Person { Name = "Shin", pA = true, pB = false });
        }
        ...
    }
</code></pre>
<h4 id="常规解法"><a class="header" href="#常规解法">常规解法</a></h4>
<ul>
<li>分别写两个方法，根据属性A 或者 属性B 来判断</li>
</ul>
<pre><code class="language-C#">  internal class ExpressionTest
    {
        List&lt;Person&gt; persons = new List&lt;Person&gt;();
        public ExpressionTest()
        {
            persons.Add(new Person { Name = "Jerry", pA = true, pB = false });
            persons.Add(new Person { Name = "Shin", pA = true, pB = false });
        }

        /* 需求： 遍历 persons， 根据 pA 或者 pB 的值，判断每个人是说 hello 还是 bye
         * 常规写法： 分别些两个方法遍历判断
         * Expression: 通过表达式实现通用写法
         * 
         */
        #region 常规写法

        private void SayHelloByA()
        {
            foreach (var p in persons)
            {
                if (p.pA)
                    Console.WriteLine($"[{p.Name}]\tSay Hello！");
                else
                    Console.WriteLine($"[{p.Name}]\tSay Bye！");
            }
           
        }
        private void SayHelloByB()
        {
            foreach (var p in persons)
            {
                if (p.pB)
                    Console.WriteLine($"[{p.Name}]\tSay Hello！");
                else
                    Console.WriteLine($"[{p.Name}]\tSay Bye！");
            }

        }

        #endregion
       // 测试
       public void Test()
        {
            SayHelloByA();// 输出: Say Hello!
            SayHelloByB();// 输出: Say Bye!
        }
    }
</code></pre>
<ul>
<li><strong>存在的问题</strong> ： 如果我们有多个属性 C D E F，那么我们就需要写多少方法，但是发现这些方法的逻辑都是一样的。总感觉很别扭，此时就要用到 <strong>Expression</strong></li>
</ul>
<h4 id="expression-写法"><a class="header" href="#expression-写法">Expression 写法</a></h4>
<pre><code class="language-C#"> internal class ExpressionTest
    {
        List&lt;Person&gt; persons = new List&lt;Person&gt;();
        public ExpressionTest()
        {
            persons.Add(new Person { Name = "Jerry", pA = true, pB = false });
            persons.Add(new Person { Name = "Shin", pA = true, pB = false });
        }
       
        #region  Expression
        public void SayHello(Expression&lt;Func&lt;Person, bool&gt;&gt; expr)
        {
            var valProp = (PropertyInfo)(((MemberExpression)expr.Body).Member);
            foreach (var p in persons)
            {
                bool isShow = (bool)valProp.GetValue(p, null);
                if (isShow)
                    Console.WriteLine($"[{p.Name}]\tSay Hello！");
                else
                    Console.WriteLine($"[{p.Name}]\tSay Bye！");
            }
        }
        #endregion
       // 测试
       public void Test()
        {
            SayHello(x =&gt; x.pA);// 输出: Say Hello!
            SayHello(x =&gt; x.pB);// 输出: Say Bye!
        }
    }
</code></pre>
<ul>
<li>通过表达式，让调用者来确定条件的值。</li>
</ul>
<h2 id="泛型基类"><a class="header" href="#泛型基类">泛型基类</a></h2>
<blockquote>
<p>无法创建显示类型的基类问题
解决方案：将泛型参数作为构造函数的参数，调用的函数中不要包含泛型参数，同时将函数提升为接口（新增接口），转换为面向接口编程</p>
</blockquote>
<p><strong>需求场景</strong>：</p>
<p>有多个数据结构，它们继承同一个基类，需要创建不同的 'Handler' 来处理不同的数据结构。</p>
<p>基类：</p>
<pre><code class="language-csharp">public class BaseClass{
    public string Name{get;set;}
}
</code></pre>
<p>子类A</p>
<pre><code class="language-csharp">public class AClass：BaseClass{
}
</code></pre>
<p>子类B</p>
<pre><code class="language-csharp">public class BClass：BaseClass{
}
</code></pre>
<p>Handler base</p>
<pre><code class="language-csharp">public abstract class BaseHandler&lt;T&gt;{

    public abstract void DoSomthing(T data);
   

}
</code></pre>
<p>Handler A</p>
<pre><code class="language-csharp">public class AHandler:BaseHandler&lt;AClass&gt;{

    public override void DoSomthing(T data)
    {
       Console.WriteLine($"A handel {data.Name}");
    }
}
</code></pre>
<p>Handler B</p>
<pre><code class="language-csharp">public class BHandler:BaseHandler&lt;BClass&gt;{
     public override void DoSomthing(T data)
    {
          Console.WriteLine($"B handel {data.Name}");
    }
}
</code></pre>
<p>处理逻辑(失败)</p>
<pre><code class="language-csharp">public void Handler(T data)
{
    //这里无法这样声明，因为泛型需要显示的指定类型，然后如果显示的指定类型，就无法使用到达我们多态的需求
    BaseHandler? = null;
    if(typeof(T) == typeof(AClass))
        return new AHandler();
    if(typeof(T) == typeof(BClass))
        return new BHandler();
    BaseHandler.DoSomthing(data);

}
</code></pre>
<p><strong>处理逻辑解读：</strong> 无法这样声明，因为泛型需要显示的指定类型，然后如果显示的指定类型，就无法使用到达我们多态的需求</p>
<hr />
<p><strong>解决办法</strong>：</p>
<ul>
<li>将多态的概念转变为面向接口编程</li>
<li>将调用的函数提升为接口，并且接口不要包含泛型参数</li>
<li>将参数放在构造函数中初始化</li>
<li>使用工厂创建处理器</li>
</ul>
<p>接口定义</p>
<pre><code class="language-csharp">public interface IHandler{
    void DoSomthing();
}

</code></pre>
<p>处理器基类实现接口，并定义包含泛型参数的构造函数</p>
<pre><code class="language-csharp">public abstract class BaseHandler&lt;T&gt;:IHandler{

    public T Data{get;set;}
    public abstract void DoSomthing();
   

}
</code></pre>
<p>Handler A 新增 含泛型参数的构造函数</p>
<pre><code class="language-csharp">public class AHandler:BaseHandler&lt;AClass&gt;{

    public AHandler(AClass data)
    {
        this.Data = data;
    }
    public override void DoSomthing(T data)
    {
       Console.WriteLine($"A handel {Data.Name}");
    }
}
</code></pre>
<p>Handler B 新增 含泛型参数的构造函数</p>
<pre><code class="language-csharp">public class BHandler:BaseHandler&lt;BClass&gt;{
     public BHandler(BClass data)
    {
        this.Data = data;
    }
     public override void DoSomthing()
    {
          Console.WriteLine($"B handel {Data.Name}");
    }
}
</code></pre>
<p>增加创建工厂</p>
<pre><code class="language-csharp">public class HandlerFactory
    {
        public static IHandler CreateHandler&lt;T&gt;(T data) where T : BaseClass 
        {
            if (typeof(T) == typeof(AClass))
            {
                return new AHandler(data as AClass);
            }
            if (typeof(T) == typeof(FlowPsdSingelOpen))
            {
               return new BHandler(data as BClass);
            }
            throw new ArgumentException("HandlerFactory: CreateHandler: Unsupported type: " + data.GetType());
        }
    }
</code></pre>
<p>处理逻辑(使用接口)</p>
<pre><code class="language-csharp">public void Handler(T data)
{
    //使用工厂创建
    BaseHandler= HandlerFactory.CreateHandler(data);
    BaseHandler.DoSomthing();

}
</code></pre>
<h2 id="开源项目"><a class="header" href="#开源项目">开源项目</a></h2>
<ol>
<li><a href="https://github.com/DebugST/STNodeEditor">一款基于.Net WinForm的节点编辑器</a>：纯GDI+绘制 使用方式非常简洁 提供了丰富的属性以及事件 可以非常方便的完成节点之间数据的交互及通知 大量的虚函数供开发者重写具有很高的自由性。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nuget"><a class="header" href="#nuget">Nuget</a></h1>
<h2 id="迁移-nuget-文件夹"><a class="header" href="#迁移-nuget-文件夹">迁移 .nuget 文件夹</a></h2>
<p><strong>.nuget</strong> 默认在C盘，用于缓存我们使用过的包，随着项目越来越多，文件夹越来越大，占用C盘空间。</p>
<p>参考 <a href="https://blog.csdn.net/Henry_Wu001/article/details/135825699">把.nuget文件夹从C盘移到其它盘</a></p>
<ul>
<li>查看当前缓存路径 <code>dotnet nuget locals all --list</code>，<code>global-packages</code> 指向的就是当前的路径</li>
<li>关闭当前的所有VS</li>
<li>打开 <code>%AppData%\NuGet\NuGet.Config</code> 文件，假设将 <strong>.nuget</strong> 移动到 <strong>D</strong> 盘的 <strong>Users</strong> 文件夹下，添加以下配置 <code> &lt;add key="globalPackagesFolder" value="D:\Users\.nuget\packages" /&gt;</code></li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;packageSources&gt;
   //...
  &lt;/packageSources&gt;
  &lt;packageRestore&gt;
    &lt;add key="enabled" value="True" /&gt;
    &lt;add key="automatic" value="True" /&gt;
  &lt;/packageRestore&gt;
  &lt;bindingRedirects&gt;
    &lt;add key="skip" value="False" /&gt;
  &lt;/bindingRedirects&gt;
  &lt;packageManagement&gt;
    &lt;add key="format" value="0" /&gt;
    &lt;add key="disabled" value="False" /&gt;
  &lt;/packageManagement&gt;
  &lt;config&gt;
     &lt;add key="globalPackagesFolder" value="D:\Users\.nuget\packages" /&gt;
  &lt;/config&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>将 <strong>.nuget</strong> 移动到 <strong>D</strong> 盘的 <strong>Users</strong> 文件夹下</li>
<li>再次查看当前缓存路径 <code>dotnet nuget locals all --list</code>，确认修改成功</li>
</ul>
<h2 id="发布包"><a class="header" href="#发布包">发布包</a></h2>
<ul>
<li>可以直接将包发布到官方网站上</li>
<li>自建 Nuget 服务器，参考：<a href="dotnet/../technology-stack/docker.html#%E5%AE%9E%E4%BE%8B-bagetter">docker-bagetter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messagepack"><a class="header" href="#messagepack">Messagepack</a></h1>
<p>速度超快的序列化工具。</p>
<h2 id="union-使用"><a class="header" href="#union-使用">Union 使用</a></h2>
<ul>
<li>当存在多层多态时，在最基类上标注所有的子类</li>
<li>中间层为抽象层也需要使用Union</li>
</ul>
<pre><code class="language-C#">/*Union应用所有的实现类*/
[MessagePack.Union(0, typeof(Foo1))]
[MessagePack.Union(1, typeof(Foo2))]
[MessagePack.Union(2, typeof(Bar1))]
public interface Root { }

[MessagePackObject]
[MessagePack.Union(0, typeof(Foo1))] //中间层使用Union,否则报错
[MessagePack.Union(1, typeof(Foo2))] //中间层使用Union,否则报错
public abstract class FooRoot : Root
{
    [Key(0)] public string F1 { get; set; }

}

[MessagePackObject]
[MessagePack.Union(0, typeof(Bar1))] //中间层使用Union,否则报错
public abstract class BarRoot : Root { }

[MessagePackObject]

public class Foo1 : FooRoot { [Key(1)] public string Name { get; set; } }
[MessagePackObject]

public class Foo2 : FooRoot { [Key(1)] public string Name { get; set; } }


[MessagePackObject]
public class Bar1 : BarRoot { [Key(0)] public string Name { get; set; } }



public class Test
{

    public static void TestMessagepack()
    {
        List&lt;Root&gt; arr = new List&lt;Root&gt;();
        arr.Add(new Foo1() {  F1 = "f" , Name = " nam"});
        arr.Add(new Bar1() {  Name = "b"});

        var bin = MessagePackSerializer.Serialize(arr);
        var list = MessagePackSerializer.Deserialize&lt;List&lt;Root&gt;&gt;(bin);
        foreach (var item in list)
        {
            Console.WriteLine("00");
        }
    }

}
</code></pre>
<h2 id="mpc"><a class="header" href="#mpc">Mpc</a></h2>
<p>进行AOT编译时，请仔细检查输出信息，是否有错误，这一步导致的错误，在后面无法跟踪查找</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memorypack"><a class="header" href="#memorypack">MemoryPack</a></h1>
<blockquote>
<p>使用方式见官网，此处仅记录使用中出现的问题</p>
</blockquote>
<p><a href="https://cysharp.co.jp/">Cysharp</a>发布了一个新的序列化器<a href="https://github.com/Cysharp/MemoryPack">Cysharp/内存包</a>，日文：<a href="https://spacekey.dev/memorypack-1">memorypack：日文</a></p>
<h2 id="memorypackorder"><a class="header" href="#memorypackorder">MemoryPackOrder</a></h2>
<blockquote>
<p>没有必要不要使用，当存在继承关系时，中途修改某个字段的 Order 将导致编号错乱，不易维护</p>
</blockquote>
<p>默认序列化是按照定义的属性或者字段的顺序来序列化的，如果要自定义属性或者字段的序列化顺序，可以使用 <code>MemoryPackOrder</code></p>
<pre><code class="language-c#">    /*
    使用 MemoryPackOrder
    */
    [MemoryPackable(generateType: GenerateType.VersionTolerant, SerializeLayout.Explicit)]
    public partial class TestData
    {
        [MemoryPack.MemoryPackOrder(1)]
        public int  Num { get; set; }
        [MemoryPack.MemoryPackOrder(0)]
        public string Name { get; set; }

        [MemoryPack.MemoryPackIgnore]
        public string NoSeriProp { get; set; }
    }
</code></pre>
<ul>
<li><strong>SerializeLayout.Explicit</strong>： 标识自定义布局</li>
<li>先序列化 <code>Name</code> ，后序列化 <code>Num</code></li>
</ul>
<p><strong>注意事项：</strong> 在 ASP.NET 中使用时（HttpClient 网络传输），上述的结构没问题，但是如果不使用 <code>MemoryPackOrder</code> 时会报错，后面找到原因是必须给标记了 <code>MemoryPackIgnore</code> 属性的字段一个默认值才正常</p>
<pre><code class="language-c#">    /*
    不使用 MemoryPackOrder
    */
    [MemoryPackable]
    public partial class TestData
    {
        public int  Num { get; set; }
        public string Name { get; set; }

        [MemoryPack.MemoryPackIgnore]
        public string NoSeriProp { get; set; } = string.Empty; //给定默认值
    }
</code></pre>
<h2 id="与-aspnet-core-一起使用"><a class="header" href="#与-aspnet-core-一起使用">与 Asp.net Core 一起使用</a></h2>
<h3 id="基础"><a class="header" href="#基础">基础</a></h3>
<p><strong>优点</strong>：</p>
<ul>
<li>支持多态</li>
<li>包小</li>
<li>可以嵌套等</li>
<li>支持AOT(for unity)</li>
</ul>
<p>使用默认设置（还包括 OpenAPI）创建 ASP.NET Core Web API (.NET 6-8) 项目。除了安装 MemoryPack 之外，还包括 ASP.NET Core 的包。</p>
<pre><code class="language-shell">PM&gt; Install-Package MemoryPack.AspNetCoreMvcFormatter
</code></pre>
<p>如下所示更改 Program.cs 中的 AddControllers。</p>
<pre><code>builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(true));
});
</code></pre>
<p>将 WeatherForecast 类设为部分类并添加 MemoryPackable 属性。</p>
<pre><code>[MemoryPackable]
public partial class WeatherForecast
{
    public DateTime Date { get; set; }
    public int TemperatureC { get; set; }
    public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);
    public string? Summary { get; set; }
}
</code></pre>
<p><img src="dotnet/packages/image/memorypack/1718327837738.png" alt="1718327837738" /></p>
<p>application/x-memorypack可以看到它已经被添加到 Media type 中了。</p>
<p><strong>测试调用该方法</strong></p>
<p><img src="dotnet/packages/image/memorypack/1718327868816.png" alt="1718327868816" /></p>
<p>它作为 <code>application/x-memorypack</code> 返回。二进制数据按原样在响应正文中输出。 当然，如果将Media type改为JSON，也会返回可读的数据。</p>
<p>它可以很容易地转换成 MemoryPack。</p>
<p>顺便说一句，JSON 的主体大小约为 493 字节，MemoryPack 的主体大小约为 150 字节。</p>
<p><img src="dotnet/packages/image/memorypack/1718327894976.png" alt="1718327894976" /></p>
<p><img src="dotnet/packages/image/memorypack/1718327901785.png" alt="1718327901785" /></p>
<p>WeatherForecast 并不准确，因为数据是随机的，但它肯定更小。嗯，很自然，字段名字符串会随着记录数的减少而减少，所以如果有几十个字段，而且名称都很长，减少的效果会相当显着。</p>
<p>这是令人惊奇的，因为流经此过程的数据量减少了。</p>
<p><strong>配置既可以接收Json和二进制文件</strong></p>
<pre><code>new MemoryPackOutputFormatter(true)
</code></pre>
<p>如果未使用 checkContentType=true 生成 OutputFormatter，MemoryPack 将接管所有输出处理，因此即使您指定 JSON，也会返回二进制文件，您会感到失望。</p>
<h3 id="支持客户端typescript"><a class="header" href="#支持客户端typescript">支持客户端TypeScript</a></h3>
<p>服务端是 ASP.NET Core，客户端却是 React 或 Vue。 使用 <code>GenerateTypeScript</code> 特性，详见官网。</p>
<pre><code class="language-c#">[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}

public enum Gender
{
    Male, Female, Other
}
</code></pre>
<h3 id="httpclient-中解析异常"><a class="header" href="#httpclient-中解析异常">HttpClient 中解析异常</a></h3>
<h4 id="给标记memorypackignore的属性指定默认值"><a class="header" href="#给标记memorypackignore的属性指定默认值">给标记MemoryPackIgnore的属性指定默认值</a></h4>
<p>在使用 <code>HttpClient</code> 网络传输时，出现以下情况</p>
<ul>
<li>当使用 <code>MemoryPackOrder</code>　时，被标记 <code>MemoryPackIgnore</code> 的属性不给默认值，使用正常，如下：</li>
</ul>
<pre><code class="language-c#">    /*
    使用 MemoryPackOrder
    */
    [MemoryPackable(generateType: GenerateType.VersionTolerant, SerializeLayout.Explicit)]
    public partial class TestData
    {
        [MemoryPack.MemoryPackOrder(1)]
        public int  Num { get; set; }
        [MemoryPack.MemoryPackOrder(0)]
        public string Name { get; set; }

        [MemoryPack.MemoryPackIgnore]
        public string NoSeriProp { get; set; }
    }
</code></pre>
<ul>
<li>不使用 <code>MemoryPackOrder</code> 时，被标记 <code>MemoryPackIgnore</code> 的属性不给默认值，使用异常，解析错误，必须如下给定一个默认值：</li>
</ul>
<pre><code class="language-c#">    /*
    不使用 MemoryPackOrder
    */
    [MemoryPackable]
    public partial class TestData
    {
        public int  Num { get; set; }
        public string Name { get; set; }

        [MemoryPack.MemoryPackIgnore]
        public string NoSeriProp { get; set; } = string.Empty; //给定默认值
    }
</code></pre>
<h4 id="list-属性异常"><a class="header" href="#list-属性异常">List<T> 属性异常</a></h4>
<blockquote>
<p>Ver 1.21.1</p>
</blockquote>
<p><strong>现象描述</strong> ：定义一个类 <code>A</code>，从服务器获取 <code>List&lt;A&gt;</code> 时正常，从客户端向服务器 <strong>Post</strong> <code>A</code> 时失败，（这里没有验证从服务器获取 单个 <code>A</code> 和从客户端向服务器Post <code>List&lt;A&gt;</code> 的情况）</p>
<p><strong>查找问题步骤</strong> ：</p>
<ol>
<li>若类中存在被标记为 <code>MemoryPackIgnore</code> 的属性，确定给其指定了默认值</li>
<li>逐步将属性设置为 null 进行测试，如果都还有问题进行下一步</li>
<li>从新构建一个类，将原类中所有的属性拷贝过来，先进行一次测试，若存在问题，下一步</li>
<li>在构建的新类中，逐步删除复杂结构（List<T>,[],枚举，其他类或者数据结构）的属性进行测试</li>
</ol>
<p><strong>找到的原因</strong> ：在 <code>A</code> 中类型为 <code>List&lt;B&gt;</code> 的属性，当存在数据时就会异常（根本原因不清楚），设置为null时就正常</p>
<p><strong>解决办法</strong> ：</p>
<ol>
<li>看存在异常的属性在当前传中是否会使用到，如果未使用到将其设置为 <code>null</code></li>
<li>重新构建一个类，仅包含需要使用到的属性</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务端收到的消息滞后一条"><a class="header" href="#服务端收到的消息滞后一条">服务端收到的消息滞后一条</a></h1>
<p>第一条消息服务端没收到，客户端发送第二条时，服务端收到上一条的消息？</p>
<h2 id="原因"><a class="header" href="#原因">原因：</a></h2>
<p>使用了SSL，加密后出现上述问题，不使用就正常，未测试具体原因。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>
<p><a href="https://stackexchange.github.io/StackExchange.Redis/Basics">官方文档</a></p>
</li>
<li>
<p><a href="https://www.gitbook.com/?utm_source=legacy&amp;utm_medium=redirect&amp;utm_campaign=close_legacy">伪中文文档</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_27461747/article/details/89441778">CSDN文章</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="excel插件-epplus"><a class="header" href="#excel插件-epplus">Excel插件-EPPlus</a></h1>
<ol>
<li>
<p>使用前需要设置证书声明</p>
</li>
<li>
<p>一个文件中的sheet,索引是从0开始的</p>
</li>
<li>
<p>表里面的内容，行和列的索引都是从1开始的</p>
</li>
<li>
<p>当new ExcelPackage 时，若没有文件会直接创建</p>
</li>
<li>
<p>在 wpf 和 unity 端都比较好用， unity 端可以用这个来读取配置的excel文件，转换为Unity 多序列化文件，或者 json ，注意exce只是用来配置文件，真正使用的还是json等通用的文件格式，因为excel 在有些平台不支持，或者说使用的插件不支持，且excel文件比较大，冗余数据多</p>
</li>
</ol>
<p>代码：</p>
<pre><code>public static List&lt;string[]&gt; ReadAllInfo(int hostId)
{
    ExcelPackage.LicenseContext = LicenseContext.NonCommercial;//声明非商业证书

    FileInfo fileInfo = new FileInfo(excelPath);
    if(File.Exists(fileInfo.FullName) == false)
    {
        return null;
    }
    using (ExcelPackage ep = new ExcelPackage(fileInfo))
    {
        List&lt;string[]&gt; listArr = new List&lt;string[]&gt;();
        ExcelWorksheet ipSheet = ep.Workbook.Worksheets[hostId];
        if (ipSheet.Cells[2, 1].Value == null) return null;
        int workStaCount = int.Parse(ipSheet.Cells[2, 3].Value.ToString());
        int count = 3 + workStaCount;
        int row = 1;
        while (true)
        {
            if (ipSheet.Cells[row, 1].Value != null)
            {
                string[] rowData = new string[count];
                for (int i = 0; i &lt; count; i++)//遍历列
                {
                    if (ipSheet.Cells[row, i + 1].Value != null)
                        rowData[i] = ipSheet.Cells[row, i + 1].Value.ToString();
                }
                listArr.Add(rowData);
                row++;
            }
            else
            {
                break;
            }
        }
        return listArr;
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wpf"><a class="header" href="#wpf">WPF</a></h1>
<h2 id="使用-svg"><a class="header" href="#使用-svg">使用 SVG</a></h2>
<ul>
<li>
<p>通过 <a href="https://github.com/BerndK/SvgToXaml.git">SvgToXaml 工具</a> 将 <strong>SVG</strong> 图片转为 <strong>xaml</strong> 资源</p>
</li>
<li>
<p>打开工具，在底部选择 <strong>SVG</strong> 图片</p>
<p><img src="dotnet/wpf/image.png" alt="alt text" /></p>
</li>
<li>
<p>在弹出的窗口中，切换到 <strong>XAML</strong> 查看代码</p>
<p><img src="dotnet/wpf/image-1.png" alt="alt text" /></p>
</li>
<li>
<p>集成到资源字典，接下来我们可以把转换得到了xaml 集成到资源字典中，以下是直接放在 <code>App.xaml</code> 中（可创建一个资源文件来存放）：</p>
</li>
</ul>
<pre><code class="language-xml">&lt;Application x:Class="WpfApp3.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:WpfApp3"
             StartupUri="MainWindow.xaml"&gt;
    &lt;Application.Resources&gt;

        &lt;DrawingImage x:Key="XX"&gt;
            &lt;DrawingImage.Drawing&gt;
                &lt;DrawingGroup ClipGeometry="M0,0 V25 H120 V0 H0 Z"&gt;
                    &lt;GeometryDrawing Brush="#FFFFFFFF" Geometry="F1 M120,25z M0,0z M0,25L120,25 120,0 0,0 0,25z" /&gt;
                    &lt;DrawingGroup Opacity="1"&gt;
                        &lt;GeometryDrawing Brush="#FFB0B0B0" Geometry="F1 M120,25z M0,0z M18.91,8.2C18.77,8.71,18.59,9.24,18.38,9.75L15.63,9.75 15.63,10.47 18.05,10.47C17.41,11.75 16.53,12.94 15.38,13.74 15.5,13.91 15.69,14.23 15.77,14.43 16.19,14.13 16.58,13.79 16.93,13.42L16.93,17.36 17.68,17.36 17.68,12.53C18.15,11.89,18.56,11.19,18.9,10.47L24.39,10.47 24.39,9.75 19.21,9.75C19.39,9.3,19.55,8.84,19.69,8.39L18.91,8.2z M20.98,10.99L20.98,12.92 18.73,12.92 18.73,13.62 20.98,13.62 20.98,16.46 18.33,16.46 18.33,17.16 24.38,17.16 24.38,16.46 21.73,16.46 21.73,13.62 24,13.62 24,12.92 21.73,12.92 21.73,10.99 20.98,10.99z M25.58,10.08L25.58,10.78 29.47,10.78 29.47,10.08 25.58,10.08z M25.98,11.35C26.21,12.48,26.42,13.95,26.46,14.93L27.09,14.82C27.03,13.83,26.82,12.38,26.58,11.24L25.98,11.35z M26.75,8.45C27.02,8.92,27.31,9.57,27.43,9.98L28.11,9.74C27.99,9.33,27.69,8.72,27.4,8.25L26.75,8.45z M28.3,11.11C28.17,12.34 27.9,14.1 27.64,15.16 26.82,15.36 26.05,15.53 25.47,15.65L25.65,16.4C26.69,16.14,28.1,15.78,29.43,15.44L29.36,14.75 28.28,15.01C28.53,13.96,28.81,12.43,29,11.25L28.3,11.11z M29.67,12.98L29.67,17.39 30.4,17.39 30.4,16.91 33.42,16.91 33.42,17.35 34.18,17.35 34.18,12.98 32.06,12.98 32.06,10.99 34.6,10.99 34.6,10.27 32.06,10.27 32.06,8.19 31.29,8.19 31.29,12.98 29.67,12.98z M30.4,16.21L30.4,13.69 33.42,13.69 33.42,16.21 30.4,16.21z M39.11,12.26C39.2,12.18,39.52,12.14,39.98,12.14L40.69,12.14C40.27,13.24,39.55,14.15,38.63,14.75L38.51,14.17 37.44,14.57 37.44,11.35 38.54,11.35 38.54,10.64 37.44,10.64 37.44,8.32 36.73,8.32 36.73,10.64 35.5,10.64 35.5,11.35 36.73,11.35 36.73,14.83C36.21,15.02,35.74,15.19,35.36,15.31L35.61,16.07C36.47,15.73,37.6,15.28,38.65,14.86L38.63,14.77C38.79,14.87 39.06,15.07 39.17,15.19 40.13,14.49 40.95,13.44 41.4,12.14L42.24,12.14C41.61,14.28 40.49,15.94 38.79,16.96 38.96,17.06 39.25,17.27 39.37,17.39 41.06,16.26 42.25,14.49 42.94,12.14L43.62,12.14C43.44,15.08 43.23,16.22 42.97,16.5 42.87,16.62 42.78,16.65 42.62,16.64 42.44,16.64 42.06,16.64 41.65,16.6 41.77,16.8 41.85,17.1 41.86,17.31 42.28,17.33 42.69,17.34 42.93,17.31 43.22,17.28 43.42,17.2 43.61,16.96 43.96,16.55 44.17,15.31 44.38,11.8 44.39,11.69 44.4,11.43 44.4,11.43L40.38,11.43C41.37,10.8,42.42,9.98,43.49,9.03L42.93,8.61 42.77,8.67 38.75,8.67 38.75,9.38 41.97,9.38C41.1,10.17 40.13,10.85 39.8,11.06 39.41,11.31 39.04,11.52 38.79,11.55 38.89,11.74 39.05,12.09 39.11,12.26z M48.75,13.81C49.55,13.98,50.57,14.33,51.13,14.61L51.44,14.1C50.88,13.84,49.87,13.51,49.07,13.35L48.75,13.81z M47.75,15.08C49.13,15.25,50.86,15.65,51.82,15.99L52.15,15.43C51.18,15.11,49.45,14.72,48.1,14.57L47.75,15.08z M45.84,8.64L45.84,17.4 46.56,17.4 46.56,16.98 53.42,16.98 53.42,17.4 54.17,17.4 54.17,8.64 45.84,8.64z M46.56,16.31L46.56,9.32 53.42,9.32 53.42,16.31 46.56,16.31z M49.14,9.52C48.64,10.34 47.78,11.12 46.92,11.63 47.08,11.73 47.34,11.96 47.45,12.08 47.75,11.88 48.06,11.64 48.37,11.37 48.67,11.69 49.04,11.99 49.44,12.26 48.59,12.66 47.63,12.96 46.74,13.14 46.87,13.28 47.03,13.57 47.1,13.75 48.08,13.52 49.13,13.15 50.08,12.64 50.91,13.09 51.86,13.43 52.81,13.64 52.9,13.46 53.09,13.2 53.23,13.07 52.35,12.91 51.47,12.64 50.69,12.28 51.44,11.79 52.07,11.22 52.49,10.54L52.06,10.29 51.95,10.32 49.36,10.32C49.51,10.13,49.65,9.94,49.77,9.74L49.14,9.52z M48.78,10.97L48.85,10.9 51.44,10.9C51.08,11.29 50.6,11.64 50.06,11.95 49.55,11.66 49.11,11.33 48.78,10.97z M59.27,8.35L59.27,16.17 55.51,16.17 55.51,16.92 64.5,16.92 64.5,16.17 60.06,16.17 60.06,12.19 63.81,12.19 63.81,11.44 60.06,11.44 60.06,8.35 59.27,8.35z M65.61,8.95C66.19,9.44,66.87,10.14,67.16,10.63L67.78,10.16C67.46,9.68,66.77,9,66.18,8.54L65.61,8.95z M69.46,8.5C69.22,9.39 68.8,10.27 68.26,10.86 68.44,10.95 68.76,11.15 68.9,11.26 69.13,10.98 69.35,10.63 69.55,10.24L71.03,10.24 71.03,11.7 68.2,11.7 68.2,12.37 70.01,12.37C69.84,13.68 69.43,14.63 67.93,15.16 68.09,15.3 68.31,15.58 68.39,15.77 70.07,15.11 70.57,13.96 70.76,12.37L71.79,12.37 71.79,14.69C71.79,15.45 71.96,15.67 72.71,15.67 72.86,15.67 73.54,15.67 73.69,15.67 74.32,15.67 74.52,15.35 74.59,14.08 74.38,14.03 74.07,13.92 73.93,13.78 73.9,14.83 73.86,14.97 73.61,14.97 73.47,14.97 72.92,14.97 72.82,14.97 72.56,14.97 72.53,14.94 72.53,14.69L72.53,12.37 74.51,12.37 74.51,11.7 71.78,11.7 71.78,10.24 74.09,10.24 74.09,9.59 71.78,9.59 71.78,8.24 71.03,8.24 71.03,9.59 69.85,9.59C69.98,9.29,70.09,8.97,70.18,8.65L69.46,8.5z M67.51,12.04L65.56,12.04 65.56,12.74 66.79,12.74 66.79,15.77C66.36,15.97,65.9,16.33,65.45,16.75L65.95,17.4C66.52,16.78 67.06,16.26 67.43,16.26 67.65,16.26 67.96,16.55 68.35,16.79 69.01,17.18 69.84,17.28 71,17.28 71.98,17.28 73.67,17.23 74.45,17.18 74.46,16.96 74.58,16.59 74.66,16.4 73.67,16.5 72.15,16.57 71.01,16.57 69.95,16.57 69.11,16.51 68.49,16.14 68.01,15.86 67.78,15.62 67.51,15.6L67.51,12.04z M76.77,8.21L76.77,10.21 75.46,10.21 75.46,10.91 76.77,10.91 76.77,13.04C76.24,13.2,75.75,13.34,75.36,13.45L75.55,14.18 76.77,13.79 76.77,16.48C76.77,16.61 76.72,16.65 76.6,16.66 76.48,16.66 76.09,16.67 75.66,16.65 75.76,16.86 75.85,17.17 75.88,17.36 76.52,17.36 76.91,17.35 77.16,17.22 77.41,17.1 77.5,16.89 77.5,16.48L77.5,13.55 78.66,13.17 78.56,12.48 77.5,12.81 77.5,10.91 78.69,10.91 78.69,10.21 77.5,10.21 77.5,8.21 76.77,8.21z M83.04,9.41C82.68,9.93 82.19,10.39 81.62,10.79 81.1,10.39 80.66,9.93 80.32,9.41L83.04,9.41z M78.96,8.73L78.96,9.41 79.6,9.41C79.97,10.08 80.46,10.66 81.04,11.16 80.26,11.63 79.38,11.98 78.53,12.19 78.67,12.34 78.85,12.62 78.93,12.8 79.84,12.53 80.77,12.13 81.6,11.6 82.38,12.14 83.29,12.55 84.28,12.81 84.38,12.61 84.59,12.33 84.74,12.18 83.8,11.98 82.94,11.64 82.2,11.18 82.99,10.58 83.66,9.83 84.09,8.95L83.64,8.7 83.51,8.73 78.96,8.73z M81.2,12.48L81.2,13.36 79.17,13.36 79.17,14.04 81.2,14.04 81.2,15.07 78.66,15.07 78.66,15.75 81.2,15.75 81.2,17.42 81.95,17.42 81.95,15.75 84.57,15.75 84.57,15.07 81.95,15.07 81.95,14.04 83.85,14.04 83.85,13.36 81.95,13.36 81.95,12.48 81.2,12.48z M94.27,8.74L85.97,8.74 85.97,17.1 94.52,17.1 94.52,16.38 86.71,16.38 86.71,9.47 94.27,9.47 94.27,8.74z M87.59,10.75C88.37,11.39 89.24,12.15 90.05,12.91 89.2,13.77 88.24,14.53 87.26,15.11 87.44,15.24 87.73,15.53 87.86,15.68 88.8,15.06 89.72,14.29 90.58,13.41 91.45,14.24 92.22,15.05 92.72,15.68L93.33,15.13C92.79,14.5 91.98,13.69 91.09,12.86 91.81,12.05 92.47,11.16 93.02,10.23L92.31,9.95C91.83,10.8 91.23,11.62 90.55,12.38 89.74,11.64 88.89,10.92 88.13,10.31L87.59,10.75z M100.38,8.57L100.38,9.78C100.38,10.51 100.22,11.4 99.23,12.06 99.38,12.15 99.66,12.4 99.76,12.54 100.85,11.81 101.08,10.69 101.08,9.8L101.08,9.22 102.48,9.22 102.48,11.1C102.48,11.78 102.61,12.04 103.28,12.04 103.4,12.04 103.89,12.04 104.03,12.04 104.22,12.04 104.43,12.03 104.54,11.99 104.52,11.84 104.5,11.59 104.49,11.41 104.37,11.44 104.15,11.45 104.02,11.45 103.9,11.45 103.46,11.45 103.34,11.45 103.2,11.45 103.17,11.38 103.17,11.11L103.17,8.57 100.38,8.57z M99.67,12.74L99.67,13.39 100.4,13.39 100.01,13.5C100.33,14.34 100.77,15.08 101.34,15.69 100.65,16.22 99.83,16.58 98.93,16.8 99.08,16.95 99.25,17.24 99.33,17.44 100.28,17.17 101.14,16.77 101.87,16.19 102.5,16.72 103.26,17.12 104.13,17.37 104.24,17.18 104.44,16.88 104.61,16.73 103.76,16.53 103.02,16.17 102.39,15.7 103.07,15 103.58,14.08 103.87,12.88L103.4,12.71 103.27,12.74 99.67,12.74z M100.63,13.39L102.97,13.39C102.72,14.12 102.34,14.73 101.85,15.23 101.32,14.71 100.91,14.09 100.63,13.39z M96.18,9.09L96.18,14.92 95.33,15.03 95.46,15.75 96.18,15.63 96.18,17.26 96.91,17.26 96.91,15.51 99.35,15.1 99.31,14.45 96.91,14.81 96.91,13.36 99.15,13.36 99.15,12.68 96.91,12.68 96.91,11.31 99.16,11.31 99.16,10.64 96.91,10.64 96.91,9.55C97.78,9.32,98.73,9.03,99.45,8.7L98.83,8.14C98.21,8.47,97.14,8.85,96.2,9.1L96.18,9.09z" /&gt;
                    &lt;/DrawingGroup&gt;
                &lt;/DrawingGroup&gt;
            &lt;/DrawingImage.Drawing&gt;
        &lt;/DrawingImage&gt;

    &lt;/Application.Resources&gt;
&lt;/Application&gt;

</code></pre>
<ul>
<li>前端使用，实现 TextBox 的水印功能（最好定义一个 <strong>image</strong> 的资源）</li>
</ul>
<pre><code class="language-xml">&lt;Window x:Class="WpfApp3.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApp3"
        mc:Ignorable="d"
        Title="MainWindow" Height="450" Width="800"&gt;
    &lt;Window.Resources&gt;
        &lt;ImageBrush x:Key="watermark" ImageSource="{StaticResource XX}" AlignmentX="Center" Stretch="None" /&gt;
    &lt;/Window.Resources&gt;
    &lt;StackPanel&gt;
        &lt;TextBox Name="myTextBox" TextChanged="OnTextBoxTextChanged" Width="200" Height="25" Background="{StaticResource  watermark}" /&gt;
    &lt;/StackPanel&gt;
&lt;/Window&gt;

</code></pre>
<p>后端添加文本changed处理事件</p>
<pre><code class="language-c#">  private void OnTextBoxTextChanged(object sender, TextChangedEventArgs e)
  {
      if (sender is TextBox box)
      {
          if (string.IsNullOrEmpty(box.Text))
              box.Background = (ImageBrush)FindResource("watermark");
          else
              box.Background = null;
      }
  }
</code></pre>
<h2 id="剪切板错误"><a class="header" href="#剪切板错误">剪切板错误</a></h2>
<blockquote>
<p>❌ WPF剪切板问题-OpenClipboard HRESULT:0x800401D0 (CLIPBRD_E_CANT_OPEN))</p>
</blockquote>
<p>错误示例：</p>
<p><img src="dotnet/wpf/image/%E5%89%AA%E5%88%87%E6%9D%BF/1717641062860.png" alt="1717641062860" /></p>
<p><strong>原实现：</strong></p>
<pre><code class="language-csharp"> Clipboard.SetText(content);
</code></pre>
<p><strong>解决方法：</strong></p>
<pre><code class="language-csharp"> Clipboard.SetDataObject(content);
</code></pre>
<p><strong>参考（其中的处理方式不优）</strong></p>
<p><a href="https://www.cnblogs.com/tranw/p/6150276.html">WPF剪切板问题-OpenClipboard HRESULT:0x800401D0 (CLIPBRD_E_CANT_OPEN))</a></p>
<h2 id="元素焦点问题"><a class="header" href="#元素焦点问题">元素焦点问题</a></h2>
<blockquote>
<p><strong>Focus()</strong> 函数常常设置失败</p>
</blockquote>
<p>通过以下方式可设置成功 <code>pwdBoxPWD</code>  需要设置的UI元素</p>
<pre><code class="language-C#">Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority.Render,
new Action(() =&gt; pwdBoxPWD.Focus()));
</code></pre>
<h2 id="wpf-hardware-acceleration-in-rdp"><a class="header" href="#wpf-hardware-acceleration-in-rdp">WPF hardware acceleration in RDP</a></h2>
<blockquote>
<p>在 .net 8.0 后出现的问题</p>
</blockquote>
<p>调试模式正常运行，发布后无法运行，提示设置硬件加速</p>
<p><a href="https://startdebugging.net/2023/10/wpf-hardware-acceleration-in-rdp/">google 文章</a></p>
<p><strong>解决方案：</strong></p>
<p>在项目中配置此设置RuntimeHostConfigurationOption：</p>
<pre><code class="language-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;ItemGroup&gt;
    &lt;RuntimeHostConfigurationOption Include="Switch.System.Windows.Media.EnableHardwareAccelerationInRdp" Value="true" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>删除所有的文件，再生成</p>
<p><strong>项目示例：</strong></p>
<p>在某项目中，有一组菜单按钮，一个菜单对应一个页面，假设A按钮对应A页面，B按钮对应B页面，同时有个需求，在A页面，按下空格键后代码控制跳转到B页面。</p>
<p><strong>出现问题</strong>：当点击A按钮后，然后按下空格键，不会跳到B页面。</p>
<p><strong>调试结果</strong>：按下空格键后执行代码跳转到B页面后，会再次跳转到A页面。</p>
<p><strong>分析原因</strong>：</p>
<ul>
<li>点击A按钮，此时A按钮获得键盘焦点。</li>
<li>按下空格键，执行跳转到B的代码逻辑，跳转到B页面。</li>
<li>执行完成后，由于A按钮具有焦点会响应键盘，所以会执行A按钮的点击事件，既点击了A按钮，跳转到A页面。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listbox"><a class="header" href="#listbox">ListBox</a></h1>
<p>常用于导航</p>
<p>自定义ItemContainerStyle</p>
<p>在使用ListBox的时候，发现鼠标移入到item上，会有一个很宽的背景，想把它去除，我们自己定义鼠标移入的状态，可以通过 <code>ItemContainerStyle</code> 来定义模板，以下实现一个理论考试的题目选择样式，有如下需求:</p>
<ul>
<li>题目有 未做、已做、正确、错误，四种状态，不同的状态显示不同的背景</li>
<li>鼠标移入有状态变化（因为这里有四种状态，采用鼠标移入的时候，先死一个透明度40的遮罩，或者显示一个边框，否则要基于4种颜色来设计4种不同的over 色）</li>
<li>注意：不能将 <code>ItemContainerStyle</code> 样式设定为： <code>ItemContainerStyle="{x:Null}"</code> ，会引起其他异常。</li>
</ul>
<pre><code class="language-xml"> &lt;ListBox.ItemContainerStyle&gt;
     &lt;Style TargetType="ListBoxItem"&gt;
         &lt;Setter Property="Padding" Value="0"/&gt;
         &lt;Setter Property="BorderThickness" Value="0"/&gt;
         &lt;Setter Property="BorderThickness" Value="0"/&gt;
         &lt;Setter Property="Template" &gt;
             &lt;Setter.Value&gt;
                 &lt;ControlTemplate &gt;
                     &lt;Border x:Name="_border"  Style="{StaticResource subnum_border}"&gt;
                         &lt;Grid&gt;
                             &lt;TextBlock   Text="{Binding SubNum}" Style="{StaticResource subnum_text}"/&gt;
                             &lt;Border x:Name="_mask" VerticalAlignment="Stretch" HorizontalAlignment="Stretch" Visibility="Collapsed" 
                                 Opacity="0.4" Background="#FFF7E9C2"/&gt;
                         &lt;/Grid&gt;
                     &lt;/Border&gt;
                     &lt;ControlTemplate.Triggers&gt;

                         &lt;!--未做--&gt;
                         &lt;DataTrigger Binding="{Binding OperateState}" Value="0"&gt;
                             &lt;Setter TargetName="_border" Property="Background" Value="#FFB9B9B9"/&gt;
                         &lt;/DataTrigger&gt;
                         &lt;!--已做--&gt;
                         &lt;DataTrigger Binding="{Binding OperateState}" Value="1"&gt;
                             &lt;Setter TargetName="_border" Property="Background" Value="#FF428DD2"/&gt;

                         &lt;/DataTrigger&gt;
                         &lt;!--正确--&gt;
                         &lt;DataTrigger Binding="{Binding OperateState}" Value="2"&gt;
                             &lt;Setter TargetName="_border" Property="Background" Value="Green"/&gt;

                         &lt;/DataTrigger&gt;
                         &lt;!--错误--&gt;
                         &lt;DataTrigger Binding="{Binding OperateState}" Value="3"&gt;
                             &lt;Setter TargetName="_border" Property="Background" Value="#FFAD1E1E"/&gt;
                         &lt;/DataTrigger&gt;

                         &lt;!-- 鼠标悬停时，改变背景色  --&gt;
                         &lt;Trigger Property="IsMouseOver" Value="True"&gt;
                             &lt;Setter TargetName="_mask" Property="Visibility" Value="Visible" /&gt;
                         &lt;/Trigger&gt;
                     &lt;/ControlTemplate.Triggers&gt;

                 &lt;/ControlTemplate&gt;

             &lt;/Setter.Value&gt;
         &lt;/Setter&gt;
         &lt;Style.Triggers&gt;
             &lt;Trigger Property="IsMouseOver" Value="True"&gt;
                 &lt;!-- 当鼠标移入时重置背景色为透明 --&gt;
                 &lt;Setter Property="Background" Value="Transparent"/&gt;
                 &lt;!-- 其他的属性重置 --&gt;
             &lt;/Trigger&gt;
         &lt;/Style.Triggers&gt;
     &lt;/Style&gt;
 &lt;/ListBox.ItemContainerStyle&gt;
</code></pre>
<h3 id="设置itemcontainerstyle-为null出现问题"><a class="header" href="#设置itemcontainerstyle-为null出现问题">设置ItemContainerStyle 为null(出现问题)</a></h3>
<p>这种方式，我们可以单独定义我们的item 模板，如果不自定义模板，还需要，重置 ListItem的风格</p>
<pre><code class="language-xml">
  &lt;!-- 自定义 ListBoxItem 的控件模板  去除自带的模板样式--&gt;
  &lt;Style TargetType="ListBoxItem"&gt;
      &lt;Setter Property="Template"&gt;
          &lt;Setter.Value&gt;
              &lt;ControlTemplate TargetType="ListBoxItem"&gt;
                  &lt;ContentPresenter /&gt;
              &lt;/ControlTemplate&gt;
          &lt;/Setter.Value&gt;
      &lt;/Setter&gt;
  &lt;/Style&gt;

</code></pre>
<pre><code class="language-xml">&lt;ListBox ItemsSource="{Binding YourItems}"
         ItemTemplateSelector="{StaticResource MyTemplateSelector}"
         ItemContainerStyle="{x:Null}" /&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listview"><a class="header" href="#listview">ListView</a></h1>
<h2 id="表头动态显示和隐藏"><a class="header" href="#表头动态显示和隐藏">表头动态显示和隐藏</a></h2>
<p>在WPF中，表头不在VisualTree里面，无法通过绑定属性值动态控制列的显示隐藏，此示例通过附件属性实现该功能， 以 <code>ListView</code>为例，其他具有表头的组件</p>
<p>如DataGrid应类似处理。</p>
<ol>
<li>添加附加属性</li>
</ol>
<pre><code class="language-C#">public class GridViewColumnVisibilityManager
{
    static void UpdateListView(ListView lv)
    {
        GridView gridview = lv.View as GridView;
        if (gridview == null || gridview.Columns == null) return;
        List&lt;GridViewColumn&gt; toRemove = new List&lt;GridViewColumn&gt;();
        foreach (GridViewColumn gc in gridview.Columns)
        {
            if (GetIsVisible(gc) == false)
            {
                toRemove.Add(gc);
            }
        }
        foreach (GridViewColumn gc in toRemove)
        {
            gridview.Columns.Remove(gc);
        }
    }

    public static bool GetIsVisible(DependencyObject obj)
    {
        return (bool)obj.GetValue(IsVisibleProperty);
    }

    public static void SetIsVisible(DependencyObject obj, bool value)
    {
        obj.SetValue(IsVisibleProperty, value);
    }

    public static readonly DependencyProperty IsVisibleProperty =
        DependencyProperty.RegisterAttached("IsVisible", typeof(bool), typeof(GridViewColumnVisibilityManager), new UIPropertyMetadata(true));


    public static bool GetEnabled(DependencyObject obj)
    {
        return (bool)obj.GetValue(EnabledProperty);
    }

    public static void SetEnabled(DependencyObject obj, bool value)
    {
        obj.SetValue(EnabledProperty, value);
    }

    public static readonly DependencyProperty EnabledProperty =
        DependencyProperty.RegisterAttached("Enabled", typeof(bool), typeof(GridViewColumnVisibilityManager), new UIPropertyMetadata(false,
            new PropertyChangedCallback(OnEnabledChanged)));

    private static void OnEnabledChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e)
    {
        ListView view = obj as ListView;
        if (view != null)
        {
            bool enabled = (bool)e.NewValue;
            if (enabled)
            {
                view.Loaded += (sender, e2) =&gt;
                {
                    UpdateListView((ListView)sender);
                };
                view.TargetUpdated += (sender, e2) =&gt;
                {
                    UpdateListView((ListView)sender);
                };
                view.DataContextChanged += (sender, e2) =&gt;
                {
                    UpdateListView((ListView)sender);
                };
            }
        }
    }
}
</code></pre>
<ol>
<li>前端使用</li>
</ol>
<ul>
<li>引入附加属性脚本的命名空间 <code>xmlns:foo="clr-namespace:LotteryPredict.Control"</code></li>
<li>在ListView里面使用附件属性 用  <code>foo:GridViewColumnVisibilityManager.Enabled="true"</code>,启用附件属性的功能</li>
<li>GridViewColumn 中使用  <code>foo:GridViewColumnVisibilityManager.IsVisible="{Bindg IsFullAuth}"</code>控制该列</li>
</ul>
<pre><code class="language-XML">...
xmlns:foo="clr-namespace:LotteryPredict.Control"
...
 &lt;ListView Grid.Row="1" ItemContainerStyle="{StaticResource CenterLVItemStyle}" ItemsSource="{Binding CurVersionCatalogs}"
            foo:GridViewColumnVisibilityManager.Enabled="True"&gt;
            ...
             &lt;GridViewColumn Header="目录名称" DisplayMemberBinding="{Binding Name}" Width="110" 
                 foo:GridViewColumnVisibilityManager.IsVisible="{Binding IsFullAuth}"
                 &gt;&lt;/GridViewColumn&gt;
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设置项目版本号"><a class="header" href="#设置项目版本号">设置项目版本号</a></h1>
<ul>
<li>可以在项目属性面板上设置（一般在包选项卡下），这种方式没找到产品版本号的设置</li>
<li>可直接编辑项目文件，以下为编辑项目文件案例，这种方式可直接设置各种版本号</li>
</ul>
<p><strong>框架：. net 6.0</strong></p>
<p>添加版本号，可以在测试的时候确定当前版本</p>
<ol>
<li>可以在属性面板中设置(只看到了文件版本和程序集版本号的设置)</li>
<li>也可以直接在文件中编辑</li>
</ol>
<pre><code class="language-C#">&lt;PropertyGroup&gt;
  &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
  &lt;TargetFramework&gt;net6.0-windows&lt;/TargetFramework&gt;
  &lt;UseWPF&gt;true&lt;/UseWPF&gt;
  &lt;ApplicationIcon&gt;sc.ico&lt;/ApplicationIcon&gt;
  &lt;NeutralLanguage&gt;zh-CN&lt;/NeutralLanguage&gt;
  &lt;Version&gt;2.0.0&lt;/Version&gt;
  &lt;AssemblyVersion&gt;2.0.0.0&lt;/AssemblyVersion&gt;
  &lt;FileVersion&gt;2.0.0.0&lt;/FileVersion&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p><img src="dotnet/wpf/image/%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E5%8F%B7/1717635499500.png" alt="1717635499500" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资源引用"><a class="header" href="#资源引用">资源引用</a></h1>
<p>WPF中的资源包含很多，如图片、字体、声音，以及样式、模板等很多，在使用的时候常常出现很多问题。</p>
<h2 id="资源路径"><a class="header" href="#资源路径">资源路径</a></h2>
<p>在WPF开发中，对资源的管理非常重要，当我们存在多个项目时，最好是把所有的资源都放在一个基础项目中进行管理，方便维护。</p>
<p>正确的做法使用</p>
<pre><code class="language-XML">pack://application:,,,/程序集名称;component/资源路径名
</code></pre>
<h3 id="图片资源路径"><a class="header" href="#图片资源路径">图片资源路径</a></h3>
<p>存在两个项目</p>
<ul>
<li>基础项目名称：Demo.Infrastructure</li>
<li>主项目 Demo</li>
</ul>
<p>所有的资源在 <code>Demo.Infrastructure</code>  中定义</p>
<ul>
<li>正确的使用</li>
</ul>
<pre><code class="language-XML">    &lt;UserControl.Background&gt;
        &lt;!----&gt;
        &lt;ImageBrush ImageSource="pack://application:,,,/
        Demo.Infrastructure;component/images/login_bg.png"/&gt;
    &lt;/UserControl.Background&gt;
</code></pre>
<ul>
<li>错误的使用（不加 <strong>pack://application:,,,</strong>）此时为相对路径，在编辑模式下可以看到图片，但是运行后不显示</li>
</ul>
<pre><code class="language-XML"> &lt;UserControl.Background&gt;
        &lt;!----&gt;
        &lt;ImageBrush ImageSource="/
        Demo.Infrastructure;component/images/login_bg.png"/&gt;
    &lt;/UserControl.Background&gt;
</code></pre>
<ul>
<li>错误的使用（不加 <strong>pack://application:,,,</strong> 和命名空间）</li>
</ul>
<pre><code class="language-XML"> &lt;UserControl.Background&gt;
        &lt;!----&gt;
        &lt;ImageBrush ImageSource="images/login_bg.png"/&gt;
    &lt;/UserControl.Background&gt;
</code></pre>
<h3 id="字体资源路径"><a class="header" href="#字体资源路径">字体资源路径</a></h3>
<p>可以下载阿里巴巴的字体文件，下载后将ttf文件拷贝到项目中</p>
<pre><code class="language-Toml">
&lt;TextBlock Text="&amp;#xe657;" FontFamily="{StaticResource iconfont}" FontSize="14" Foreground="Red" VerticalAlignment="Center" /&gt;
&lt;TextBlock Text="&amp;#xe657;" FontFamily="/OESTS.Modules.Login;component/fonts/#iconfont" FontSize="14" Foreground="Red" VerticalAlignment="Center" /&gt;
&lt;TextBlock Text="&amp;#xe657;" FontFamily="/fonts/#iconfont" FontSize="14" Foreground="Red" VerticalAlignment="Center"/&gt;
</code></pre>
<h3 id="loadcomponent使用的路径"><a class="header" href="#loadcomponent使用的路径">LoadComponent使用的路径</a></h3>
<p>加载组件函数，可以加载一个xaml文件，这里页存在一个资源路径的问题，此方法仅能使用相对路径，不能使用觉得路径</p>
<p><strong>案例</strong>：需求加载一个流文档控件的文件资源，</p>
<p>文件名为flowdoc.xaml，如下</p>
<pre><code class="language-XML">&lt;FlowDocument xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
                xmlns:sys="clr-namespace:System;assembly=mscorlib"
                TextOptions.TextFormattingMode="Display" &gt;
    &lt;Paragraph&gt;
        &lt;Run Text="加载测试" &gt;&lt;/Run&gt;
    &lt;/Paragraph&gt;
&lt;/FlowDocument&gt;
</code></pre>
<ul>
<li>当只有一个项目时，若文件存在项目的resources文件中，加载方式如下</li>
</ul>
<pre><code class="language-C#">  FlowDocument doc = (FlowDocument)Application.LoadComponent(new Uri("/resources/flowdoc.xaml", UriKind.Relative));
</code></pre>
<ul>
<li>当存在多个项目，如使用了Prism框架，在一个模块项目中加载时（模块项目的程序集为：DemoModule）</li>
</ul>
<pre><code class="language-C#">//正确的做法
FlowDocument doc = (FlowDocument)Application.LoadComponent(
new Uri("/DemoModule;component/resources/flowdoc.xaml",
UriKind.Relative));

//错误的做法，不能加pack://application:,,,，加了后为绝对路径
FlowDocument doc = (FlowDocument)Application.LoadComponent(
new Uri("pack://application:,,,DemoModule;component/resources/flowdoc.xaml", 
UriKind.Relative));
</code></pre>
<h2 id="资源的引用方式"><a class="header" href="#资源的引用方式">资源的引用方式</a></h2>
<ul>
<li>本地添加模板目录：分别创建模板对象。</li>
<li>App.xaml中添加模板目录，创建全局模板对象，导致大家的数据相同。</li>
<li>对于样式、转换器、模板选择器等，在App.xaml添加目录比较合适。</li>
<li>对于模板的使用，在本地添加模板目录不会出现问题。</li>
<li>如果两者都添加，本地添加的起作用。</li>
</ul>
<p><strong>场景描述：</strong> 当前有两个页面（AView,BView）的布局相同，数据不同，定义了一个通用模板为 <code>ContentTemplate</code>， 定义了通用模板，key 为 <code>contentView</code></p>
<pre><code class="language-xml">&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:local="clr-namespace:ScreenControlE" &gt;
    &lt;Grid x:Key="contentView"&gt;

       &lt;TextBlock Text="{Binding Path=Content}" FontSize="14" Foreground="Red" VerticalAlignment="Center" /&gt;

    &lt;/Grid&gt;
&lt;/ResourceDictionary&gt;
</code></pre>
<h3 id="ab页面在本地添加模板目录"><a class="header" href="#ab页面在本地添加模板目录">A、B页面在本地添加模板目录</a></h3>
<ul>
<li>A、B页面的前端（这里使用了Prsim框架），在本地添加了资源目录，并引用 <code>contentView</code>，此时两个页面显示正常，分别显示自己的内容</li>
</ul>
<pre><code class="language-xml">
&lt;UserControl x:Class=" ScreenControlE.Views.NCCView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:prism="http://prismlibrary.com/"       
             prism:ViewModelLocator.AutoWireViewModel="True"&gt;
    &lt;UserControl.Resources&gt;
        &lt;ResourceDictionary Source="/Themes/ContentTemplate.xaml"/&gt;
    &lt;/UserControl.Resources&gt;
    &lt;Grid&gt;
        &lt;ContentControl x:Name="ncc_contentCrl" Content="{StaticResource contentView }"/&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;

</code></pre>
<h3 id="在appxaml中添加模板的目录"><a class="header" href="#在appxaml中添加模板的目录">在App.xaml中添加模板的目录</a></h3>
<ul>
<li>App.xaml</li>
</ul>
<pre><code class="language-xml">&lt;prism:PrismApplication x:Class="ScreenControlE.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:ScreenControlE"
             xmlns:prism="http://prismlibrary.com/" &gt;
    &lt;Application.Resources&gt;
		&lt;ResourceDictionary Source="/Themes/ContentTemplate.xaml"/&gt;

    &lt;/Application.Resources&gt;
&lt;/prism:PrismApplication&gt;

</code></pre>
<ul>
<li>A、B页面的前端（这里使用了Prsim框架），直接引用 <code>contentView</code></li>
</ul>
<pre><code class="language-xml">
&lt;UserControl x:Class=" ScreenControlE.Views.NCCView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:prism="http://prismlibrary.com/"       
             prism:ViewModelLocator.AutoWireViewModel="True"&gt;
 
    &lt;Grid&gt;
        &lt;ContentControl x:Name="ncc_contentCrl" Content="{StaticResource contentView }"/&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;

</code></pre>
<ul>
<li>
<p>两个页面显示了相同的内容，在App.xaml中添加的相当于创建了一个全局变量的对象</p>
</li>
<li>
<p>ViewModel（A为例）</p>
</li>
</ul>
<pre><code class="language-csharp">public class AViewModel : ViewModelBase
{
    public string Content { get; set; } = "A模板"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devexpress"><a class="header" href="#devexpress">DevExpress</a></h1>
<p><a href="https://www.devexpress.com/">官网</a></p>
<p><a href="https://www.evget.com/doclib/s/129/16340">文档手册</a></p>
<h2 id="版本记录"><a class="header" href="#版本记录">版本记录</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>DevExPress</td><td>Framework4.8</td><td>.net 7.0</td><td>.net 8.0</td><td></td></tr>
<tr><td>v23.1</td><td>√</td><td>√</td><td>×</td><td></td></tr>
<tr><td>v23.2(还未发布)</td><td>√</td><td>√</td><td>√</td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="安装和激活"><a class="header" href="#安装和激活">安装和激活</a></h2>
<p>官网下载进行安装，<a href="https://www.evget.com/product/2346/lastly">国内慧都(代理商)下载地址</a> 上下载，目前为23.1版本，还不能支持 .net8.0，如果下面的网址打不开，直接在官网下载最新的即可。</p>
<p>下载（群晖下载）后使用科技进行解锁使用，运行下图中的程序，选择devexpress的版本和vs的版本</p>
<p><img src="dotnet/wpf/image/devexpress/1722506797754.png" alt="1722506797754" /></p>
<h2 id="创建项目"><a class="header" href="#创建项目">创建项目</a></h2>
<p>vs中直接创建DevExpress的模板项目，可以选择使用的.net版本</p>
<p><img src="dotnet/wpf/image/devexpress/1722507105165.png" alt="1722507105165" /></p>
<h2 id="案例"><a class="header" href="#案例">案例</a></h2>
<blockquote>
<p>DevExpress 安装时，提供了一系列案例（包含源码和编译好的exe）</p>
</blockquote>
<p><strong>运行案例程序</strong></p>
<ul>
<li>第一种：在 <code>VS</code> 中直接运行案例程序：</li>
</ul>
<p><img src="dotnet/wpf/assets/devexpress/image-1.png" alt="DevExpress 案例程序" /></p>
<ul>
<li>第二种：在开始菜单中运行案例exe程序（操作略）。</li>
</ul>
<p><strong>查看案例源码</strong></p>
<p>每个案例窗口上可以查看源码或者直接打开源码解决方案，如下图：</p>
<p><img src="dotnet/wpf/assets/devexpress/image-4.png" alt="alt text" /></p>
<p>同时也可以通过开始菜单，所有程序-&gt;DevExpress xx.x 中打开源码路径</p>
<p><img src="dotnet/wpf/assets/devexpress/image.png" alt="DevExpress demo source code" /></p>
<p>路径默认在 <strong>公共用户</strong> 的文档目录下：</p>
<p><code>C:\Users\Public\Documents\DevExpress Demos 23.2</code></p>
<h2 id="汉化"><a class="header" href="#汉化">汉化</a></h2>
<p><strong>网络上教程</strong>：<a href="https://blog.csdn.net/weixin_45132755/article/details/132039135?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-132039135-blog-109551776.235^v43^pc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-132039135-blog-109551776.235^v43^pc_blog_bottom_relevance_base5&amp;utm_relevant_index=5">DevExpress：手把手教你用官方汉化资源做汉化</a></p>
<p><strong>防丢失记录</strong>：</p>
<ul>
<li>
<p>进入官网 <a href="https://www.devexpress.com/MyAccount/">https://www.devexpress.com/MyAccount/</a>，使用账号登录</p>
</li>
<li>
<p>点击 支持（SUPPORT $ DOCS）</p>
</li>
<li>
<p>点击本地化 （Localization）</p>
<p><img src="dotnet/wpf/assets/devexpress/image-2.png" alt="alt text" /></p>
</li>
<li>
<p>选择当前使用的 <strong>DevExpress</strong> 版本和对应的语言</p>
</li>
<li>
<p>中文包相关说明</p>
<ul>
<li>zh-CN：简体中文</li>
<li>zh-hans：简体中文，和zh-CN等价，在net 6.0中发布时，默认已经有一个 zh-hans包，我们只需要使用这个就可以了</li>
<li>zh-hant：繁体中文</li>
</ul>
<p><img src="dotnet/wpf/assets/devexpress/image-3.png" alt="alt text" /></p>
</li>
<li>
<p>点击下载，大概半个小时以邮件的方式发送连接给我们</p>
</li>
<li>
<p>收到邮件后下载（邮件中的附件地址有过期时间），解压后包含源码文件夹 <code>src</code> 和已经发布的汉化文件 <code>dll</code>, 拷贝需要的dll到自己的工程中，如：zh-hans</p>
</li>
<li>
<p>源码可自定义汉化，并且处理一些原本未汉化的内容。</p>
</li>
</ul>
<p><strong>汉化失败处理</strong>：</p>
<p>官方提供的汉化包，有些没有汉化，可以通过提供的源码自己更改汉化。</p>
<p>（1）通过邮件附件中附带的src源码工程添加缺少的汉化，注意工程中勾选了生产签名，取消签名即可。</p>
<p>（2）通过 资源设置 来配置汉化。</p>
<p>Windows 窗口，最小化按钮汉化失败处理对比：</p>
<p>版本：23.2.4 wpf</p>
<p>修改前</p>
<p><img src="dotnet/wpf/image/devexpress/1722507003938.png" alt="1722507003938" /></p>
<p>修改后</p>
<p><img src="dotnet/wpf/image/devexpress/1722507009226.png" alt="1722507009226" /></p>
<h2 id="功能模块"><a class="header" href="#功能模块">功能模块</a></h2>
<h3 id="splashscreen"><a class="header" href="#splashscreen">SplashScreen</a></h3>
<blockquote>
<p>软件启动时的加载界面</p>
</blockquote>
<p><strong>模板自带的启动画面</strong></p>
<p><strong>版本：</strong> 23.2</p>
<p>软件启动时的加载界面，使用官方主题模板创建项目，会有一个启动界面，但是不能修改界面上的公司、版权、版本以及logo等信息，原因是模板中使用的默认画面。</p>
<pre><code class="language-C#"> static App()
 {
     CompatibilitySettings.UseLightweightThemes = true;
     ApplicationThemeHelper.UpdateApplicationThemeName();
     //SplashScreenManager.CreateThemed().ShowOnStartup(); //这里直接默认创建了，但是不能修改信息
 }
</code></pre>
<p><strong>自定义启动加载画面</strong></p>
<blockquote>
<p>根据官方文档（失败）</p>
</blockquote>
<p>自定义启动加载画面，根据官网文档以及下载github上的模板参考后还是没有成功，后续再研究</p>
<p><a href="https://docs.devexpress.com/WPF/401692/mvvm-framework/services/predefined-set/splashscreenmanagerservice">SplashScreenManagerService | WPF Controls | DevExpress Documentation</a></p>
<p><strong>根据脚本中的说明</strong></p>
<p>**版本：**23.2</p>
<p>在创建<code>SplashScreen</code>后，在xaml脚本中有段说明</p>
<pre><code class="language-XML">&lt;!-- To show the splash screen on the application startup, add the following code to App.xaml.cs:

static App() {

  var splashScreenViewModel = new DXSplashScreenViewModel() { Title = "MyApplication" };

  SplashScreenManager.Create(() =&gt; new SplashScreen(), splashScreenViewModel).ShowOnStartup();

}

Refer to the following articles for more information:

  [docs.devexpress.com/WPF/401685/controls-and-libraries/windows-and-utility-controls/splash-screen-manager?v=20.1#show-splash-screen](http://docs.devexpress.com/WPF/401685/controls-and-libraries/windows-and-utility-controls/splash-screen-manager?v=20.1#show-splash-screen)

  [docs.devexpress.com/WPF/401692/mvvm-framework/services/predefined-set/splashscreenmanagerservice?v=20.1#show-splash-screen-from-view-model](http://docs.devexpress.com/WPF/401692/mvvm-framework/services/predefined-set/splashscreenmanagerservice?v=20.1#show-splash-screen-from-view-model)

NOTE: SplashScreenWindow uses its own theme mechanism to speed up initialization.

For this reason, the current theme will not be applied to any DevExpress or standard controls placed inside the splash screen.

To apply the default theme mechanism to the splash screen content, set AllowTheming="True" for SplashScreenWindow. --&gt;
</code></pre>
<p>根据说明在App.cs中添加以下内容</p>
<pre><code class="language-C#">   DefaultInterpolatedStringHandler defaultInterpolatedStringHandler = new DefaultInterpolatedStringHandler(47, 1);
   defaultInterpolatedStringHandler.AppendLiteral("Copyright © ");
   defaultInterpolatedStringHandler.AppendFormatted(DateTime.Today.Year);
   defaultInterpolatedStringHandler.AppendLiteral(" 上海田之金计算机科技有限公司.\nAll rights reserved.");
   string copyright = defaultInterpolatedStringHandler.ToStringAndClear();

   var splashScreenViewModel = new DXSplashScreenViewModel()
   {
       //Title = "维护工具",
       Status = "加载中...",
       //Logo = new Uri("pack://application:,,,/logo2.png"), //logo在模板中设置了
       //Logo = new Uri("../logo.png", UriKind.Relative),
       Copyright = copyright,
       //Subtitle = Application.ResourceAssembly.GetName().Version.ToString()
   };
   SplashScreenManager.Create(() =&gt; new Views.SplashScreen(), splashScreenViewModel).ShowOnStartup();
</code></pre>
<p><strong>注意</strong></p>
<ul>
<li>Logo 图片的属性要设置为 资源，设置为内容，发布后不显示</li>
<li>发布时，选择单文件发布，可减少文件数量，但是注意Logo图片要设置为 资源。</li>
</ul>
<p><img src="dotnet/wpf/image/devexpress/1722507276944.png" alt="1722507276944" /></p>
<h3 id="gridcontrol"><a class="header" href="#gridcontrol">GridControl</a></h3>
<p><strong>(1) 行模块中绑定按钮</strong></p>
<p>注意当我们点击行中的某个按钮，把当前行绑定的对象作为参数传递给命令函数时：</p>
<ul>
<li>WPF 自带或者使用（PRISM）的写法 <code>CommandParameter="{Binding}"</code>，在 <code>DevExpress</code> 框架中要这样写  <code>CommandParameter="{Binding RowData.Row}"</code></li>
</ul>
<p>前端 <code>Items</code> 为 <code>Person</code> 集合</p>
<pre><code class="language-xml"> &lt;dxg:GridControl Grid.Row="1" Name="grid" ShowBorder="False" ItemsSource="{Binding Items}" AutoGenerateColumns="None"&gt;
     &lt;dxg:GridControl.View&gt;
         &lt;dxg:TableView x:Name="view"
                        ShowHorizontalLines="True"
                        ShowGroupPanel="False"
                        AllowSorting="False"
                        AllowColumnFiltering="False"
                        AllowHorizontalScrollingVirtualization="True"
                     /&gt;
     &lt;/dxg:GridControl.View&gt;
     &lt;dxg:GridControl.Columns&gt;
         &lt;dxg:GridColumn FieldName="Id" Header="Id"/&gt;
         &lt;dxg:GridColumn FieldName="Name" Header="Name"/&gt;
         &lt;dxg:GridColumn FieldName="Age" Header="Age"/&gt;
         &lt;dxg:GridColumn  Header="操作" AllowEditing="False"&gt;
             &lt;dxg:GridColumn.CellTemplate&gt;
                 &lt;DataTemplate&gt;
                     &lt;dx:SimpleButton Content="删除" Width="100" 
                                      Command="{Binding DataContext.DeleteCommand, RelativeSource={RelativeSource AncestorType=dxg:GridControl} }" 
                                      CommandParameter="{Binding RowData.Row}"/&gt;
                 &lt;/DataTemplate&gt;
             &lt;/dxg:GridColumn.CellTemplate&gt;
         &lt;/dxg:GridColumn&gt;
     &lt;/dxg:GridControl.Columns&gt;
 &lt;/dxg:GridControl&gt;
</code></pre>
<p>后端写法一、使用 <code>Command</code> 特性，注意：此时前端以 Command 结尾，但是后端不需要此结尾</p>
<pre><code class="language-csharp">[Command]
 public async Task Delete(Persion data)
 {
    //todo
 }
</code></pre>
<p>后端写法二、使用 <code>DelegateCommand</code> ,和其他框架一致。</p>
<pre><code class="language-csharp">public DelegateCommand&lt;Person&gt; DeleteCommand { get; set; }
public MainViewModel()
{
    DeleteCommand = new DelegateCommand&lt;Person&gt;((r) =&gt; { 

        //todo:

     });
}
</code></pre>
<h3 id="richeditcontrol"><a class="header" href="#richeditcontrol">RichEditControl</a></h3>
<p>富文本控件：可以渲染长文和图片。可以读取 mht/rtf/odt 等格式的文件，但是使用后，如下效果：</p>
<ul>
<li>rtf: 显示正常（注意段落中不要打空格，否则会直接换行）</li>
<li>mht: 中文显示 ？号，英文和图片正常显示（未解决）</li>
<li>odt：直接没有渲染出来</li>
</ul>
<p>使用描述（RTF）：</p>
<ol>
<li>通过 <strong>Word</strong> 编辑好文本后,转化为 <code>tft</code> 格式</li>
<li>后端加载文件</li>
</ol>
<pre><code class="language-c#">using DevExpress.Mvvm;
using DevExpress.Mvvm.POCO;
using Microsoft.Win32;
using System.Collections.ObjectModel;
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Windows.Media;
using System.IO;
using System.Linq;
using TsimTool.Properties;
using System.Windows;

namespace TsimTool.ViewModels
{
    public class ToolDescriptionViewModel : ViewModelBase
    {
        private string _text;

        /// &lt;summary&gt;
        /// 
        /// &lt;/summary&gt;
        public string Text
        {
            get { return _text; }
            set { _text = value; }
        }

        public ToolDescriptionViewModel() {

            Text = File.ReadAllText(Path.Combine(AppDomain.CurrentDomain.BaseDirectory,"Docs/工具说明.rtf"));
        }

    }
}

</code></pre>
<ol start="3">
<li>前端绑定（注意要使用rtf转换器），感觉控件是根据绑定的文本内容格式来自动设定控件的内容格式，但是要手动指定转换器</li>
</ol>
<pre><code class="language-xml">&lt;UserControl xmlns:dxe="http://schemas.devexpress.com/winfx/2008/xaml/editors"  
             xmlns:dxre="http://schemas.devexpress.com/winfx/2008/xaml/richedit"  
             xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:dxmvvm="http://schemas.devexpress.com/winfx/2008/xaml/mvvm" 
             xmlns:ViewModels="clr-namespace:TsimTool.ViewModels" 
             xmlns:dxe1="http://schemas.devexpress.com/winfx/2008/xaml/docking/visualelements"
             xmlns:dxp="http://schemas.devexpress.com/winfx/2008/xaml/printing"  
             x:Class="TsimTool.Views.ToolDescriptionView"
             mc:Ignorable="d"
             d:DesignHeight="300" d:DesignWidth="1000"&gt;
    &lt;UserControl.Resources&gt;
        &lt;dxre:MhtToContentConverter x:Key="MhtToContentConverter"/&gt;
        &lt;dxre:RtfToContentConverter x:Key="RtfToContentConverter"/&gt;
    &lt;/UserControl.Resources&gt;
    &lt;UserControl.DataContext&gt;
        &lt;ViewModels:ToolDescriptionViewModel/&gt;
    &lt;/UserControl.DataContext&gt;
    &lt;dxre:RichEditControl x:Name="richEditControl"  
    ReadOnly="True" ActiveViewType="Simple" ShowBorder="False" 
    HorizontalScrollBarVisibility="Collapsed" HorizontalAlignment="Stretch"
    Content="{Binding Path=Text, Converter={StaticResource RtfToContentConverter}}"/&gt;

&lt;/UserControl&gt;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="托盘应用开发"><a class="header" href="#托盘应用开发">托盘应用开发</a></h1>
<h3 id="设置启动时不显示窗体"><a class="header" href="#设置启动时不显示窗体">设置启动时不显示窗体</a></h3>
<p>通过重写 <code>OnLoad</code> 来实现</p>
<pre><code>protected override void OnLoad(EventArgs e)
     {
         base.OnLoad(e);
         this.Visible = false;
         this.ShowInTaskbar = false;
     }
</code></pre>
<p><strong>异常</strong></p>
<p>在构造函数中添加 <code>this.ShowInTaskbar = false; </code> 写了这句，导致窗体一直显示，出现异常</p>
<h3 id="设置托盘图标"><a class="header" href="#设置托盘图标">设置托盘图标</a></h3>
<p><strong>注意事项</strong></p>
<ul>
<li>NotifyIcon 必须设置图标，否则不会显示</li>
<li>ContextMenuStrip：作为菜单，可设置菜单勾选</li>
</ul>
<pre><code class="language-csharp"> // 创建 NotifyIcon。
         this.notifyIcon1 = new NotifyIcon();
         this.notifyIcon1.Icon = this.Icon;
         this.notifyIcon1.Visible = true;
         this.notifyIcon1.MouseDoubleClick += NotifyIcon1_MouseDoubleClick;
         // 创建 ContextMenuStrip。
         this.notifyIconMenuStrip = new ContextMenuStrip();
         // 创建并初始化 ToolStripMenuItem 对象。
         ToolStripMenuItem showFormItem = new ToolStripMenuItem("显示窗体");
         showFormItem.Click += (object? sender, EventArgs e) =&gt;
         {
             NotifyIcon1_MouseDoubleClick(sender, null);
         };

         ToolStripMenuItem item2 = new ToolStripMenuItem("开机自启动") { CheckOnClick = true, Checked = true };
         item2.CheckedChanged += (object? sender, EventArgs e) =&gt;
         {
             bool isAuto = ((ToolStripMenuItem)sender).Checked;
             SetAutoStart(isAuto);
         };

         ToolStripMenuItem item3 = new ToolStripMenuItem("退出");
         item3.Click += (object? sender, EventArgs e) =&gt;
         {
             Application.Exit();  // 退出应用程序
         };
         // 将 ToolStripMenuItem 对象添加到 ContextMenuStrip 的 Items 集合中。
         this.notifyIconMenuStrip.Items.Add(showFormItem);
         this.notifyIconMenuStrip.Items.Add(item2);
         this.notifyIconMenuStrip.Items.Add(item3);
         // ContextMenu 属性设置当右键点击系统托盘图标时显示的菜单。
         notifyIcon1.ContextMenuStrip = this.notifyIconMenuStrip;
</code></pre>
<p>其他开机启动方式（不推荐）</p>
<ul>
<li>拷贝快捷方式到启动菜单</li>
<li>添加任务几乎</li>
</ul>
<h3 id="设置气泡消息"><a class="header" href="#设置气泡消息">设置气泡消息</a></h3>
<ul>
<li>设置消息标题</li>
<li>设置消息内容</li>
<li>设置消息图标</li>
<li>设置显示时间</li>
<li>没找到在那里更改程序集的名称，如案例中为 <code>TSCT</code> 它就显示TSCT</li>
</ul>
<pre><code class="language-csharp">notifyIcon1.BalloonTipIcon = ToolTipIcon.Info;
notifyIcon1.BalloonTipTitle = "提示";
notifyIcon1.BalloonTipText = "培训系统被控端已启动";
notifyIcon1.ShowBalloonTip(3000);
</code></pre>
<h3 id="设置开机启动"><a class="header" href="#设置开机启动">设置开机启动</a></h3>
<p><strong>重要部分！！！</strong></p>
<p>实现向其他软件一样的可以通过界面操作设置软件是否开机启动，采用的方式为修改注册表，有几个注意事项</p>
<ul>
<li>不要设置软件为管理员权限启动，这样开机启动无效（有些电脑管理员启动也有效。暂时搞不懂）</li>
<li>修改当前用户的注册表(<code>Registry.CurrentUser</code>)，不要修改本机的注册表(<code>Registry.LocalMachine</code>)，否则会要求管理员权限，从而导致启动失败</li>
</ul>
<pre><code class="language-csharp">string R_startPath = Application.ExecutablePath;
         try
         {
             RegistryKey R_currentUser = Registry.CurrentUser; //不要使用本地，本地的无法开机启动
             RegistryKey? R_run = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
             if (autoStart)
             {
                 if (R_run == null)
                     R_run = Registry.CurrentUser.CreateSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
                 R_run.SetValue(Properties.Resources.RegistryKey, R_startPath);
                 R_run.Close();
                 OnMsgEventHandler(MsgType.Info, "软件设置自动启动成功！");
             }
             else
             {
                 if (R_run != null)
                 {
                     R_run.DeleteValue(Properties.Resources.RegistryKey);
                     R_run.Close();
                     OnMsgEventHandler(MsgType.Info, "软件禁止自动启动成功！");
                 }
             }
         }
         catch (Exception e)
         {
             OnMsgEventHandler(MsgType.Info, $"设置软件的开机状态：{autoStart} 出现异常！" + e.Message);
             MessageBox.Show("设置软件的开机状态异常,如那件正常启动，但是下次可能不会自动启动", "提示", MessageBoxButtons.OK, MessageBoxIcon.Error);
         }
</code></pre>
<h3 id="全部代码"><a class="header" href="#全部代码">全部代码</a></h3>
<p>可能会存在其他类的引用，可自行判断</p>
<pre><code class="language-csharp">using System.Windows.Forms;
 public partial class Form1 : Form
 {
     private NotifyIcon notifyIcon1;

     private ContextMenuStrip notifyIconMenuStrip;
     // 右键菜单
     private ContextMenuStrip itemMenuStrip;
     public Form1()
     {
         InitializeComponent();
         InitForm();
         InitTrayIcon();
         /*
          软件每次启动，强制设置为开机启动，启动后可手动禁止开机启动
          */
         SetAutoStart(true);
     }

     private void InitForm()
     {
         OnMsgEventHandler(MsgType.Info, "软件启动");

         this.Text = Properties.Resources.AppTitle + $" V{GetVersion()}";
         this.Visible = false;
         this.StartPosition = FormStartPosition.CenterScreen;
         //this.ShowInTaskbar = false; //此语句导致窗体会显示，必须注释
         Program.OnMsgEvent += OnMsgEventHandler;
         // 初始化右键菜单
         itemMenuStrip = new ContextMenuStrip();
         ToolStripMenuItem copyMenuItem = new ToolStripMenuItem("复制");
         copyMenuItem.Click += CopyMenuItem_Click;
         itemMenuStrip.Items.Add(copyMenuItem);

         // 绑定右键菜单到ListBox
         listBox1.ContextMenuStrip = itemMenuStrip;

         listBox1.DrawMode = DrawMode.OwnerDrawVariable;
         listBox1.MeasureItem += ListBox1_MeasureItem;
         listBox1.DrawItem += listBox1_DrawItem;
         listBox1.HorizontalScrollbar = true; // 设置横向滚动条为可见
     }


     private void OnMsgEventHandler(MsgType type, string message)
     {
         MsgInfo msg = new MsgInfo() { Message = DateTime.Now.ToString("HH:mm:ss: ") + message, Type = type };
         // 判断是否需要在UI线程中执行
         if (this.InvokeRequired)
         {
             // 使用Invoke在UI线程中执行
             this.Invoke(new Action(() =&gt;
             {
                 listBox1.DrawMode = DrawMode.OwnerDrawFixed;
                 this.listBox1.Items.Add(msg);
             }));
         }
         else
         {
             // 如果已在UI线程中，直接更新UI
             this.listBox1.Items.Add(msg);
         }
     }


     private void ListBox1_MeasureItem(object? sender, MeasureItemEventArgs e)
     {
         e.ItemHeight = (int)e.Graphics.MeasureString(listBox1.Items[e.Index].ToString(), listBox1.Font, listBox1.Width).Height;
     }

     private void listBox1_DrawItem(object? sender, DrawItemEventArgs e)
     {
         if (e.Index &lt; 0) return;
         e.DrawBackground();
         MsgInfo info = (MsgInfo)listBox1.Items[e.Index];
         Color color = Color.White;
         switch (info.Type)
         {
             case MsgType.Error:
                 color = Color.Red;
                 break;
             case MsgType.Warning:
                 color = Color.Yellow;
                 break;
             case MsgType.Info:
                 break;
         }

         e.DrawBackground();
         //e.Graphics.DrawString(info.Message, e.Font, new SolidBrush(color), new PointF(e.Bounds.X, e.Bounds.Y));
         e.Graphics.DrawString(info.Message, e.Font, new SolidBrush(color), e.Bounds);

         // 获取文本的实际宽度，并设置为横向滚动条的最大值
         float textWidth = e.Graphics.MeasureString(info.Message, e.Font).Width;
         if (textWidth &gt; listBox1.HorizontalExtent)
         {
             listBox1.HorizontalExtent = (int)textWidth;
         }

         e.DrawFocusRectangle();
     }


     private void button1_Click(object sender, EventArgs e)
     {
         listBox1.Items.Clear();
         listBox1.HorizontalExtent = 0;
     }

     private void button2_Click(object sender, EventArgs e)
     {
         if (listBox1.Items.Count &gt; 10)
         {
             for (int i = listBox1.Items.Count - 10; i &gt; -1; i--)
             {
                 listBox1.Items.RemoveAt(i);
             }
         }
         UpdateHorizontalScrollBar();
     }

     // 更新横向滚动条的宽度
     private void UpdateHorizontalScrollBar()
     {
         int maxWidth = 0;

         // 计算当前列表中最长文本的宽度
         foreach (MsgInfo item in listBox1.Items)
         {
             int itemWidth = (int)listBox1.CreateGraphics().MeasureString(item.Message, listBox1.Font).Width;
             if (itemWidth &gt; maxWidth)
             {
                 maxWidth = itemWidth;
             }
         }

         // 将最长文本的宽度设置为横向滚动条的最大值
         if (maxWidth &gt; listBox1.HorizontalExtent)
         {
             listBox1.HorizontalExtent = maxWidth;
         }
     }

     private void CopyMenuItem_Click(object? sender, EventArgs e)
     {
         // 获取选定项的文本
         string selectedText = "";

         foreach (var item in listBox1.SelectedItems)
         {
             selectedText += ((MsgInfo)item).Message.ToString() + Environment.NewLine;
         }

         // 将文本放入剪贴板
         Clipboard.SetText(selectedText);
     }

     private void InitTrayIcon()
     {
         // 创建 NotifyIcon。
         this.notifyIcon1 = new NotifyIcon();
         this.notifyIcon1.Icon = this.Icon;
         this.notifyIcon1.Visible = true;
         this.notifyIcon1.MouseDoubleClick += NotifyIcon1_MouseDoubleClick;
         // 创建 ContextMenuStrip。
         this.notifyIconMenuStrip = new ContextMenuStrip();
         // 创建并初始化 ToolStripMenuItem 对象。
         ToolStripMenuItem showFormItem = new ToolStripMenuItem("显示窗体");
         showFormItem.Click += (object? sender, EventArgs e) =&gt;
         {
             NotifyIcon1_MouseDoubleClick(sender, null);
         };

         ToolStripMenuItem item2 = new ToolStripMenuItem("开机自启动") { CheckOnClick = true, Checked = true };
         item2.CheckedChanged += (object? sender, EventArgs e) =&gt;
         {
             bool isAuto = ((ToolStripMenuItem)sender).Checked;
             SetAutoStart(isAuto);
         };

         ToolStripMenuItem item3 = new ToolStripMenuItem("退出");
         item3.Click += (object? sender, EventArgs e) =&gt;
         {
             Application.Exit();  // 退出应用程序
         };
         // 将 ToolStripMenuItem 对象添加到 ContextMenuStrip 的 Items 集合中。
         this.notifyIconMenuStrip.Items.Add(showFormItem);
         this.notifyIconMenuStrip.Items.Add(item2);
         this.notifyIconMenuStrip.Items.Add(item3);
         // ContextMenu 属性设置当右键点击系统托盘图标时显示的菜单。
         notifyIcon1.ContextMenuStrip = this.notifyIconMenuStrip;
         ShowStartInfo();
     }

     private void NotifyIcon1_MouseDoubleClick(object? sender, MouseEventArgs e)
     {
         this.ShowInTaskbar = true;
         this.Show();  // 显示窗体
         this.WindowState = FormWindowState.Normal;  // 恢复窗体正常大小
     }
     private void UpdateNoticyIconText(bool isAutoStart)
     {
         string yes = isAutoStart ? "是" : "否";
         this.notifyIcon1.Text = $"{Properties.Resources.AppTitle}\n端口：{Program.port}\n开机启动：{yes}";
     }

     private void ShowStartInfo()
     {
         notifyIcon1.BalloonTipIcon = ToolTipIcon.Info;
         notifyIcon1.BalloonTipTitle = "提示";
         notifyIcon1.BalloonTipText = "培训系统被控端已启动";
         notifyIcon1.ShowBalloonTip(3000);
     }

     protected override void OnLoad(EventArgs e)
     {
         base.OnLoad(e);
         this.Visible = false;
         this.ShowInTaskbar = false;
     }

     protected override void OnFormClosing(FormClosingEventArgs e)
     {
         if (e.CloseReason == CloseReason.UserClosing)
         {
             e.Cancel = true;  // 取消关闭窗体
             this.Hide();  // 隐藏窗体
         }
     }


     //开机启动
     private void SetAutoStart(bool autoStart)
     {
         string R_startPath = Application.ExecutablePath;
         try
         {
             RegistryKey R_currentUser = Registry.CurrentUser; //不要使用本地，本地的无法开机启动
             RegistryKey? R_run = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
             if (autoStart)
             {
                 if (R_run == null)
                     R_run = Registry.CurrentUser.CreateSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
                 R_run.SetValue(Properties.Resources.RegistryKey, R_startPath);
                 R_run.Close();
                 OnMsgEventHandler(MsgType.Info, "软件设置自动启动成功！");
             }
             else
             {
                 if (R_run != null)
                 {
                     R_run.DeleteValue(Properties.Resources.RegistryKey);
                     R_run.Close();
                     OnMsgEventHandler(MsgType.Info, "软件禁止自动启动成功！");
                 }
             }
         }
         catch (Exception e)
         {
             OnMsgEventHandler(MsgType.Info, $"设置软件的开机状态：{autoStart} 出现异常！" + e.Message);
             MessageBox.Show("设置软件的开机状态异常,如那件正常启动，但是下次可能不会自动启动", "提示", MessageBoxButtons.OK, MessageBoxIcon.Error);
         }
         UpdateNoticyIconText(autoStart);
     }

     private string GetVersion()
     {
         return Assembly.GetExecutingAssembly().GetName().Version.ToString();
     }
 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aspnet"><a class="header" href="#aspnet">Asp.Net</a></h1>
<h2 id="控制器"><a class="header" href="#控制器">控制器</a></h2>
<h3 id="访问路径问题"><a class="header" href="#访问路径问题">访问路径问题</a></h3>
<p>假设在本机访问，端口为 <code>80</code>， 代码示例，配置了两个接口 <code>Get1</code> 和 <code>Get2</code></p>
<pre><code class="language-c#">    [ApiController]
    [Route("[controller]")]
    public class TestController : ControllerBase
    {

        //使用 http://localhost/Test/Get1 访问
        [HttpGet("Get1")] 
        public async Task&lt;int&gt; Get1()
        {
            //...
        }
        //使用 http://localhost/Get2 访问
        [HttpGet("/Get2")]
        public async Task&lt;int&gt; Get2()
        {
            //...
        }
    }
</code></pre>
<ul>
<li>当 HttpGet 中的路由地址以 <code>/</code> 开头，那么地址不会加上控制器的名称，如：http://localhost/Get2</li>
<li>当 HttpGet 中的路由地址不以 <code>/</code> 开头，那么地址会自动加上控制器的名称，如：http://localhost/Test/Get1</li>
</ul>
<h2 id="全局异常捕获"><a class="header" href="#全局异常捕获">全局异常捕获</a></h2>
<p>默认的异常提示</p>
<pre><code>2024-09-18 17:47:51.7860 error：An unhandled exception has occurred while executing the request.
</code></pre>
<p>希望的异常提示，最好是有栈跟踪，或者具有明确的错误信息。</p>
<h3 id="通过控制器的过滤器捕获"><a class="header" href="#通过控制器的过滤器捕获">通过控制器的过滤器捕获</a></h3>
<blockquote>
<p>具有栈跟踪</p>
</blockquote>
<p>定义过滤器</p>
<pre><code class="language-c#"> public class CustomExceptionFilter : IExceptionFilter
 {
     private readonly ILogger&lt;CustomExceptionFilter&gt; _logger;

     // 注入日志服务
     public CustomExceptionFilter(ILogger&lt;CustomExceptionFilter&gt; logger)
     {
         _logger = logger;
     }
     public void OnException(ExceptionContext context)
     {
         var exception = context.Exception;

         _logger.LogError("控制器异常："+exception.ToString());
         // 记录异常
         context.Result = new RedirectToActionResult("Error", "Home", null);
         context.ExceptionHandled = false; // 标记异常未处理，让全局获取
     }
 }
</code></pre>
<p>注册</p>
<pre><code class="language-c#">    // 注册全局异常过滤器
    builder.Services.AddControllersWithViews(options =&gt;
    {
        options.Filters.Add&lt;CustomExceptionFilter&gt;(); // 全局添加过滤器
    });


</code></pre>
<h3 id="捕获控制器的过滤器无法处理的"><a class="header" href="#捕获控制器的过滤器无法处理的">捕获控制器的过滤器无法处理的</a></h3>
<blockquote>
<p>无栈跟踪，提供错误信息</p>
</blockquote>
<pre><code class="language-c#">    builder.Services.AddProblemDetails(options =&gt;
            options.CustomizeProblemDetails = (context) =&gt;
            {
                logger.Error($"全局异常捕获：Title: {context.ProblemDetails.Title}，Detail: {context.ProblemDetails.Detail}");

            }
        );
</code></pre>
<h2 id="部署-iis"><a class="header" href="#部署-iis">部署 IIS</a></h2>
<blockquote>
<p>说明：使用IIS部署，通常是 <code>http</code> 协议，后面要通过 <strong>Nginx</strong> 来代理访问，因为 <strong>Nginx</strong> 配置证书等比较方便</p>
</blockquote>
<p><a href="https://learn.microsoft.com/zh-cn/aspnet/core/tutorials/publish-to-iis?view=aspnetcore-8.0&amp;tabs=visual-studio">官网手册</a></p>
<p>以 Windows Server 为例：</p>
<h3 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h3>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/dotnet/core/sdk">NET Core SDK</a> 安装在开发计算机上。如果发布的程序勾选了独立运行，可以不安装SDK。</li>
<li>安装IIS，自行网上查找资料。</li>
<li>在 IIS 服务器上安装 <a href="https://dotnet.microsoft.com/permalink/dotnetcore-current-windows-runtime-bundle-installer">.NET Core 托管捆绑包</a>。 捆绑包可安装 .NET Core 运行时、.NET Core 库和 ASP.NET Core 模块。 该模块允许 ASP.NET Core 应用在 IIS 后面运行。</li>
<li>上面安装的托管捆绑包应该包含了 AspNetCoreModuleV2</li>
</ul>
<h3 id="发布aspnet程序"><a class="header" href="#发布aspnet程序">发布Asp.NET程序</a></h3>
<p>发布到文件夹。</p>
<p>不要发布单文件格式，好像无法运行。</p>
<h3 id="创建站点"><a class="header" href="#创建站点">创建站点</a></h3>
<p><strong>创建应用程序池</strong>：在IIS管理器中创建一个新的应用程序池，注意：</p>
<ul>
<li>当部署Blazor项目时：设置.NET CLR版本为“No Managed Code”，正常运行</li>
<li>当部署 <strong>Web API</strong> 项目，并且从 Blazor 项目中跨域访问时(注：API项目中已经配置了跨域策略)，这里要选择一个版本，否则会因 <strong>跨域问题</strong> 无法访问。</li>
</ul>
<p><img src="dotnet/aspnet/image/aspnet/1723516732615.png" alt="1723516732615" /></p>
<p><strong>创建网站</strong>：设置网站名称（仅显示作用），选择自己创建的应用程序池，选择程序目录，设置端口，IP地址和主机名不用填，默认就行</p>
<p><img src="dotnet/aspnet/image/aspnet/1723516895463.png" alt="1723516895463" /></p>
<h2 id="使用-nginx部署"><a class="header" href="#使用-nginx部署">使用 Nginx部署</a></h2>
<h2 id="问题汇总"><a class="header" href="#问题汇总">问题汇总</a></h2>
<h3 id="部署后有的浏览器不能访问"><a class="header" href="#部署后有的浏览器不能访问">部署后有的浏览器不能访问</a></h3>
<p><strong>环境</strong>：</p>
<ul>
<li>阿里云域名</li>
<li>阿里云免费云解析</li>
<li>阿里云服务器（带固定公网IP）</li>
<li>未备案</li>
</ul>
<p>阿里云售后给出的答复是，网站未备案，详细回复如下：</p>
<p>您好，www.xxx.com看解析到阿里云大陆主机，未在阿里云备案导致备案拦截无法访问</p>
<p>网站托管在中国内地（大陆）的服务器上，您需根据所在省市的管局规则进行备案申请。当您使用阿里云中国内地（大陆）节点服务器时，您可以在PC端或移动端的阿里云ICP代备案系统中提交ICP备案申请，审核通过便可开通网站访问服务。
https://help.aliyun.com/document_detail/61819.html</p>
<p><strong>备案后</strong>：</p>
<p>网站正常访问。</p>
<h3 id="重启iis服务可能存在访问异常"><a class="header" href="#重启iis服务可能存在访问异常">重启IIS服务可能存在访问异常</a></h3>
<blockquote>
<p>错误信息： Microsoft.AspNetCore.Antiforgery.DefaultAntiforgery|An exception was thrown while deserializing the token. Microsoft.AspNetCore.Antiforgery.AntiforgeryValidationException: The antiforgery token could not be decrypted.</p>
</blockquote>
<p>当IIS重启过程中，客户端通过刷新浏览器发起请求，由于两次请求的服务不一样，导致出现此错误信息，应该不影响。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signalr"><a class="header" href="#signalr">SignalR</a></h1>
<p><a href="https://gitee.com/AByte-L/csharp-dev-demo/tree/master/AspNetCore/SignalRSample/doc">Signal Sample</a># SignalR</p>
<h2 id="hub"><a class="header" href="#hub">Hub</a></h2>
<h3 id="配置hub"><a class="header" href="#配置hub">配置Hub</a></h3>
<p>若要注册 SignalR 中心所需的服务，请调用 Program.cs 中的 AddSignalR：</p>
<pre><code class="language-C#">var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();
builder.Services.AddSignalR();
</code></pre>
<p>若要配置 SignalR 终结点，请调用同时在 Program.cs 中的 MapHub：</p>
<pre><code class="language-C#">app.MapRazorPages();
app.MapHub&lt;ChatHub&gt;("/Chat");

app.Run();
</code></pre>
<blockquote>
<p>⚠️ <strong>备注</strong></p>
<p>ASP.NET Core SignalR 服务器端程序集现在随 .NET Core SDK 一起安装。 有关详细信息，请参阅共享框架中的 SignalR 程序集。</p>
</blockquote>
<h3 id="创建和使用hub"><a class="header" href="#创建和使用hub">创建和使用Hub</a></h3>
<p>通过声明从 Hub 继承的类来创建中心。 将 public 方法添加到类，使其可从客户端调用：</p>
<pre><code class="language-C#">public class ChatHub : Hub
{
    public async Task SendMessage(string user, string message)
        =&gt; await Clients.All.SendAsync("ReceiveMessage", user, message);
}
</code></pre>
<blockquote>
<p>⚠️ <strong>备注</strong></p>
<p><strong>中心是暂时性的：</strong></p>
<ul>
<li>请勿将状态存储在中心类的属性中。 每个中心方法调用都在新的中心实例上执行。</li>
<li>请勿通过依赖关系注入直接实例化中心。 若要从应用程序中的其他位置向客户端发送消息，请使用 IHubContext。</li>
<li>调用依赖于保持活动状态的中心的异步方法时请使用 await。 例如，如果在没有 await 的情况下进行调用，则 Clients.All.SendAsync(...) 这类方法会失败，并且中心方法会在 SendAsync 完成之前完成。</li>
</ul>
</blockquote>
<h3 id="上下文对象"><a class="header" href="#上下文对象">上下文对象</a></h3>
<p>Hub 类具有一个 Context 属性，该属性包含具有连接相关信息的以下属性：</p>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>说明</th><th>解释</th></tr></thead><tbody>
<tr><td>ConnectionId</td><td>获取连接的唯一 ID（由 SignalR 分配）。 每个连接有一个连接 ID。</td><td>每次调用方法时，Hub都是新示例</td></tr>
<tr><td>UserIdentifier</td><td>获取用户标识符。 默认情况下，SignalR 使用与连接关联的 ClaimsPrincipal 中的 ClaimTypes.NameIdentifier 作为用户标识符。</td><td></td></tr>
<tr><td>User</td><td>获取与当前用户关联的 ClaimsPrincipal。</td><td></td></tr>
<tr><td>Items</td><td>获取可用于在此连接范围内共享数据的键/值集合。 数据可以存储在此集合中，会在不同的中心方法调用间为连接持久保存。</td><td></td></tr>
<tr><td>Features</td><td>获取连接上可用的功能的集合。 目前，在大多数情况下不需要此集合，因此未对其进行详细记录。</td><td></td></tr>
<tr><td>ConnectionAborted</td><td>获取一个 CancellationToken，它会在连接中止时发出通知。</td><td></td></tr>
</tbody></table>
</div>
<p>Hub.Context 还包含以下方法：</p>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>说明</th><th>解释</th></tr></thead><tbody>
<tr><td>GetHttpContext</td><td>返回连接的 HttpContext，如果连接不与 HTTP 请求关联，则返回 null。 对于 HTTP 连接，可以使用此方法获取 HTTP 标头和查询字符串等信息。</td><td>每次调用方法时，Hub都是新示例</td></tr>
<tr><td>Abort</td><td>中止连接。</td><td></td></tr>
</tbody></table>
</div>
<h3 id="客户端对象"><a class="header" href="#客户端对象">客户端对象</a></h3>
<p>Hub 类具有一个 Clients 属性，该属性包含适用于服务器与客户端之间的通信的以下属性：</p>
<div class="table-wrapper"><table><thead><tr><th>属性</th><th>说明</th><th>解释</th></tr></thead><tbody>
<tr><td>All</td><td>对所有连接的客户端调用方法</td><td></td></tr>
<tr><td>Caller</td><td>对调用了中心方法的客户端调用方法</td><td>哪个客户端发过来的，就发送给哪个</td></tr>
<tr><td>Others</td><td>对所有连接的客户端调用方法（调用了方法的客户端除外）</td><td>除了调用者，都发送</td></tr>
</tbody></table>
</div>
<p>Hub.Clients |还包含以下方法：</p>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th>说明</th><th>解释</th></tr></thead><tbody>
<tr><td>AllExcept</td><td>对所有连接的客户端调用方法（指定连接除外）</td><td></td></tr>
<tr><td>Client</td><td>对连接的一个特定客户端调用方法</td><td></td></tr>
<tr><td>Clients</td><td>对连接的多个特定客户端调用方法</td><td></td></tr>
<tr><td>Group</td><td>对指定组中的所有连接调用方法</td><td>需要一个组id</td></tr>
<tr><td>GroupExcept</td><td>对指定组中的所有连接调用方法（指定连接除外）</td><td></td></tr>
<tr><td>Groups</td><td>对多个连接组调用方法</td><td></td></tr>
<tr><td>OthersInGroup</td><td>对一个连接组调用方法（不包括调用了中心方法的客户端）</td><td></td></tr>
<tr><td>User</td><td>对与一个特定用户关联的所有连接调用方法</td><td></td></tr>
<tr><td>Users</td><td>对与多个指定用户关联的所有连接调用方法</td><td></td></tr>
</tbody></table>
</div>
<p>以上表中的每个属性或方法都返回具有 SendAsync 方法的对象。 SendAsync 方法接收要调用的客户端方法的名称和任何参数。</p>
<p>Client 和 Caller 方法返回的对象还包含一个 InvokeAsync 方法，该方法可用于等待来自客户端的结果。</p>
<h3 id="向客户端发送消息"><a class="header" href="#向客户端发送消息">向客户端发送消息</a></h3>
<p>若要对特定客户端发出调用，请使用 Clients 对象的属性。 在下面的示例中，有三个中心方法：</p>
<ul>
<li>SendMessage 使用 Clients.All 将消息发送到所有连接的客户端。</li>
<li>SendMessageToCaller 使用 Clients.Caller 将消息发送回调用方。</li>
<li>SendMessageToGroup 将消息发送给 SignalR Users 组中的所有客户端。</li>
</ul>
<pre><code class="language-C#">public async Task SendMessage(string user, string message)
    =&gt; await Clients.All.SendAsync("ReceiveMessage", user, message);

public async Task SendMessageToCaller(string user, string message)
    =&gt; await Clients.Caller.SendAsync("ReceiveMessage", user, message);

public async Task SendMessageToGroup(string user, string message)
    =&gt; await Clients.Group("SignalR Users").SendAsync("ReceiveMessage", user, message);
</code></pre>
<h3 id="强类型hub"><a class="header" href="#强类型hub">强类型Hub</a></h3>
<p>使用 SendAsync 的缺点在于，它依赖于字符串来指定要调用的客户端方法。 如果客户端中的方法名称拼写错误或缺失，则这会使代码可能出现运行时错误。</p>
<p>使用 SendAsync 的替代方法是使用 Hub<T> 将 Hub 类设为强类型。 在下面的示例中，ChatHub 客户端方法提取到名为 IChatClient 的接口中：</p>
<pre><code class="language-C#">public interface IChatClient
{
    Task ReceiveMessage(string user, string message);
}
</code></pre>
<p>此接口可用于将上面的 ChatHub 示例重构为强类型：</p>
<pre><code class="language-C#">public class StronglyTypedChatHub : Hub&lt;IChatClient&gt;
{
    public async Task SendMessage(string user, string message)
        =&gt; await Clients.All.ReceiveMessage(user, message);

    public async Task SendMessageToCaller(string user, string message)
        =&gt; await Clients.Caller.ReceiveMessage(user, message);

    public async Task SendMessageToGroup(string user, string message)
        =&gt; await Clients.Group("SignalR Users").ReceiveMessage(user, message);
}
</code></pre>
<p>使用 Hub<IChatClient> 可以对客户端方法进行编译时检查。 这可防止由于使用字符串而导致的问题，因为 Hub<T> 只能提供对接口中定义的方法的访问。 使用强类型 Hub<T> 会禁止使用 SendAsync。</p>
<blockquote>
<p>⚠️  <strong>备注</strong></p>
<p>Async 后缀不会从方法名称中去除。 除非使用 .on('MyMethodAsync') 定义客户端方法，否则不要使用 MyMethodAsync 作为名称。</p>
</blockquote>
<h3 id="客户端结果"><a class="header" href="#客户端结果">客户端结果</a></h3>
<p>除了对客户端进行调用外，服务器还可以从客户端请求结果。 这要求服务器使用 ISingleClientProxy.InvokeAsync，并且客户端从其 .On 处理程序返回结果。</p>
<p>有两种方法可以在服务器上使用 API，第一种方法是在中心方法中对 Clients 属性调用 Client(...) 或 Caller：</p>
<pre><code class="language-C#">public class ChatHub : Hub
{
    public async Task&lt;string&gt; WaitForMessage(string connectionId)
    {
        var message = await Clients.Client(connectionId).InvokeAsync&lt;string&gt;(
            "GetMessage");
        return message;
    }
}
</code></pre>
<p>第二种方法是对 IHubContext<T> 的实例调用 Client(...)：</p>
<pre><code class="language-C#">async Task SomeMethod(IHubContext&lt;MyHub&gt; context)
{
    string result = await context.Clients.Client(connectionID).InvokeAsync&lt;string&gt;(
        "GetMessage");
}
</code></pre>
<p>强类型中心还可以从接口方法返回值：</p>
<pre><code class="language-C#">public interface IClient
{
    Task&lt;string&gt; GetMessage();
}

public class ChatHub : Hub&lt;IClient&gt;
{
    public async Task&lt;string&gt; WaitForMessage(string connectionId)
    {
        string message = await Clients.Client(connectionId).GetMessage();
        return message;
    }
}
</code></pre>
<p>客户端在其 .On(...) 处理程序中返回结果，如下所示：</p>
<h4 id="net-客户端"><a class="header" href="#net-客户端">.NET 客户端</a></h4>
<pre><code class="language-C#">hubConnection.On("GetMessage", async () =&gt;
{
    Console.WriteLine("Enter message:");
    var message = await Console.In.ReadLineAsync();
    return message;
});
</code></pre>
<h4 id="typescript-客户端"><a class="header" href="#typescript-客户端">Typescript 客户端</a></h4>
<pre><code class="language-TypeScript">hubConnection.on("GetMessage", async () =&gt; {
    let promise = new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve("message");
        }, 100);
    });
    return promise;
});

</code></pre>
<h4 id="java-客户端"><a class="header" href="#java-客户端">Java 客户端</a></h4>
<pre><code class="language-Java">hubConnection.onWithResult("GetMessage", () -&gt; {
    return Single.just("message");
});
</code></pre>
<p>更改中心方法的名称
默认情况下，服务器中心方法名称是 .NET 方法的名称。 若要更改特定方法的此默认行为，请使用 HubMethodName 属性。 调用方法时，客户端应使用此名称，而不是 .NET 方法名称：</p>
<pre><code class="language-C#">[HubMethodName("SendMessageToUser")]
public async Task DirectMessage(string user, string message)
    =&gt; await Clients.User(user).SendAsync("ReceiveMessage", user, message);
</code></pre>
<h3 id="将服务注入hub"><a class="header" href="#将服务注入hub">将服务注入Hub</a></h3>
<p>中心构造函数可以接受 DI 中的服务作为参数，这些参数可以存储在类的属性中，以便在中心方法中使用。</p>
<p>为不同的中心方法注入多个服务或作为编写代码的替代方法时，中心方法也可以接受来自 DI 的服务。 默认情况下，如果可能，将从 DI 检查和解析中心方法参数。</p>
<pre><code class="language-C#">services.AddSingleton&lt;IDatabaseService, DatabaseServiceImpl&gt;();

// ...

public class ChatHub : Hub
{
    public Task SendMessage(string user, string message, IDatabaseService dbService)
    {
        var userName = dbService.GetUserName(user);
        return Clients.All.SendAsync("ReceiveMessage", userName, message);
    }
}
</code></pre>
<p>如果不需要隐式解析来自服务的参数，请使用 DisableImplicitFromServicesParameters 禁用它。 若要在中心方法中显式指定从 DI 解析的参数，请使用 DisableImplicitFromServicesParameters 选项，并使用 [FromServices] 属性或自定义属性，该属性在应从 DI 解析的中心方法参数上实现 IFromServiceMetadata。</p>
<pre><code class="language-C#">services.AddSingleton&lt;IDatabaseService, DatabaseServiceImpl&gt;();
services.AddSignalR(options =&gt;
{
    options.DisableImplicitFromServicesParameters = true;
});

// ...

public class ChatHub : Hub
{
    public Task SendMessage(string user, string message,
        [FromServices] IDatabaseService dbService)
    {
        var userName = dbService.GetUserName(user);
        return Clients.All.SendAsync("ReceiveMessage", userName, message);
    }
}
</code></pre>
<blockquote>
<p>⚠️ <strong>备注</strong></p>
<p>此功能使用 IServiceProviderIsService，通过 DI 实现来实现（可选）。 如果应用的 DI 容器不支持此功能，则不支持将服务注入中心方法。</p>
</blockquote>
<h3 id="依赖项注入中的键控服务支持"><a class="header" href="#依赖项注入中的键控服务支持">依赖项注入中的键控服务支持</a></h3>
<p>密钥服务是指使用密钥注册和检索依赖项注入 (DI) 服务的机制。 通过调用 AddKeyedSingleton （或 AddKeyedScoped 或 AddKeyedTransient）来注册服务，与密钥相关联。 使用 [FromKeyedServices] 属性指定密钥来访问已注册的服务。 以下代码演示如何使用键化服务：</p>
<pre><code class="language-C#">using Microsoft.AspNetCore.SignalR;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddKeyedSingleton&lt;ICache, BigCache&gt;("big");
builder.Services.AddKeyedSingleton&lt;ICache, SmallCache&gt;("small");

builder.Services.AddRazorPages();
builder.Services.AddSignalR();

var app = builder.Build();

app.MapRazorPages();
app.MapHub&lt;MyHub&gt;("/myHub");

app.Run();

public interface ICache
{
    object Get(string key);
}
public class BigCache : ICache
{
    public object Get(string key) =&gt; $"Resolving {key} from big cache.";
}

public class SmallCache : ICache
{
    public object Get(string key) =&gt; $"Resolving {key} from small cache.";
}

public class MyHub : Hub
{
    public void SmallCacheMethod([FromKeyedServices("small")] ICache cache)
    {
        Console.WriteLine(cache.Get("signalr"));
    }

    public void BigCacheMethod([FromKeyedServices("big")] ICache cache)
    {
        Console.WriteLine(cache.Get("signalr"));
    }
}
</code></pre>
<p>为连接处理事件
SignalR 中心 API 提供 OnConnectedAsync 和 OnDisconnectedAsync 虚拟方法来管理和跟踪连接。 替代 OnConnectedAsync 虚拟方法可在客户端连接到中心时执行操作（例如将它添加到组）：</p>
<pre><code class="language-C#">public override async Task OnConnectedAsync()
{
    await Groups.AddToGroupAsync(Context.ConnectionId, "SignalR Users");
    await base.OnConnectedAsync();
}
</code></pre>
<p>替代 OnDisconnectedAsync 虚拟方法可在客户端断开连接时执行操作。 如果客户端有意断开连接（例如通过调用 connection.stop()），则 exception 参数将设置为 null。 但是，如果客户端由于错误（例如网络故障）而断开连接，则 exception 参数将包含描述故障的异常：</p>
<pre><code class="language-C#">public override async Task OnDisconnectedAsync(Exception? exception)
{
    await base.OnDisconnectedAsync(exception);
}
</code></pre>
<p>无需在 OnDisconnectedAsync 中调用 RemoveFromGroupAsync，系统会自动为你进行处理。</p>
<p>处理错误
在中心方法中引发的异常会发送到调用方法的客户端。 在 JavaScript 客户端上，invoke 方法会返回 JavaScript Promise。 客户端可以将 catch 处理程序附加到返回的承诺，或使用和 try/catch 和 async/await 来处理异常：</p>
<pre><code class="language-JavaScript">try {
  await connection.invoke("SendMessage", user, message);
} catch (err) {
  console.error(err);
}
</code></pre>
<p>当中心引发异常时，连接不会关闭。 默认情况下，SignalR 将向客户端返回一般错误消息，如以下示例所示：</p>
<p>输出</p>
<pre><code>Microsoft.AspNetCore.SignalR.HubException: An unexpected error occurred invoking 'SendMessage' on the server.
</code></pre>
<p>意外异常通常包含敏感信息，例如在数据库连接失败时触发的异常中会包含数据库服务器的名称。 作为安全措施，SignalR 在默认情况下不会公开这些详细错误消息。 有关为何禁止显示异常详细信息的详细信息，请参阅 ASP.NET Core SignalR 中的安全注意事项一文。</p>
<p>如果必须将异常情况传播到客户端，请使用 HubException 类。 如果在中心方法中引发 HubException，则 SignalR 会将整个消息发送到客户端（未修改）：</p>
<pre><code class="language-C#">public Task ThrowException()
    =&gt; throw new HubException("This error will be sent to the client!");
</code></pre>
<blockquote>
<p>⚠️ <strong>备注</strong></p>
<p>SignalR 仅将异常的 Message 属性发送到客户端。 异常中的堆栈跟踪和其他属性不可供客户端使用。</p>
</blockquote>
<h2 id="从中心外部发送"><a class="header" href="#从中心外部发送">从中心外部发送</a></h2>
<p>由于Hub每次调用都是新的示例，也就意味着Hub中的方法触发是被动的，只有客户端主动调用，服务端无法主动调用。那要实现服务端向客户端主动发送数据。</p>
<p>SignalR 中心是用于向连接到 SignalR 服务器的客户端发送消息的核心抽象。 你也可以使用 IHubContext 服务从应用中的其他位置发送消息。 本文介绍如何访问 SignalRIHubContext 以从中心外部向客户端发送通知。</p>
<blockquote>
<p>⚠️ <strong>备注</strong></p>
<p>IHubContext 用于将通知发送到客户端，而非用于调用 Hub 上的方法。</p>
</blockquote>
<h3 id="获取-ihubcontext-实例"><a class="header" href="#获取-ihubcontext-实例">获取 IHubContext 实例</a></h3>
<p>在 ASP.NET Core SignalR 中，你可以通过依赖项注入来访问 IHubContext 实例。 你可以将 IHubContext 实例注入控制器、中间件或其他 DI 服务。 使用该实例向客户端发送消息。</p>
<h3 id="在控制器中注入-ihubcontext-实例"><a class="header" href="#在控制器中注入-ihubcontext-实例">在控制器中注入 IHubContext 实例</a></h3>
<p>通过将 IHubContext 实例添加到构造函数，可以将其注入控制器：</p>
<pre><code class="language-C#">public class HomeController : Controller
{
    private readonly IHubContext&lt;NotificationHub&gt; _hubContext;

    public HomeController(IHubContext&lt;NotificationHub&gt; hubContext)
    {
        _hubContext = hubContext;
    }
}
</code></pre>
<p>获权访问 IHubContext 实例后，就像在中心本身一样调用客户端方法：</p>
<pre><code class="language-C#">public async Task&lt;IActionResult&gt; Index()
{
    await _hubContext.Clients.All.SendAsync("Notify", $"Home page loaded at: {DateTime.Now}");
    return View();
}
</code></pre>
<h3 id="在中间件中获取-ihubcontext-实例"><a class="header" href="#在中间件中获取-ihubcontext-实例">在中间件中获取 IHubContext 实例</a></h3>
<p>访问中间件管道中的 IHubContext，如下所示：</p>
<pre><code class="language-C#">app.Use(async (context, next) =&gt;
{
    var hubContext = context.RequestServices
                            .GetRequiredService&lt;IHubContext&lt;ChatHub&gt;&gt;();
    //...
    
    if (next != null)
    {
        await next.Invoke();
    }
});
</code></pre>
<blockquote>
<p>⚠️ <strong>备注</strong></p>
<p>当从 Hub 类外部调用客户端方法时，没有与该调用关联的调用方。 因此，无法访问 ConnectionId、Caller 和 &gt;Others 属性。</p>
<p>需要将用户映射到连接 ID 并保留该映射的应用可以执行以下操作之一：</p>
<p>将单个或多个连接的映射保留为组。 有关详细信息，请参阅SignalR 中的组。
通过单一实例服务保留连接和用户信息。 有关详细信息，请参阅将服务注入中心。 单一实例服务可以使用任何存储方法，&gt;例如：
字典中的内存中存储。
永久性外部存储。 例如，使用 Azure.Data.Tables NuGet 包的数据库或 Azure 表存储。
在客户端之间传递连接 ID。</p>
</blockquote>
<h3 id="从-ihost-获取-ihubcontext-实例"><a class="header" href="#从-ihost-获取-ihubcontext-实例">从 IHost 获取 IHubContext 实例</a></h3>
<p>从 Web 主机访问 IHubContext 对于与 ASP.NET Core 之外的区域集成很有用，例如，使用第三方依赖项注入框架：</p>
<pre><code class="language-C#">    public class Program
    {
        public static void Main(string[] args)
        {
            var host = CreateHostBuilder(args).Build();
            var hubContext = host.Services.GetService(typeof(IHubContext&lt;ChatHub&gt;));
            host.Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&gt; {
                    webBuilder.UseStartup&lt;Startup&gt;();
                });
    }
</code></pre>
<h3 id="注入强类型-hubcontext"><a class="header" href="#注入强类型-hubcontext">注入强类型 HubContext</a></h3>
<p>若要注入强类型 HubContext，请确保中心继承自 Hub<T>。 使用 IHubContext&lt;THub, T&gt; 接口而不是 IHubContext<THub> 进行注入。</p>
<pre><code class="language-C#">public class ChatController : Controller
{
    public IHubContext&lt;ChatHub, IChatClient&gt; _strongChatHubContext { get; }

    public ChatController(IHubContext&lt;ChatHub, IChatClient&gt; chatHubContext)
    {
        _strongChatHubContext = chatHubContext;
    }

    public async Task SendMessage(string user, string message)
    {
        await _strongChatHubContext.Clients.All.ReceiveMessage(user, message);
    }
}
</code></pre>
<p>有关详细信息，请参阅强类型中心。</p>
<h3 id="在泛型代码中使用-ihubcontext"><a class="header" href="#在泛型代码中使用-ihubcontext">在泛型代码中使用 IHubContext</a></h3>
<p>注入的 IHubContext<THub> 实例可以强制转换为 IHubContext，而无需指定泛型 Hub 类型。</p>
<pre><code class="language-C#">class MyHub : Hub
{ }

class MyOtherHub : Hub
{ }

app.Use(async (context, next) =&gt;
{
    var myHubContext = context.RequestServices
                            .GetRequiredService&lt;IHubContext&lt;MyHub&gt;&gt;();
    var myOtherHubContext = context.RequestServices
                            .GetRequiredService&lt;IHubContext&lt;MyOtherHub&gt;&gt;();
    await CommonHubContextMethod((IHubContext)myHubContext);
    await CommonHubContextMethod((IHubContext)myOtherHubContext);

    await next.Invoke();
}

async Task CommonHubContextMethod(IHubContext context)
{
    await context.Clients.All.SendAsync("clientMethod", new Args());
}
</code></pre>
<p>此操作在以下情况下十分有用：</p>
<ul>
<li>编写不引用应用正在使用的特定 Hub 类型的库。</li>
<li>编写可应用于多个不同 Hub 实现的泛型代码</li>
</ul>
<h2 id="用户和组"><a class="header" href="#用户和组">用户和组</a></h2>
<p>SignalR 允许将消息发送到与特定用户关联的所有连接，以及指定的连接组。</p>
<h3 id="signalr-中的用户"><a class="header" href="#signalr-中的用户">SignalR 中的用户</a></h3>
<p>SignalR 中的单个用户可以与一个应用建立多个连接。 例如，用户可以在桌面和手机上进行连接。 每台设备都有一个单独的 SignalR 连接，但它们都与同一个用户关联。 如果向用户发送消息，则与该用户关联的所有连接都会收到消息。 可以通过中心内的 Context.UserIdentifier 属性访问连接的用户标识符。</p>
<p>默认情况下，SignalR 使用与连接关联的 ClaimsPrincipal 中的 ClaimTypes.NameIdentifier 作为用户标识符。 若要自定义此行为，请参阅使用声明自定义标识处理。</p>
<p>通过将用户标识符传递给中心方法中的 User 函数，向特定用户发送消息，如以下示例所示：</p>
<blockquote>
<p>⚠️ <strong>备注</strong></p>
<p>用户标识符区分大小写。</p>
</blockquote>
<pre><code class="language-C#">public Task SendPrivateMessage(string user, string message)
{
    return Clients.User(user).SendAsync("ReceiveMessage", message);
}
</code></pre>
<h3 id="signalr-中的组"><a class="header" href="#signalr-中的组">SignalR 中的组</a></h3>
<p>组是与名称关联的连接集合。 你可以将消息发送到组中的所有连接。 建议通过组发送到一个或多个连接，因为组由应用程序管理。 一个连接可以是多个组的成员。 组非常适合聊天应用程序之类的应用，其中每个聊天室都可以表示为一个组。</p>
<h3 id="添加或删除组的连接"><a class="header" href="#添加或删除组的连接">添加或删除组的连接</a></h3>
<p>可通过 AddToGroupAsync 和 RemoveFromGroupAsync 方法在组中添加或删除连接：</p>
<pre><code class="language-C#">public async Task AddToGroup(string groupName)
{
    await Groups.AddToGroupAsync(Context.ConnectionId, groupName);

    await Clients.Group(groupName).SendAsync("Send", $"{Context.ConnectionId} has joined the group {groupName}.");
}

public async Task RemoveFromGroup(string groupName)
{
    await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName);

    await Clients.Group(groupName).SendAsync("Send", $"{Context.ConnectionId} has left the group {groupName}.");
}
</code></pre>
<p>多次将用户添加到组是安全的，如果组中已存在用户，不会引发异常。</p>
<p>重新连接时不会保留组成员身份。 重新建立连接后，需要重新加入组。 无法计算组的成员数，因为如果将应用程序扩展到多台服务器，则无法获取此信息。</p>
<p>组保留在内存中，因此在服务器重启时不会保留。 对于需要保留组成员身份的方案，请考虑 Azure SignalR 服务。 有关详细信息，请参阅 Azure SignalR</p>
<p>若要在使用组时保护对资源的访问，请使用 ASP.NET Core 中的身份验证和授权功能。 如果仅当凭据对组有效时才将用户添加到该组，则发送到该组的消息将仅发送给授权用户。 但是，组不是一项安全功能。 身份验证声明具有组不具备的功能，例如到期和吊销。 如果撤销用户对组的访问权限，应用必须从组中显式删除该用户。</p>
<blockquote>
<p>⚠️ <strong>备注</strong></p>
<p>组名称区分大小写。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aspnet-证书"><a class="header" href="#aspnet-证书">Asp.NET 证书</a></h1>
<h2 id="生成证书"><a class="header" href="#生成证书">生成证书</a></h2>
<p><a href="https://blog.csdn.net/mzl87/article/details/125635650">CSDN</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jwt"><a class="header" href="#jwt">Jwt</a></h1>
<h2 id="密钥的类型"><a class="header" href="#密钥的类型">密钥的类型</a></h2>
<p>密钥通常是一个字符串，通常是用作 HMAC（例如 HS256、HS384、HS512）算法的密钥。这个密钥可以是任何字符串，但为了确保安全性，通常会选择一个随机生成的、足够复杂的字符串。</p>
<h2 id="密钥的长度"><a class="header" href="#密钥的长度">密钥的长度</a></h2>
<p>密钥的长度要求取决于你所使用的加密算法：</p>
<ul>
<li><strong>HS256</strong> : 建议至少使用 32 字节（256 位）长度的密钥。</li>
<li><strong>HS384</strong> : 建议至少使用 48 字节（384 位）长度的密钥。</li>
<li><strong>HS512</strong> : 建议至少使用 64 字节（512 位）长度的密钥。</li>
</ul>
<p>短于这些推荐长度的密钥虽然可以使用，但会降低安全性，增加被破解的风险。</p>
<h2 id="示例代码"><a class="header" href="#示例代码">示例代码</a></h2>
<p>创建TOKEN</p>
<pre><code class="language-C#"> private string CreateToken(User user)
 {
     List&lt;Claim&gt; claims = new List&lt;Claim&gt;
     {
         new Claim(ClaimTypes.NameIdentifier, user.Id),
         new Claim(ClaimTypes.Name, user.Account),
         new Claim(ClaimTypes.Role, user.Role)
     };
     var key = new SymmetricSecurityKey(System.Text.Encoding.UTF8
         .GetBytes(_authSettingsOpt.Value.SecurityKey));

    // var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha512Signature); //这个需要更长的密钥，同时要牺牲一点性能
     var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

     var token = new JwtSecurityToken(
             claims: claims,
             expires: DateTime.Now.AddDays(_authSettingsOpt.Value.ExpireDays),
             //expires: DateTime.Now.AddSeconds(5),
             signingCredentials: creds);

     var jwt = new JwtSecurityTokenHandler().WriteToken(token);

     return jwt;
 }
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<ul>
<li>密钥应该是一个随机生成的、复杂的字符串。</li>
<li>密钥的长度应根据所使用的算法来确定，建议至少达到算法要求的位数，以确保安全性。</li>
</ul>
<p>使用强密码生成器或专门的密钥管理工具来生成和存储这些密钥，可以进一步提升安全性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="balzor"><a class="header" href="#balzor">Balzor</a></h1>
<h2 id="不要复制razor文件"><a class="header" href="#不要复制razor文件">不要复制Razor文件</a></h2>
<p>当复制一个界面作为一个新的界面时，配置了新的 <code>@page</code> ，但是无法路由到此界面，最后新建页面解决，感觉复制页面容易出现Bug，通过新建，把内容复制过来比较靠谱。</p>
<h2 id="注入服务"><a class="header" href="#注入服务">注入服务</a></h2>
<h3 id="页面中中注入服务"><a class="header" href="#页面中中注入服务">页面中中注入服务</a></h3>
<p>不能通过构造函数注入</p>
<p>服务不加 ? 会有警告</p>
<pre><code class="language-c#">[Inject][NotNull] NavigationManager? nav { get; set; }
</code></pre>
<h3 id="服务中注入其他服务"><a class="header" href="#服务中注入其他服务">服务中注入其他服务</a></h3>
<p>最好通过构造函数注入，如 “A” 服务依赖 “B” 服务，在 “A” 中通过构造函数注入 “B”服务，通过属性注入的方式可能会导致注入失败。</p>
<h2 id="脚本函数"><a class="header" href="#脚本函数">脚本函数</a></h2>
<h3 id="oninitializedasync"><a class="header" href="#oninitializedasync">OnInitializedAsync</a></h3>
<p>页面加载进行初始化。</p>
<p>⚠️该函数异步执行，其他函数可能在此函数执行完成后就执行了，所以注意数据的使用</p>
<h2 id="page"><a class="header" href="#page">Page</a></h2>
<h3 id="路由问题"><a class="header" href="#路由问题">路由问题</a></h3>
<p>在ASP.NET Core Razor页面上，我们可以执行以下操作来更改默认的基于文件夹的路由：</p>
<pre><code class="language-razor">@page"/student-list"
</code></pre>
<p>希望 将 <code>/student-list</code> 定义为常量，以便在其他地方共用（如授权策略，菜单导航等），避免重复编写字符</p>
<pre><code>public const string Myroute ="/student-list";
</code></pre>
<pre><code class="language-razor">@page @Constants.Routes.Myroute
</code></pre>
<p>编译时出现错误：<code>The 'page' directive expects a string surrounded by double quotes.</code></p>
<p>总结：网上有一些解决办法，但是都比较复杂，没必要使用，就按照标注的使用双引号字符直接编写。</p>
<h2 id="display特性"><a class="header" href="#display特性">Display特性</a></h2>
<p>在ASP.NET Core中，Display属性是用来定义模型的某个属性在视图中显示的格式。它通常在使用Entity Framework Core的模型类中使用，并且通常与Data Annotations模型进行配合使用。</p>
<p>定义一个枚举，每个值添加Display特性，在使用枚举集合绑定到下拉列表上的时候，视图上显示Display的名称，如果想获取我们选择的值对应的名称，按下面方式实现</p>
<pre><code class="language-csharp">
 public enum MajorType
 {
     [Display(Name = "运营专业")]
     YunYing = 0,
     [Display(Name = "车辆专业")]
     CheLiang = 1,
     [Display(Name = "通号专业")]
     TongHao = 1,
     [Display(Name = "机电专业")]
     JiDian = 1,
     [Display(Name = "供电专业")]
     GongDian = 1,
     [Display(Name = "工务专业")]
     GongWu = 1,
 }
private string GetMajorText(MajorType type)
{

    // 获取枚举类型的字段信息  
    FieldInfo? field = type.GetType().GetField(type.ToString());
    if(field == null) return type.ToString();
    // 检查字段是否有Display特性  
    DisplayAttribute? attribute = Attribute.GetCustomAttribute(field, typeof(DisplayAttribute)) as DisplayAttribute;

    // 返回Display特性的Name属性值，如果没有找到Display特性，则返回枚举值的名称  
    return attribute?.Name ?? type.ToString();
  
}
</code></pre>
<h2 id="blazorinputfile-不支持同步读取"><a class="header" href="#blazorinputfile-不支持同步读取">BlazorInputFile-不支持同步读取</a></h2>
<blockquote>
<p>BlazorInputFile - Synchronous reads are not supported</p>
</blockquote>
<p>在 <code>Blazor</code> 中上传文件，不支持同步读取，仅支持异步，如下方法中上传文件：</p>
<pre><code class="language-c#">private async Task Upload(InputFileChangeEventArgs e)
{
    MemoryStream ms = new MemoryStream();
    e.File.OpenReadStream().CopyTo(ms);
    var bytes = ms.ToArray();
    UploadFile file = new UploadFile
    {
        FileName = e.File.Name,
        FileContent = bytes,
        Size = e.File.Size,
        ContentType = e.File.ContentType
    };
        await Http.PostAsJsonAsync&lt;UploadFile&gt;("/api/uploadfile", file);
        await OnInitializedAsync();
}
</code></pre>
<p>报错：</p>
<pre><code class="language-txt">ortunately I keep getting an error/exception from BlazorInputFile which says "Synchronous reads are not supported".
</code></pre>
<p><strong>解决办法</strong>： 将 <code>OpenReadStream</code>  的复制改为 异步复制：</p>
<pre><code class="language-c#">MemoryStream ms = new MemoryStream();
await e.File.OpenReadStream().CopyToAsync(ms);
</code></pre>
<p>如下写法在非Blazor程序中正确，但是在Blazor中不行：</p>
<pre><code class="language-c#">MemoryStream ms = new MemoryStream();
await e.File.OpenReadStream().CopyTo(ms);

//or
MemoryStream ms =  e.File.OpenReadStream();
</code></pre>
<p><a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0&amp;pivots=server">Blazor 文件上传说明文档</a></p>
<p><strong>阿里云对象存储（OSS）接口</strong></p>
<ul>
<li>
<p>在阿里云的对象存储接口中，只提供了同步方法，导致用户认为，无法在 Blazor 中使用</p>
</li>
<li>
<p>上传文件只能先将客户端的资源保存到服务端，然后使用服务端的本地路径进行上传，不能使用 <code>Stream</code> 上传，否则报 “数组越界”</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bootstrp-blazor"><a class="header" href="#bootstrp-blazor">Bootstrp Blazor</a></h1>
<h2 id="登出组件"><a class="header" href="#登出组件">登出组件</a></h2>
<p><a href="https://www.blazor.zone/logout">登出组件 Logout</a></p>
<p>使用参看官网文档，这里讨论下使用 <code>LogoutLink</code> 的注意事项，必须配置自己的 <code>Url</code> 属性值，如果不配置，直接跳转到默认的 <code> /Account/Login</code>  ，出现找不到页面404错误</p>
<pre><code class="language-html">&lt;Logout ImageUrl="./images/Argo.png" DisplayName="Administrators" UserName="Admin" class="bg-primary"&gt;
    &lt;LinkTemplate&gt;
        &lt;a href="#"&gt;
            &lt;i class="fa-solid fa-user"&gt;&lt;/i&gt;&lt;span&gt;个人中心&lt;/span&gt;
        &lt;/a&gt;
        &lt;a href="#"&gt;
            &lt;i class="fa-solid fa-gear"&gt;&lt;/i&gt;&lt;span&gt;设置&lt;/span&gt;
        &lt;/a&gt;
        &lt;LogoutLink Url="/logouts" /&gt;
    &lt;/LinkTemplate&gt;
&lt;/Logout&gt;
</code></pre>
<p><code>LogoutLink </code>配置了 Url，表示点击登出时，路由到 <code>/logouts</code> 页面</p>
<p>此时需要配置一个登出页面来处理登出逻辑，包含：清除登录数据，自动跳转到登录页：</p>
<pre><code>@namespace xxx
@page "/logouts"
@inherits LayoutComponentBase
你已退出登录!
</code></pre>
<pre><code class="language-csharp">using Blazored.LocalStorage;
using BootstrapBlazor.Components;
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.AspNetCore.Components;

namespace TSIM.Web.Components
{
    /// &lt;summary&gt;
    /// 
    /// &lt;/summary&gt;
    public sealed partial class AccountLogout : LayoutComponentBase
    {
#pragma warning disable CS8618 // 在退出构造函数时，不可为 null 的字段必须包含非 null 值。请考虑声明为可以为 null。
        [Inject] NavigationManager nav { get; set; }
        [Inject] ILocalStorageService _localStorage { get; set; }
        [Inject] AuthenticationStateProvider authStateProvider { get; set; }

#pragma warning restore CS8618 // 在退出构造函数时，不可为 null 的字段必须包含非 null 值。请考虑声明为可以为 null。

        /// &lt;summary&gt;
        /// OnInitialized 方法
        /// &lt;/summary&gt;
        protected async override void OnInitialized()
        {
            await this._localStorage.RemoveItemAsync("authToken");/清除登录数据
            await this.authStateProvider.GetAuthenticationStateAsync();
            nav.NavigateTo("/login", true);//导航到登录页面
        }  
    }
}

</code></pre>
<h2 id="表格页面"><a class="header" href="#表格页面">表格页面</a></h2>
<p>当页面中有表格时，如果出现垂直滚动条错误，采用以下解决方式</p>
<p>整个页面使用 <code>&lt;div&gt;</code> 包裹，可添加 <code>class</code></p>
<pre><code class="language-css">.page-user {
    height: calc(100vh - 162px);
}
</code></pre>
<p>如果希望表格底部的页码正好显示，可以给 <code>table</code> 定义类来解决（自行调整<code>93px</code> 的值)，如：</p>
<pre><code class="language-css">.table-users {
    height: calc(100% - 93px);
}css
</code></pre>
<p>页面：</p>
<pre><code class="language-html">@page "/users"
@attribute [TabItemOption(Text = "花名册")]
&lt;PageTitle&gt;花名册&lt;/PageTitle&gt;

&lt;div class="page-user"&gt;
    &lt;h1&gt;花名册&lt;/h1&gt;

    &lt;p&gt;只读数据 - 更改每页显示数量体验固定表头功能&lt;/p&gt;

    &lt;Table TItem="Foo" class="table-users"&gt;
        &lt;TableColumns&gt;
           ...
        &lt;/TableColumns&gt;
    &lt;/Table&gt;
&lt;/div&gt;
</code></pre>
<h2 id="更改组件的样式"><a class="header" href="#更改组件的样式">更改组件的样式</a></h2>
<p>通过组件属性 <code>AdditionalAttributes</code>  来实现，组件都提供了 <code>class</code> 和 <code>style</code> 两种方式来更改。</p>
<p>在后端定义一个属性 <code>AdditionalAttributes</code>，分别加了 <code>class</code> 和 <code>style</code> 两个key和对应的值</p>
<pre><code class="language-c#">public Dictionary&lt;string, object&gt; AdditionalAttributes { get; set; } = 
new Dictionary&lt;string, object&gt;() 
{ 
	{ "style", "border:none;bacground-color:red;" } ,
	{ "class", "custom-cls" }
};
</code></pre>
<p><strong>style</strong> : 直接编写样式字符串</p>
<p><strong>class</strong> ：值为定义的css类名，这里定义类名为 <code>custom-cls</code> 的样式，设置颜色为红色</p>
<pre><code class="language-css">.custom-cls { color:red; }
</code></pre>
<p>前端假设设置ListView组件，直接绑定我们的属性</p>
<pre><code class="language-html">&lt;ListView  AdditionalAttributes="@AdditionalAttributes" &gt;
&lt;/ListView&gt;
</code></pre>
<p>发现<strong>class</strong>设置的有些值可能无效，可能是优先级的原因，我们添加class的优先级并没有原有的高，但是<strong>style</strong>设置的值都是有效的。</p>
<h2 id="对象绑定"><a class="header" href="#对象绑定">对象绑定</a></h2>
<p>对于框架封装的组件，如Table、ListView等，有时需要手动查询数据，此时需要获得组件对象，通过 <code>@ref</code>来绑定对象，以<strong>ListView</strong>为例：</p>
<p>前端通过 <code>@ref</code> 绑定对象</p>
<pre><code class="language-html">&lt;ListView @ref="listview" &gt;
&lt;/ListView&gt;
</code></pre>
<p>后端定义对象属性，并通过对象调用手工查询方法来更新组件内容</p>
<pre><code class="language-csharp">private ListView&lt;VideoCollModel&gt; listView { get; set; } 

//如果是表格
//private Table&lt;VideoCollModel&gt; table { get; set; } 

//通过对象查询更新内容
listView.QueryAsync();
</code></pre>
<h2 id="本地化资源缺失错误"><a class="header" href="#本地化资源缺失错误">本地化资源缺失错误</a></h2>
<p>❌ <code>System.Resources.MissingManifestResourceException”(位于 System.Private.CoreLib.dll 中)</code></p>
<p>状态：⚠️<strong>未解决</strong>⚠️</p>
<p>由于当前提示的错误不影响使用，没继续研究。</p>
<p><a href="https://www.blazor.zone/localization">组件相关章节</a></p>
<p>异常通常发生在 .NET 程序无法找到指定的资源文件时。这通常出现在使用本地化、资源文件或卫星程序集的应用程序中。</p>
<p><a href="https://chatgpt.com/c/0ac209cd-b5f8-4626-9e15-d807c92c58f0">ChatGPT 回复</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unity"><a class="header" href="#unity">Unity</a></h1>
<h2 id="enum"><a class="header" href="#enum">Enum</a></h2>
<h3 id="自定义特性实现"><a class="header" href="#自定义特性实现">自定义特性实现</a></h3>
<p>定义特性</p>
<pre><code class="language-c#">using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace EnumTest
{
  public class EnumFlags : PropertyAttribute
  {
    public EnumFlags() { }
  }

  #if UNITY_EDITOR
  [CustomPropertyDrawer( typeof( EnumFlags ) )]
  public class EnumFlagsPropertyDrawer : PropertyDrawer
  {
    public override void OnGUI( Rect position, SerializedProperty property, GUIContent label )
    {
      property.intValue = EditorGUI.MaskField( position, label, property.intValue, property.enumNames);
    }
  }
#endif
}
</code></pre>
<p>定义枚举，定义枚举需标记1，2，4...,一次2的次方，代码如下：</p>
<pre><code class="language-c#">public enum MyEnum
{
    A=1,
    B=2,
    V=4
}
</code></pre>
<p>使用特性标记属性面板多选</p>
<pre><code class="language-c#">[EnumFlags]
public MyEnum val;
</code></pre>
<p>判断两个枚举值是否包含相同</p>
<pre><code class="language-c#">public bool IsSelectEnumType(MyEnum e1, MyEnum e2)
{         
    return ((int)e1 &amp; (int)e2) != 0 ;
}
</code></pre>
<h3 id="flags实现"><a class="header" href="#flags实现">Flags实现</a></h3>
<p>略</p>
<h2 id="使用dll"><a class="header" href="#使用dll">使用DLL</a></h2>
<p>在开发过程中，我们需要将一些dll放入Pulgins文件夹下，这时最好使用对应Unity版本的dll，并不是dll的版本越高越好，不同版本在引用Unity中的dll的路径不同，具体参照下表</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">版本</th><th style="text-align: left">dll路径</th><th style="text-align: left">备注</th></tr></thead><tbody>
<tr><td style="text-align: left">以前版本</td><td style="text-align: left"><code>C:\Program Files\Unity\Editor\Data\Mono\lib\mono\2.0</code></td><td style="text-align: left">没有使用HUB安装的以前的版本</td></tr>
<tr><td style="text-align: left">Unity2020.3.x</td><td style="text-align: left"><code>Editor\Data\MonoBleedingEdge\lib\mono\unityjit</code></td><td style="text-align: left">在对应版本的 <code>Editor</code> 下</td></tr>
</tbody></table>
</div>
<p>开发中，我们可能需要使用到如下的dll</p>
<ul>
<li>I18N.CJK.dll</li>
<li>I18N.dll</li>
<li>Mono.Data.Sqlite.dll</li>
<li>System.Data.dll</li>
</ul>
<p>注：某些dll是可以在Unity安装的目录找到的，有些不能，这时需要在官网上看是否有对应Unity的版本，不要一味的最求最新版本</p>
<h2 id="多场景加载"><a class="header" href="#多场景加载">多场景加载</a></h2>
<p>异步加载时，需要设置 <code>asyncOp.allowSceneActivation = false;</code></p>
<p>加载完成后，需要设置 <code>asyncOp.allowSceneActivation = true;</code></p>
<p>注意，此时被加载的场景并不是活跃场景，我们一般都是需要把被加载的场景设置为活跃场景</p>
<pre><code class="language-csharp">//...
  SceneManager.sceneLoaded += SceneLoadHandler;
//...

private void SceneLoadHandler(Scene scene, LoadSceneMode mode)
{
    Debug.Log("激活场景: " + scene.name);
    SceneManager.SetActiveScene(scene);
}
//...
  SceneManager.sceneLoaded -= SceneLoadHandler;
//...
</code></pre>
<h2 id="证书问题崩溃"><a class="header" href="#证书问题崩溃">证书问题崩溃</a></h2>
<p>查看崩溃日志：<code>C:\Users\ABYTE\AppData\Local\Temp\Unity\Editor\Crashes</code>,找到最近一次崩溃的文件夹，查看 <code>Editor.log</code> 文件，若出现 <code>[Licensing::Client] Error: Code 10 while verifying Licensing Client signature</code> 这种错误信息。</p>
<p>删除 <code>C:\ProgramData\Unity\Unity_lic.ulf</code> ，重新激活即可。</p>
<ul>
<li>注意，在使用 "+="时，要匹配使用 “-=”,否则响应会叠加</li>
</ul>
<p>激活场景的目的：多场景时，引擎会使用活跃场景的天空盒</p>
<h2 id="dictionary的key-为-null导致报错"><a class="header" href="#dictionary的key-为-null导致报错">Dictionary的key 为 null导致报错</a></h2>
<p>ArgumentNullException: Value cannot be null.</p>
<pre><code>Parameter name: key
  at System.Collections.Generic.Dictionary`2[TKey,TValue].FindEntry (TKey key) [0x00008] in &lt;695d1cc93cca45069c528c15c9fdd749&gt;:0 
  at System.Collections.Generic.Dictionary`2[TKey,TValue].ContainsKey (TKey key) [0x00000] in &lt;695d1cc93cca45069c528c15c9fdd749&gt;:0 
</code></pre>
<p>Dictionary 的 key 值不能为null.</p>
<p>查看代码追踪 key 的来源，进行修改</p>
<p><strong>注意此问题</strong>：
在编辑模式下，应该也会报错，但是有些时候莫名不会提示你错误，但是在发布后会报错
所以在使用 字典 时，最好对key进行判断**</p>
<h2 id="挂载脚本顺序导致依赖失败"><a class="header" href="#挂载脚本顺序导致依赖失败">挂载脚本顺序导致依赖失败</a></h2>
<p><strong>Unity版本</strong>：Unity2017.3.0</p>
<p><strong>使用情景</strong>：组件依赖问题，自定义了两个脚本，其中A依赖B，但是当停止Play时，报错：<code>CAN'T REMOVE HIGHLIGHTER (SCRIPT) BECAUSE HIGHLIGHTERREGISTER (SCRIPT) DEPENDS ON IT。</code></p>
<p><strong>解决办法</strong>：更改两个脚本的组件顺序，先是依赖项，后为被依赖项。</p>
<p><img src="unity/image/unity/1721199810487.png" alt="1721199810487" /></p>
<p>改为</p>
<p><img src="unity/image/unity/1721199816545.png" alt="1721199816545" /></p>
<h2 id="failed-to-load-mono"><a class="header" href="#failed-to-load-mono">FAILED TO LOAD MONO</a></h2>
<p><strong>Unity版本</strong>：Unity2017.1.0</p>
<p><strong>解决办法</strong>：文件夹不能包含中文名，之前发现有的版本在中文路径下可以，所以觉得后面的版本也应该可以，导致花了很多时间，最后还是中文路径的问题。</p>
<h2 id="unity打包后画面灰色重影带错误的彩色现象"><a class="header" href="#unity打包后画面灰色重影带错误的彩色现象">Unity打包后画面灰色、重影、带错误的彩色现象。</a></h2>
<p>Unity版本：Unity2017.1.0</p>
<p><strong>解决办法</strong>：更新显卡</p>
<h2 id="unity编译时间过长"><a class="header" href="#unity编译时间过长">Unity编译时间过长</a></h2>
<p>可能有很多问题导致的</p>
<ul>
<li>项目过大，资源过多，没办法，或者优化资源（不要有重复的资源）</li>
<li>VS 影响的，关闭VS ,删除 .vs文件夹，打开VS时，重新生成</li>
</ul>
<h2 id="将所有配置关联场景导致内存爆了"><a class="header" href="#将所有配置关联场景导致内存爆了">将所有配置关联场景导致内存爆了</a></h2>
<p>某次项目，配置文件都是使用“ScriptableObject”的方式来配置，为了方便读取，就把它关联的启动场景（Launch,一直存在）上，导致在移动端启动就闪退。
（1）刚开始将所有的配置文件(ScriptableObject)全部挂在到启动场景（Launch）上，导致在移动端启动时，直接闪退。
原因：
所有的配置文件占用大量内存，启动时内存不够用了，直接闪退
解决办法：
（1）按需加载，不要将太多的资源直接关联到场景中，应该按需加载
（2）手动进行Gc回收，可能导致系统卡顿，且存在问题，最好是在退出任务的时候，进下gc回收</p>
<h2 id="链接"><a class="header" href="#链接">链接</a></h2>
<ul>
<li><a href="https://freepbr.com/materials/fiber-textured-wall1/">贴图(有些需要收费，支持Unity和UE)</a></li>
<li><a href="https://gitee.com/jackyuzju/UnityAssetsResources">Unity 插件收集</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>
<h2 id="ui边缘锯齿严重"><a class="header" href="#ui边缘锯齿严重">UI边缘锯齿严重</a></h2>
<p>1.没有开启canvas上的抗锯齿选项，project setting里也要开启抗锯齿，选择2x，4x，8x</p>
<p>2.图片在导入的时候质量被压缩或者应用的时候被缩放。重新设置图片的格式，使图片的质量更高。</p>
<p>3.美术出图的时候，每张图的边缘最好都要留几个空白的像素单位。边缘是产生锯齿的源头，这样被锯齿的部分就是透明的。</p>
<h2 id="ui-1"><a class="header" href="#ui-1">UI</a></h2>
<h3 id="toggle"><a class="header" href="#toggle">Toggle</a></h3>
<p>需求：
第一次不选中任何选项，当点击任一个选项后，自动只选中一个</p>
<ul>
<li>
<p>默认将ToggleGroup allowSwiechOff 勾选</p>
</li>
<li>
<p>调用 toggleGroup.SetAllTogglesOff(false);</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动画"><a class="header" href="#动画">动画</a></h1>
<h2 id="问题汇总-1"><a class="header" href="#问题汇总-1">问题汇总</a></h2>
<h3 id="动画播放失败"><a class="header" href="#动画播放失败">动画播放失败</a></h3>
<blockquote>
<p>如在使用 <code>timeline</code> 时，拖动 <code>timeline</code> 动画正常，但是点击 <code>Play</code> 后动画未播放。</p>
</blockquote>
<p><strong>解决</strong>：</p>
<p>游戏对象是否勾选了 <code>static</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="camera相机"><a class="header" href="#camera相机">Camera(相机)</a></h1>
<p><img src="unity/image/camera/1718097515607.png" alt="1718097515607" /></p>
<p>运行的CameraTag 应该为 MainCamera</p>
<h2 id="projecttion"><a class="header" href="#projecttion">Projecttion</a></h2>
<h2 id="rendering"><a class="header" href="#rendering">Rendering</a></h2>
<p><img src="unity/image/camera/1718097530253.png" alt="1718097530253" /></p>
<ul>
<li>
<p>Renderer</p>
</li>
<li>
<p>PostProcession</p>
</li>
<li>
<p>Anti-aliasing</p>
</li>
<li>
<p>StopNan</p>
</li>
<li>
<p>Dithering：</p>
</li>
<li>
<p>RenderShadows</p>
</li>
<li>
<p>Priority</p>
</li>
<li>
<p>OpaqueTexture</p>
</li>
<li>
<p>DepthTexture</p>
</li>
<li>
<p>CullingMask：剔除遮罩，勾选要渲染的层，注意：如果不勾选，不仅不渲染，且不会响应射线事件</p>
</li>
<li>
<p>OcclusionCulling</p>
</li>
</ul>
<h2 id="envrionment"><a class="header" href="#envrionment">Envrionment</a></h2>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<h1 id="physicsraycaster"><a class="header" href="#physicsraycaster">PhysicsRaycaster</a></h1>
<p>用于射线检测，可对场景中的数据进行交互</p>
<ul>
<li>EventMask：这里勾选需要交互的层级，同时注意在Camera-&gt;Renderer-&gt;CullingMask 中也要勾选响应的层级</li>
<li>MaxRayIntersections: 最大射线距离</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="向量"><a class="header" href="#向量">向量</a></h1>
<h2 id="1-基础知识"><a class="header" href="#1-基础知识">1 基础知识</a></h2>
<h3 id="11-向量叉积"><a class="header" href="#11-向量叉积">1.1 向量叉积</a></h3>
<p>若有向量a、b 则向量的叉积为：</p>
<p>数学上定义：</p>
<pre><code>a×b=|a||b|sin&lt;a，b&gt;  # 使用弧度计算
</code></pre>
<p>Unity 对应函数:</p>
<pre><code> public static Vector3 Cross(Vector3 lhs, Vector3 rhs);
</code></pre>
<p><strong>三维坐标中</strong></p>
<ul>
<li>结果是一个向量(法向量)，方向：根据右手定则，四指从a的方向向b旋转，大拇指的方向就是结果方向</li>
<li>当a是单位向量时，计算b终点到a所在直线的距离</li>
</ul>
<p><strong>二维坐标中</strong></p>
<ul>
<li>叉积等于由向量A和向量B构成的平行四边形的面积</li>
</ul>
<h3 id="12-向量点积"><a class="header" href="#12-向量点积">1.2 向量点积</a></h3>
<p>若有向量a、b 则向量的点积为：</p>
<p>数学定义：</p>
<pre><code>a·b=|a||b|cos&lt;a，b&gt;  # 使用弧度计算
</code></pre>
<p>Unity对应函数：</p>
<pre><code>public static float Dot(Vector3 lhs, Vector3 rhs);
</code></pre>
<ul>
<li>结果是一个标量。</li>
<li>常用于计算 <strong>两个向量的夹角</strong> :当a、b向量的模都为1（向量归一化），得到的为a、b向量的余玄值，求反余玄，得到夹角(弧度)</li>
</ul>
<h3 id="13-弧度和度"><a class="header" href="#13-弧度和度">1.3 弧度和度</a></h3>
<blockquote>
<p>通常我们说两个向量的角度为30度，30指的是 <strong>度</strong> ，
弧度：180度对应的 <strong>弧度</strong> 是 Π，Unity里为常量： UnityEngine.Mathf.PI</p>
</blockquote>
<ul>
<li>Unity里使用向量的方法都是使用弧度计算，而我们通常配置都是使用度（度在描述时更形象，一圈就是360度），所以需要将度转换为弧度</li>
</ul>
<p><strong>Unity中提供了转换的比例常数</strong></p>
<ul>
<li>度转弧度：Mathf.Deg2Rad，等价于 180/(UnityEngine.Mathf.PI)</li>
<li>弧度转度：Mathf.Rad2Deg，等价于 (UnityEngine.Mathf.PI)/180</li>
</ul>
<p><strong>举例：求Sin(30)的值</strong></p>
<pre><code>var v = Mathf.Sin(30*Mathf.Deg2Rad)
</code></pre>
<h2 id="2-常用函数"><a class="header" href="#2-常用函数">2 常用函数</a></h2>
<h3 id="21-两向量的夹角"><a class="header" href="#21-两向量的夹角">2.1 两向量的夹角</a></h3>
<pre><code>var cosValue= Vector3.Dot(player.forward.normalized, (target.position - player.position).normalized);
float rad = Mathf.Acos(cosValue);//反余玄求夹角的弧[-1,1]
var deg = rad * Mathf.Rad2Deg;//弧度转度

</code></pre>
<h3 id="22-判断目标点相对玩家的方位"><a class="header" href="#22-判断目标点相对玩家的方位">2.2 判断目标点相对玩家的方位</a></h3>
<p>设:</p>
<ul>
<li>玩家为： player(Transform)</li>
<li>目标为： target(Transform)</li>
</ul>
<h4 id="221-前后判断"><a class="header" href="#221-前后判断">2.2.1 前后判断</a></h4>
<ul>
<li>原理说明：通过玩家正前方向量(forward)与玩家到目标构成的向量之间的夹角来判断，&gt;90度（余玄值&lt;0）在后方，&lt;90度 (余玄值&gt;0) 在前方</li>
<li>使用知识：点乘</li>
</ul>
<pre><code>//非归一化
var value = Vector3.Dot(player.forward,target.position - player.position);
//value &gt; 0: 前方
//value &lt; 0: 后方

</code></pre>
<p>或者</p>
<pre><code>//归一化，得到的值范围：[-1,1]
var value = Vector3.Dot(player.forward.normalized, (target.position - player.position).normalized);
//value &gt; 0: 前方
//value &lt; 0: 后方

</code></pre>
<h4 id="222-左右判断"><a class="header" href="#222-左右判断">2.2.2 左右判断</a></h4>
<p>与“前后判断”原理相同，仅需要使用 <code>player.right</code> 进行计算即可</p>
<pre><code>//归一化，得到的值范围：[-1,1]
var value = Vector3.Dot(player.right.normalized, (target.position - player.position).normalized);
//value &gt; 0: 右方
//value &lt; 0: 左方

</code></pre>
<h4 id="223-上下判断"><a class="header" href="#223-上下判断">2.2.3 上下判断</a></h4>
<p>与“前后判断”原理相同，仅需要使用 <code>player.up</code> 进行计算即可</p>
<pre><code>//归一化，得到的值范围：[-1,1]
var value = Vector3.Dot(player.up.normalized, (target.position - player.position).normalized);
//value &gt; 0: 上方
//value &lt; 0: 下方

</code></pre>
<h2 id="3-需求案例"><a class="header" href="#3-需求案例">3 需求案例</a></h2>
<h3 id="31-判断对象是否在玩家视野内"><a class="header" href="#31-判断对象是否在玩家视野内">3.1 判断对象是否在玩家视野内</a></h3>
<p><strong>分析</strong></p>
<ul>
<li>视野是以相机为起点的一个圆锥体</li>
<li>视野的正前方为 forward方向</li>
<li>求夹角，用点积</li>
</ul>
<p><strong>求解</strong>
假设玩家对象为<code>player(transform)</code>,视野的大小为 <code>filedView</code>，从角色位置出发，任意一个向量和正前方的向量的 <code>夹角 &lt;= filedView * 0.5</code> ，那么该向量上的点都在视野内。</p>
<pre><code>private bool Check(Transform player, int filedView)
{
    Vector3 playerFoward = player.forward;// 角色正前方的向量
    Vector3 player2TagVec = transform.position - player.position;//角色到目标点的向量
    //向量归一化后求两个向量的点积(标量)
    var v = Vector3.Dot(playerFoward.normalized, player2TagVec.normalized);
    //然后反余玄求到夹角的弧度,这里的结果是要给-1 到 1 的弧度。
    float rad = Mathf.Acos(v);
    var deg = rad * Mathf.Rad2Deg;//弧度转度
    return deg &lt;= filedView * 0.5f;//filedView：player 前方锥形角度
}
</code></pre>
<p><strong>存在问题</strong></p>
<ol>
<li>若仅仅通过角度来判断，且这个角度是固定的，当角色与目标点较近时，此时目标点在视野外，但是此时判断就很奇怪，所以应将角度 与 “玩家和目标点的距离” 同时用于判断</li>
</ol>
<pre><code>//1）假设玩家和目标点的距离（水平面上的距离）为1m时，角度判断为30度
//2）那么用于实际判断的 filedView = 30/距离
//3）当玩家与目标越来越近时，应该使用更大的距离来判断
//4）这个距离应该在0-160度之间（自己可以改动这个范围）

    private bool CheckInFiledView(Transform player, int fieldView)
    {
        Vector3 playerFoward = player.forward;// 角色正前方的向量
        Vector3 player2TagVec = transform.position - player.position;//角色到目标点的向量
        var cosValue = Vector3.Dot(playerFoward.normalized, player2TagVec.normalized);//向量归一化后求两个向量的点积(标量),即两向量的夹角的余玄值
        if (cosValue &lt; 0) return false;// &gt; 90 为 负值，表示 目标在角色后面
        float rad = Mathf.Acos(cosValue);//反余玄求夹角的弧[-1,1]
        float disOnPlane = player.DistanceToTargetOnHorPlane(transform);//求玩家和目标的水平面上的距离
        float newFiled = fieldView / disOnPlane;
        newFiled = Mathf.Clamp(newFiled, 0f, 60f);
        var deg = rad * Mathf.Rad2Deg;//弧度转度
        bool r = deg &lt;= newFiled * 0.5f;//filedView：player 前方锥形角度
        // if (r)
        //     Debug.Log($"激活的相机：{player.name}  目标： {name}  v: {cosValue}    deg: {deg}  newFiled{newFiled} ");
        return r;
    }

</code></pre>
<h3 id="32-怪物看向玩家"><a class="header" href="#32-怪物看向玩家">3.2 怪物看向玩家</a></h3>
<blockquote>
<p>要点：控制怪物仅围绕Y轴旋转，否则怪物会倾斜</p>
</blockquote>
<blockquote>
<p>如在场景中有一个ui箭头指示操作，此时需要玩家看向箭头时，永远是箭头的正确面</p>
</blockquote>
<pre><code>private void lookat(Transform self, Transform target)
    {
        //look的方向 起点 - 终点
        Vector3 dir = target .position - self.position;
        //设置y轴上为0，不偏移
        dir.y = 0;
        //四元数插值运算
        self.rotation = Quaternion.Slerp(self.transform.rotation, Quaternion.LookRotation(dir), Time.deltaTime);
    }

</code></pre>
<h3 id="33-vr中在玩家面前显示ui"><a class="header" href="#33-vr中在玩家面前显示ui">3.3 VR中在玩家面前显示UI</a></h3>
<p><strong>分析</strong></p>
<ul>
<li>一个位置坐标 + 一个向量 = 从这个位置，以向量方向移动向量模的距离后的新的位置点</li>
<li>ui 始终垂直水平面，不能前后左右倾斜</li>
</ul>
<p><strong>求解</strong></p>
<pre><code>   Transform player; //玩家对象
    
    public void (Transform ui)
    {
        Vector3 forward = player.forward;
        forward.y = 0;//这样得到的就是一个平行水平面的一个向量
        var vMove = forward.normalized;//归一化
        
        Vector3  pos= player.position - vMove * 2;//正前方2米的位置，我们可以设置这个参数

        ui.SetPositionAndRotation(pos, Quaternion.LookRotation(v));

        //ui.SetPositionAndRotation(pos - Vector3.up * 0.2f, Quaternion.LookRotation(v)); //也可以调整高度      
    }    

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>收集了网上的一些帖子，以便需要时自己看</p>
</blockquote>
<h4 id="unity2020"><a class="header" href="#unity2020">Unity2020</a></h4>
<p><a href="https://zhuanlan.zhihu.com/p/271561018">烘焙常见问题及解决</a></p>
<h4 id="关注的博主"><a class="header" href="#关注的博主">关注的博主</a></h4>
<p><a href="https://blog.csdn.net/leeby100?type=blog">程美博主</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="material材质"><a class="header" href="#material材质">Material(材质)</a></h1>
<h2 id="通过改变材质的属性改变gameobject的显示"><a class="header" href="#通过改变材质的属性改变gameobject的显示">通过改变材质的属性改变Gameobject的显示</a></h2>
<p>在项目中，经常需要控制改变某些对象的显示状态，如红绿灯的控制，假设现在有个3个红绿灯，有三种状态，红、绿、黄，要控制他们显示不同的颜色</p>
<h3 id="更改材质实现"><a class="header" href="#更改材质实现">更改材质实现</a></h3>
<ul>
<li>
<p>一个材质是一个shader的实例，当改变材质的状态时，如我们在属性面板直接改变材质的颜色或者贴图等，那么会导致使用了此材质的所有对象都同步改变</p>
</li>
<li>
<p>创建三个材质，分别为 红 绿 黄</p>
</li>
<li>
<p>此时根据需求替换对应的材质即可</p>
</li>
</ul>
<h3 id="通过材质属性块实现"><a class="header" href="#通过材质属性块实现">通过材质属性块实现</a></h3>
<p>个人理解：材质属性块应该是材质中的一个属性实例，也就是说材质对该属性，仅是关联引用，并没有关联具体的值，当改变值时，引用不变，因此可以实现不同的游戏对象，使用一个材质，他们同时对某个属性引用，但是可以通过设置不同的值来实现不同的表现方式</p>
<p>实现代码</p>
<pre><code>
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MaterialTest : MonoBehaviour
{
    public Color color;
    void Start()
    {
        var render = GetComponent&lt;Renderer&gt;();
        MaterialPropertyBlock block = new MaterialPropertyBlock();
        render.GetPropertyBlock(block);
        block.SetColor("_BaseColor",color);
        render.SetPropertyBlock(block);
    }

    
</code></pre>
<h2 id="经验记录"><a class="header" href="#经验记录">经验记录</a></h2>
<ol>
<li>某些材质的SurfaceTpye设置为Transparent，导致渲染前后错乱，应改为Opaque</li>
</ol>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li>https://developer.aliyun.com/article/432429</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
    align-items: center; /* 垂直居中 */
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 12px;
    vertical-align: top; 
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
    text-align: center;
}

.excel-table tr:nth-child(even), table tr:nth-child(odd) {
    background-color: transparent; /* 确保所有行背景色一致 */
}

.excel-table tr:hover {
    background-color: inherit;
}
/*

.excel-table tr:nth-child(even) {
    background-color: #f9f9f9;
}

.excel-table tr:hover {
    background-color: #e9e9e9;
}
*/
.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    width: 18%;
}
.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 18%;
}
.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width: 18%;
}
.excel-table th:nth-child(4), .excel-table td:nth-child(4) {
    width: 18%;
}
.excel-table th:nth-child(5), .excel-table td:nth-child(5) {
    width: 28%;
}

</style>
<h1 id="awake"><a class="header" href="#awake">Awake</a></h1>
<pre><code>    private void Awake()
    {
        Debug.Log("Awake");
    }
</code></pre>
<ul>
<li>引擎首先调用的函数</li>
<li>游戏对象被隐藏时，不会执行</li>
<li>enabel： 启用与否都会执行</li>
<li>脚本执行顺序：Awake-&gt;...</li>
</ul>
<h1 id="onenable"><a class="header" href="#onenable">OnEnable</a></h1>
<pre><code>    private void OnEnable()
    {
        Debug.Log("OnEnable");
    }

</code></pre>
<ul>
<li>游戏对象被隐藏时，不会执行</li>
<li>enabel = true 才会执行</li>
<li>脚本执行顺序：Awake-&gt;OnEnable-&gt;...</li>
</ul>
<h1 id="start"><a class="header" href="#start">Start</a></h1>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<ul>
<li>
<p>当游戏对象显示后调用</p>
</li>
<li>
<p>仅调用一次，即来回切换游戏对象显示隐藏时，仅在第一次显示时被调用</p>
</li>
<li>
<p>当在Awake函数设置 gameobject.setactive(false); 时，不会被调用</p>
</li>
<li>
<p>游戏对象被隐藏时，不会执行</p>
</li>
<li>
<p>enabel = true 才会执行</p>
</li>
<li>
<p>脚本执行顺序：Awake-&gt;OnEnable-&gt;Start-&gt;...</p>
</li>
</ul>
<h2 id="一个案例说明"><a class="header" href="#一个案例说明">一个案例说明</a></h2>
<ul>
<li>在 Awake 里面设置 对象隐藏，运行后，Awake被执行，此时 Start 不会被调用</li>
<li>通过点击一个按钮来 调用gameobject.setactive(true) 显示对象</li>
<li>此时要注意，onclick函数里的代码要完全执行完成后，才会执行start</li>
<li>通常的 误解是 只要 gameobject.setactive(true) start就会立刻被调用</li>
</ul>
<p>下面代码示例输出：
运行后：awake
点击调用onclick:
for i = 0
for i = 1
onclick end
start</p>
<p>这里就导致了start在其他函数后面调用了，容易出问题</p>
<pre><code>
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TestStart : MonoBehaviour
{
    private void Awake()
    {
        gameObject.SetActive(false);
        Debug.Log("awake");
    }
    void Start()
    {
        Debug.Log("start");
    }

    public void OnClick()
    {
        gameObject.SetActive(true);
        for(int i = 0; i&lt;100;i++)
        {
            Debug.Log("for i = "+ i);
        }
        Debug.Log("onclick end");

    }


}

</code></pre>
<h2 id="一个错误示例"><a class="header" href="#一个错误示例">一个错误示例</a></h2>
<pre><code>public class Test:MonoBehaviour
{
    bool state;
    private void Awake()
    {
        gameObject.SetActive(false);
    }
    private void Start()
    {
        state = true;
    }
    //点击调用
    public void onclick()
    {
        gameObject.SetActive(true);
        Debug.Log(state);
    }
}

</code></pre>
<p>上面代码中，我在onclick函数里面，预期的输出是 true，但是实际结果是 false, 因为在运行后，wake将 游戏对象设置为未激活状态，导致，star未被执行，而在onclick时,虽然激活了游戏对象，但是当前代码域未执行完，不会调用start，所以先输出 false，然后才执行start ，赋值为 true。</p>
<h1 id="update"><a class="header" href="#update">Update</a></h1>
<pre><code>    private void Update()
    {
        Debug.Log("Update");
    }

</code></pre>
<ul>
<li>游戏对象被隐藏时，不会执行</li>
<li>enabel = true 才会执行</li>
<li>脚本执行顺序：Awake-&gt;OnEnable-&gt;Start-&gt;Update-&gt;...</li>
</ul>
<h1 id="onbecamevisible"><a class="header" href="#onbecamevisible">OnBecameVisible</a></h1>
<pre><code>
    private void OnBecameVisible()
    {
        Debug.Log("OnBecameVisible");
    }

</code></pre>
<ul>
<li>游戏对象被隐藏时，不会执行</li>
<li><strong>enabel 不影响调用</strong></li>
<li><strong>脚本所在的游戏对象需要meshRenderder组件 且 enable =true</strong></li>
<li><strong>当进入相机视野内时调用</strong></li>
<li><strong>在编辑模式 Scene 窗口，进入窗口范围时调用</strong></li>
<li>若一开始就在相机范围内，脚本执行顺序：Awake-&gt;OnEnable-&gt;Start-&gt;Update-&gt;Update-&gt;OnBecameVisible-&gt;... （注意：在调用两次 Update后调用这个函数）</li>
</ul>
<h1 id="onbecameinvisible"><a class="header" href="#onbecameinvisible">OnBecameInvisible</a></h1>
<pre><code>
    private void OnBecameInvisible()
    {
        Debug.Log("OnBecameInvisible");
    }
</code></pre>
<ul>
<li>游戏对象被隐藏时，不会执行</li>
<li><strong>enabel 不影响调用</strong></li>
<li><strong>脚本所在的游戏对象需要meshRenderder组件 enable =true</strong></li>
<li><strong>当离开相机视野内时调用</strong></li>
<li><strong>在编辑模式 Scene 窗口，离开窗口范围时调用</strong></li>
</ul>
<h1 id="ontriggerenterontriggerexit"><a class="header" href="#ontriggerenterontriggerexit">OnTriggerEnter/OnTriggerExit</a></h1>
<pre><code>
    private void OnTriggerEnter(Collider other)
    {
        Debug.Log("OnTriggerEnter");
    }

    private void OnTriggerExit(Collider other)
    {
        Debug.Log("OnTriggerExit");
    }


     //一般情况下不用，耗性能
     private void OnTriggerStay(Collider other) {
        Debug.Log("OnTriggerStay");
    }

</code></pre>
<ul>
<li>一般用于检车玩家进入某个触发区域</li>
<li><strong>enabel 不影响调用</strong></li>
<li>游戏对象需要显示</li>
<li>两个对象至少有个挂载 <code>刚体(Rigidbody)</code>  组件，两个都挂也会触发</li>
<li>两个对象都要挂载 <code>Collider</code> 组件,至少有个设置IsTrigger = true</li>
<li>两个对象可以挂载多个 Collider，但是不能同时存在 <code>IsTrigger = false</code>的 Collider (A/B上不能同时存在)</li>
</ul>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>A <br>Collider数量</th>
                <th>A 勾选IsTrigger数量</th>
                <th>B <br>Collider数量</th>
                <th>B 勾选IsTrigger数量</th>
                <th>触发结果</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td><td>1</td> <td>1</td><td>1</td>
                <td>触发 <b>1</b> 次Enter/Exit</td>
            </tr>
            <tr>
                <td>2</td><td>2</td> <td>1</td><td>1</td>
                <td>触发 <b>2</b> 次Enter/Exit</td>
            </tr> <tr>
                <td>1</td><td>1</td> <td>2</td><td>2</td>
                <td>触发 <b>2</b> 次Enter/Exit</td>
            </tr> <tr>
                <td>2</td><td>2</td> <td>2</td><td>2</td>
                <td>触发 <b>4</b> 次Enter/Exit</td>
        </tbody>
    </table>
</div>
<h2 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h2>
<ul>
<li>角色进入触发器中，若此时隐藏掉触发器对象，不会触发Exit方法</li>
</ul>
<h1 id="ondisable"><a class="header" href="#ondisable">OnDisable</a></h1>
<pre><code>    private void OnDisable()
    {
        Debug.Log("OnDisable");
    }
</code></pre>
<ul>
<li>游戏对象需要显示</li>
<li>当设置 enable = false 时触发</li>
<li>对象删除时触发</li>
<li>场景卸载时触发</li>
</ul>
<h1 id="ondestroy"><a class="header" href="#ondestroy">OnDestroy</a></h1>
<pre><code>    private void OnDestroy()
    {
        Debug.Log("OnDestroy");
    }
</code></pre>
<ul>
<li>游戏对象需要显示</li>
<li><strong>enabel 不影响调用</strong></li>
<li>对象删除时触发</li>
<li>场景卸载时触发</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timeline"><a class="header" href="#timeline">Timeline</a></h1>
<h2 id="playabledirector"><a class="header" href="#playabledirector">PlayableDirector</a></h2>
<blockquote>
<p>导演，挂在场景游戏对象上的一个组件</p>
</blockquote>
<ul>
<li><strong>Playable</strong>  ：Timeline编辑的资源，类型为 “TimelineAsset”</li>
<li><strong>UpdateMethod</strong>  ：更新方式，默认 GameTime</li>
<li><strong>PlayOnAwake</strong>  ：在游戏对象Wake时，是否播放Timeline</li>
<li><strong>WrapMode</strong>  ：循环模式</li>
<li><strong>InitialTime</strong>  ：初始化时间，若设置了时间，会等待这个时间之后才播放</li>
<li><strong>Bindings</strong>  ：绑定的轨道数据</li>
</ul>
<h2 id="timelineasset"><a class="header" href="#timelineasset">TimelineAsset</a></h2>
<blockquote>
<p>编辑时间线数据时，存储的数据</p>
</blockquote>
<p>获取轨道集合</p>
<pre><code class="language-csharp">timelineAsset.GetOutputTracks()
</code></pre>
<p>通过轨道获取timeline资源( <code>track.timelineAsset</code> )，但是可能返回null，导致异常，可能的原因是复制timeline导致的，如果出现异常，可以通过 遍历打印出每个轨道的名字来检测</p>
<pre><code class="language-csharp">public TimelineAsset timelineAsset
{
    get
    {
        var node = this;
        while (node != null)
        {
            if (node.parent == null)
                return null;
            var seq = node.parent as TimelineAsset;
            if (seq != null)
                return seq;
            node = node.parent as TrackAsset;
        }
        return null;
    }
}
</code></pre>
<h2 id="trackasset轨道"><a class="header" href="#trackasset轨道">TrackAsset(轨道)</a></h2>
<blockquote>
<p>编辑时间线数据时，存储的数据</p>
</blockquote>
<ul>
<li>
<p><strong>name</strong> :轨道名称</p>
</li>
<li>
<p><strong>Start(float)</strong>  ：开始时间</p>
</li>
<li>
<p><strong>End(float)</strong>  ：结束时间</p>
</li>
<li>
<p><strong>duration(float)</strong>  ：轨道长度</p>
</li>
<li>
<p><strong>muted(bool)</strong>  ：是否静音，静音轨道从生成的PlayableGraph中被排除，所以应先静音，再 buildGraph</p>
</li>
<li>
<p><strong>timelineAsset(TimelineAsset)</strong>  ：这个指向 时间线资源，实际上对应的是 轨道的 根 父节点</p>
</li>
<li>
<p><strong>parent（PlayableAsset）</strong>  ：轨道的父节点（轨道的拥有者），轨道是可以嵌套的， TrackGroup 可以包含其他 轨道，所有轨道的最终父节点应为 TimelineAsset，即我们编辑的资源</p>
</li>
<li>
<p><strong>clips（TimelineClip[]）</strong>  ：轨道片段数组</p>
</li>
</ul>
<p>获取轨道绑定的对象</p>
<pre><code class="language-csharp">var bind = director.GetGenericBinding(track);//需要使用Director来获取，  得到的是一个UnityEngine.Object  

</code></pre>
<p>重写CreateTrackMixer</p>
<pre><code class="language-csharp"> public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
 {
    //graph: timelineasset构建的图
    //go: 挂载 director 的游戏对象
    //inputCount: 片段数量
     return base.CreateTrackMixer(graph, go, inputCount);
 }
</code></pre>
<h2 id="混合器"><a class="header" href="#混合器">混合器</a></h2>
<h3 id="描述"><a class="header" href="#描述">描述</a></h3>
<p>根据片段的权重来控制某个参数的百分比，可用于解决以下需求：</p>
<p>（1）动画轨道（可以和controller 混合使用）</p>
<p>（2）解决淡进淡出问题</p>
<p>（3）解决监听播放一个片段结束问题（这里可以避免因暂停timeline导致误认为播发结束的问题）</p>
<h3 id="淡进淡出案例"><a class="header" href="#淡进淡出案例">淡进淡出案例</a></h3>
<p>使用 <code>CanvasGroup</code> 组件来实现效果</p>
<pre><code class="language-csharp">public class CanvasGroupTrack : TrackAsset
{
    public float easeduration = 0.5f;
    public bool useSettingForAllClips;
    public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
    {
        //graph: timelineasset构建的图
        //go: 挂载 director 的游戏对象
        //inputCount: 片段数量
        if (useSettingForAllClips) UpdateEaseDuration();
        return ScriptPlayable&lt;CanvasGroupMixerBehaviour&gt;.Create(graph, inputCount);
    }

    private void UpdateEaseDuration()
    {
        foreach (var clip in GetClips())
        {
            clip.easeInDuration = easeduration;
            clip.easeOutDuration = easeduration;
        }
    }
}


/// &lt;summary&gt;
/// 注意事项：
/// 1 gameObject.activeSelf 必须为true 否则会导致 初次设置 淡进淡出 报错，提示就是获取不到 reacTransform 
/// 2 当淡出后，必须设置canvasgroup 不可交互，否则会挡住其他的交互
/// &lt;/summary&gt;
public class CanvasGroupMixerBehaviour : PlayableBehaviour
{
    CanvasGroup canvasGroup;

    public override void ProcessFrame(Playable playable, FrameData info, object playerData)
    {
        if (canvasGroup == null)
        {
            MonoBehaviour bind = playerData as MonoBehaviour;
            if (bind == null) return;
            if (bind.gameObject.activeSelf == false)
            {
                bind.gameObject
                    .SetActive(true); //注意：滚到绑定的对象必须设置为 active 状态，否则会导致 初次设置 淡进淡出 报错，提示就是获取不到 reacTransform 
            }

            canvasGroup = bind.GetComponent&lt;CanvasGroup&gt;();
            if (canvasGroup == null)
            {
                Debug.LogWarning("CanvasGroupMixerBehaviour：轨道使用淡进淡出效果，但是缺少 CanvasGroup组件");
                return;
            }
        }

        int inputCount = playable.GetInputCount(); //这是当前轨道上所有片段的数量，注意不是当前帧

        //通过每个片段当前的权重和来设置 canvasGroup alpha值
        float inputWeight = 0;
        for (int i = 0; i &lt; inputCount; i++)
        {
            float curWeight = playable.GetInputWeight(i);
            if (curWeight &gt; 0)
                inputWeight += curWeight;
        }
        canvasGroup.alpha = inputWeight;
        var b = inputWeight &gt; 0.05f; //设置使用0.05的阈值来设定而非0，避免极限情况的出现
        if (canvasGroup.blocksRaycasts != b)
        {
            canvasGroup.blocksRaycasts = b;
        }
    }
}
</code></pre>
<p><strong>注意事项</strong>：在这个案例中，场景中对轨道绑定的CanvasGroup对象默认为“未激活”状态，每次运行的时候报错，最后在首次给CanvasGroup赋值时，将对象激活显示出来，解决问题。</p>
<p><img src="unity/image/timeline/1721813944567.png" alt="1721813944567" /></p>
<h2 id="扩展功能"><a class="header" href="#扩展功能">扩展功能</a></h2>
<h3 id="复制timeline资源解决绑定丢失"><a class="header" href="#复制timeline资源解决绑定丢失">复制Timeline资源，解决绑定丢失</a></h3>
<p>已在UKit中添加了工具处理，下面可作为原理参照。</p>
<p>_ ** 应用场景：复制已经配置好的TimelineA,改为TimelineB,发现B上的轨道绑定丢失 **_</p>
<p>配置 <strong>TimelineA</strong></p>
<p><img src="unity/image/timeline/1721813994579.png" alt="1721813994579" /></p>
<p>在场景中复制TimelineA，改为 TimelineB</p>
<p><img src="unity/image/timeline/1721814013936.png" alt="1721814013936" /></p>
<p>复制资源 TimelineA，改为 TimelineB，并托给场景中 TimelineB 的Director,此时发现绑定丢失</p>
<p><img src="unity/image/timeline/1721814028802.png" alt="1721814028802" /></p>
<p>观看下图分析，它隐藏绑定了A的，且绑定正确，B上的丢失了，我们就要去找到这部分配置，修改，使用Notepad++工具</p>
<p><img src="unity/image/timeline/1721814045040.png" alt="1721814045040" /></p>
<ul>
<li>
<p>通过  <strong>TimelineA.playable.meta</strong> 文件找到 TimelineA 资源文件的 <code>guid:56b3a74b657957d4cae6622c4a199001</code></p>
</li>
<li>
<p>通过  <strong>TimelineB.playable.meta</strong> 文件找到 TimelineB 资源文件的 <code>guid:c4cdb66148603ca4080d5eeb2b49d526</code></p>
</li>
<li>
<p>打开 TimelineAssetCopyTest.unity 场景文件，然后找到 <code>c4cdb66148603ca4080d5eeb2b49d526的位置</code></p>
</li>
</ul>
<p><img src="unity/image/timeline/1721814094360.png" alt="1721814094360" /></p>
<ul>
<li>我们只需要将下方的B的 guid 替换上方的A的 guid,并删除下方 fileID 为 0 的绑定，就可以了</li>
</ul>
<pre><code>PlayableDirector:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1410287964}
  m_Enabled: 1
  serializedVersion: 3
  m_PlayableAsset: {fileID: 11400000, guid: c4cdb66148603ca4080d5eeb2b49d526, type: 2}
  m_InitialState: 1
  m_WrapMode: 2
  m_DirectorUpdateMode: 1
  m_InitialTime: 0
  m_SceneBindings:
  - key: {fileID: 8672370563209045018, guid: c4cdb66148603ca4080d5eeb2b49d526, type: 2}
    value: {fileID: 1191359100}
  - key: {fileID: -1281548762813716947, guid: c4cdb66148603ca4080d5eeb2b49d526, type: 2}
    value: {fileID: 1489575779}
  m_ExposedReferences:
    m_References: []
--- !u!4 &amp;1410287966
</code></pre>
<ul>
<li>改后截图</li>
</ul>
<p><img src="unity/image/timeline/1721814115192.png" alt="1721814115192" /></p>
<h2 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h2>
<blockquote>
<p>开发过程中的经验总结</p>
</blockquote>
<ul>
<li>冗余绑定，复制Timeline会将原有的轨道绑定复制过来，需要删除掉不必要的信息</li>
<li>Timeline资源最好不要复制</li>
<li>编辑器模式下正常，发布后若出现Timeline不能播放，有可能是某些轨道有问题（track.timelineAsset == null）,编写测试找到轨道，然后新建相同的轨道功能，删除原有轨道</li>
</ul>
<h2 id="问题与解决方案"><a class="header" href="#问题与解决方案">问题与解决方案</a></h2>
<blockquote>
<p>此处的问题解决后会将解决方案加入的注意事项中</p>
</blockquote>
<h3 id="发布后timeline不播放"><a class="header" href="#发布后timeline不播放">发布后Timeline不播放</a></h3>
<ul>
<li>版本 Unity2020.3.40f</li>
<li>Timeline版本是最新的</li>
<li>问题详情：在编辑器模式下，播放正常，发布后Timeline不播放（无论是安卓端还是PC端）</li>
</ul>
<h4 id="第1次处理"><a class="header" href="#第1次处理">第1次处理</a></h4>
<ul>
<li>删除Timeline的冗余</li>
<li>隐藏其他Timeline</li>
</ul>
<p>未找到根本的原因，使用下面的方式可以正常播放，但是总是不靠谱</p>
<ol>
<li>在发布前，将timeline的播放针头托到起始位置</li>
<li>有种情况是即使在起始位置，也会有问题，需要再次打开这个场景，然后再发布，不知道到底什么原因</li>
</ol>
<h4 id="第2次处理"><a class="header" href="#第2次处理">第2次处理</a></h4>
<p><strong>调试处理过程记录</strong></p>
<ol>
<li>
<p>开始发布的是安卓版本，不是很好调试，后面发布PC端的 Debug 版本来查看下报错信息</p>
</li>
<li>
<p>报错信息是TimelinePlayable(插件内置类)中的 下面165行 存在 null 引用，判断是 timelineasset 为 null</p>
</li>
</ol>
<p><img src="unity/image/timeline/1721814195696.png" alt="1721814195696" /></p>
<ol start="3">
<li>
<p>从截图看出是某个 <strong>Track</strong> 的 <strong>TimelineAsset</strong> 为空， TimelineAseet 是创建的timeline资源</p>
</li>
<li>
<p>现在就是要找到是哪个轨道的 TimelineAsset 为 null,编写测试代码</p>
</li>
</ol>
<p><img src="unity/image/timeline/1721814204519.png" alt="1721814204519" /></p>
<p>第一行是打印测试的名字，第二行如果为空会报错</p>
<ol start="5">
<li>打包运行后日志如下，是一个  <strong>Teach_模式选择开关高亮</strong> 的轨道 为 null,且两个不能播放Timeline的都是因为这个同名的轨道</li>
</ol>
<p><img src="unity/image/timeline/1721814235064.png" alt="1721814235064" /></p>
<ol start="6">
<li>查看轨道，该轨道是内置的 PlayableTrack, 自己扩展编写的 Asset 和 behaviour</li>
</ol>
<p>轨道</p>
<p><img src="unity/image/timeline/1721814216815.png" alt="1721814216815" /></p>
<p>属性</p>
<p><img src="unity/image/timeline/1721814247671.png" alt="1721814247671" /></p>
<ol start="7">
<li>检查是否是因为这个轨道有问题引起的，发现其他使用了此轨道的Timelien正常，排除这个原因</li>
<li>修改轨道名称，将中文改为英文，看看是不是因为轨道名称引起的， <strong>发现正常了</strong></li>
<li>修改轨道名称，将中文改为英文，播放针头托离起点，发布后运行， <strong>还是报错</strong></li>
<li>新建（ <strong>不要复制</strong> ）相同功能的轨道，并新建（ <strong>不要复制</strong> ）对应片段，删除原有轨道，针头拖离起点， <strong>发布运行正常</strong></li>
<li>总结： 有可能是这个轨道创建的时候，脚本未编写完成，导致这个轨道异常</li>
</ol>
<h4 id="第3次处理"><a class="header" href="#第3次处理">第3次处理</a></h4>
<p><strong>使用第二次的方式还是为解决，通过调试代码找不到错误轨道</strong></p>
<p>通过构建时，勾选 “development build” 得知是在 track.TimelineAsset 获取为空时，出现问题</p>
<ul>
<li>
<p>当前Timeline上应该有GroupTrack，将组内的轨道拖动到组外，有可能的异常，如果拖到的是异常的轨道，会连带其他正常的轨道一起到组外，需要逐个的尝试</p>
</li>
<li>
<p>逐个的删除轨道，一般也是组内的轨道，若异常会出现图情况</p>
</li>
</ul>
<p><img src="unity/image/timeline/1721814267535.png" alt="1721814267535" /></p>
<p>错误信息如下</p>
<pre><code>MissingReferenceException: The object of type 'AnimationTrack' has been destroyed but you are still trying to access it.
Your script should either check if it is null or you should not destroy the object.
UnityEngine.Object.get_name () (at &lt;c7a29af87eea4c208ef711c9671e7831&gt;:0)
UnityEditor.Timeline.TimelineTrackErrorGUI.DrawMissingTrackHeader (UnityEngine.Rect headerRect, UnityEditor.Timeline.WindowState state) (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/treeview/TrackGui/TimelineTrackErrorGUI.cs:76)
UnityEditor.Timeline.TimelineTrackErrorGUI.Draw (UnityEngine.Rect headerRect, UnityEngine.Rect contentRect, UnityEditor.Timeline.WindowState state) (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/treeview/TrackGui/TimelineTrackErrorGUI.cs:46)
UnityEditor.Timeline.TimelineTreeView.OnRowGUI (UnityEngine.Rect rowRect, UnityEditor.IMGUI.Controls.TreeViewItem item, System.Int32 row, System.Boolean selected, System.Boolean focused) (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/treeview/TimelineTreeView.cs:185)
UnityEditor.IMGUI.Controls.TreeViewController.DoItemGUI (UnityEditor.IMGUI.Controls.TreeViewItem item, System.Int32 row, System.Single rowWidth, System.Boolean hasFocus) (at &lt;43587c69e7d54192b46754a593b0061f&gt;:0)
UnityEditor.IMGUI.Controls.TreeViewController.IterateVisibleItems (System.Int32 firstRow, System.Int32 numVisibleRows, System.Single rowWidth, System.Boolean hasFocus) (at &lt;43587c69e7d54192b46754a593b0061f&gt;:0)
UnityEditor.IMGUI.Controls.TreeViewController.OnGUI (UnityEngine.Rect rect, System.Int32 keyboardControlID) (at &lt;43587c69e7d54192b46754a593b0061f&gt;:0)
UnityEditor.Timeline.TimelineTreeViewGUI.OnGUI (UnityEngine.Rect rect) (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/treeview/TimelineTreeViewGUI.cs:152)
UnityEditor.Timeline.TimelineWindow.DrawTracksGUI (UnityEngine.Rect clientRect, UnityEditor.Timeline.TimelineModeGUIState trackState) (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/Window/TimelineWindow_TrackGui.cs:183)
UnityEditor.Timeline.TimelineWindow.TracksGUI (UnityEngine.Rect clientRect, UnityEditor.Timeline.WindowState state, UnityEditor.Timeline.TimelineModeGUIState trackState) (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/Window/TimelineWindow_TrackGui.cs:47)
UnityEditor.Timeline.TimelineWindow.TrackViewsGUI () (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/Window/TimelineWindow_Gui.cs:178)
UnityEditor.Timeline.TimelineWindow.SequencerGUI () (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/Window/TimelineWindow_Gui.cs:270)
UnityEditor.Timeline.TimelineWindow.DoLayout () (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/Window/TimelineWindow_Gui.cs:153)
UnityEditor.Timeline.TimelineWindow.OnGUI () (at Library/PackageCache/com.unity.timeline@1.4.8/Editor/Window/TimelineWindow.cs:227)
UnityEditor.HostView.InvokeOnGUI (UnityEngine.Rect onGUIPosition, UnityEngine.Rect viewRect) (at &lt;43587c69e7d54192b46754a593b0061f&gt;:0)
UnityEditor.DockArea.DrawView (UnityEngine.Rect viewRect, UnityEngine.Rect dockAreaRect) (at &lt;43587c69e7d54192b46754a593b0061f&gt;:0)
UnityEditor.DockArea.OldOnGUI () (at &lt;43587c69e7d54192b46754a593b0061f&gt;:0)
UnityEngine.UIElements.IMGUIContainer.DoOnGUI (UnityEngine.Event evt, UnityEngine.Matrix4x4 parentTransform, UnityEngine.Rect clippingRect, System.Boolean isComputingLayout, UnityEngine.Rect layoutSize, System.Action onGUIHandler, System.Boolean canAffectFocus) (at &lt;033e99bd4b59428a814373dfbafe317f&gt;:0)
UnityEngine.GUIUtility:ProcessEvent(Int32, IntPtr, Boolean&amp;)

GUI Error: You are pushing more GUIClips than you are popping. Make sure they are balanced.
UnityEngine.GUIUtility:ProcessEvent (int,intptr,bool&amp;)

</code></pre>
<ul>
<li>Ctr+Z 后如下图所示</li>
</ul>
<p><img src="unity/image/timeline/1721814291143.png" alt="1721814291143" /></p>
<ul>
<li>总结办法：1. 随意的将轨道在组外和组内拖动，查看是否正常;2. 逐个删除轨道，查看是否异常， 将出现的异常的组轨道以及异常轨道删除重新制作</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="steam-vr"><a class="header" href="#steam-vr">Steam VR</a></h1>
<h2 id="1-安装"><a class="header" href="#1-安装">1 安装</a></h2>
<p><a href="https://partner.steamgames.com/doc/features/steamvr/enterprise">Steamworks 文献库</a></p>
<h2 id="2-按键绑定"><a class="header" href="#2-按键绑定">2 按键绑定</a></h2>
<p>将自己的配置设置为默认配置。</p>
<ol>
<li>
<p>Unity中 Window-&gt;SteamVR Input,打开设置面板</p>
</li>
<li>
<p>点击 open binding ui</p>
</li>
</ol>
<p><img src="unity/vr/image/SteamVR/1718164102854.png" alt="1718164102854" /></p>
<ol start="3">
<li>如果显示 “这些是此游戏开发这发布的官方案件设置”，那么说明使用的不是你的配置</li>
</ol>
<p><img src="unity/vr/image/SteamVR/1718164117949.png" alt="1718164117949" /></p>
<ol start="4">
<li>点击 编辑，弹出面板后，点击 替换为默认配置</li>
</ol>
<p><img src="unity/vr/image/SteamVR/1718164149485.png" alt="1718164149485" /></p>
<ol start="5">
<li>填写你的信息，点击保存</li>
</ol>
<p><img src="unity/vr/image/SteamVR/1718164159028.png" alt="1718164159028" /></p>
<ol start="6">
<li>最后显示为你的配置，此时发布可以了</li>
</ol>
<p><img src="unity/vr/image/SteamVR/1718164172236.png" alt="1718164172236" /></p>
<h2 id="3-组件说明"><a class="header" href="#3-组件说明">3 组件说明</a></h2>
<p>无论是与模型还是UI的交互，无论是直接使用手柄还是射线的交互方式，交互对象(如果对象本身没有，那么子级上要有)需要有Collider，一般为BoxCollider，交互分手势交互和射线（手柄发送射线）交互两种情况，一般情况下，我们都用射线来交互，如和UI交互，大部分模型（如，仿真检查设备操作），手势操作的包含如：拉动滑块，转动轮盘等情况。</p>
<p>手势交互</p>
<h3 id="31-interactable"><a class="header" href="#31-interactable">3.1 Interactable</a></h3>
<p><img src="unity/vr/image/SteamVR/1718164181331.png" alt="1718164181331" /></p>
<ul>
<li>
<p>标识对象是可交互的</p>
</li>
<li>
<p>当手柄触碰到对象时，显示轮廓高亮</p>
</li>
<li>
<p>不能实现抓取和投掷等功能</p>
</li>
<li>
<p><strong>通过继承该组件重写OnPointerClick函数来写自己的业务逻辑，或者直接注册 PointerClick 事件来写自己的业务逻辑</strong></p>
</li>
</ul>
<h3 id="32-throwable"><a class="header" href="#32-throwable">3.2 Throwable</a></h3>
<p><strong>投掷功能组件</strong>：添加这个组件时，会自动添加依赖组件Interactable(可交互的) 和 Rigibody（释放时，物理重力）</p>
<h3 id="33-steamvr_laserpointer"><a class="header" href="#33-steamvr_laserpointer">3.3 SteamvR_LaserPointer</a></h3>
<p>官方提供的，在CameraRig预制体上的一个组件，用于实现激光交互，我们可以迁移到Player上</p>
<p><img src="unity/vr/image/SteamVR/1718164209485.png" alt="1718164209485" /></p>
<p><strong>用于射线交互</strong></p>
<ul>
<li>
<p>Pose 保持默认，会自动关联</p>
</li>
<li>
<p>InteractWithUI: 默认</p>
</li>
<li>
<p>Active: 设置无效（源代码未使用）</p>
</li>
<li>
<p>Color: 射线默认颜色，这里设置为白色，透明度注意设置为255</p>
</li>
<li>
<p>Thickness: 射线宽度，默认</p>
</li>
<li>
<p>Click Color: 点击颜色</p>
</li>
<li>
<p>Holder: Pointer的父级， 设置无效，源代码中会自动创建</p>
</li>
<li>
<p>Pointer: 设置无效，源代码中会自动创建一个Cube</p>
</li>
<li>
<p>AddRigidBody: 射线上添加刚体属性，默认</p>
</li>
<li>
<p>Reference: 设置无效，源代码中未使用</p>
</li>
</ul>
<h3 id="34-steamvr_loadlevel"><a class="header" href="#34-steamvr_loadlevel">3.4 SteamVR_LoadLevel</a></h3>
<p><strong>属性面板</strong></p>
<p><img src="unity/vr/image/SteamVR/1718163516491.png" alt="SteamVR_LoadLevel属性面板" /></p>
<p>所有用到的贴图，检查是否被压缩，全部改为不压缩</p>
<ul>
<li>
<p>LevelName:场景名称</p>
</li>
<li>
<p>InternalProcessPath:加载时要启动的进程（不用写）</p>
</li>
<li>
<p>InternalProcessArgs:进程参数</p>
</li>
<li>
<p>Load Addtive:场景是否是添加模式，不勾选就是从当前场景切换到目标场景</p>
</li>
<li>
<p>LoadAsync: 是否为异步加载，一般勾选</p>
</li>
<li>
<p>LoadingScreen: 加载背景</p>
</li>
<li>
<p>ProgressBarEmpty:加载进度条的背景</p>
</li>
<li>
<p>ProgressBarFull:加载进度条的进度</p>
</li>
<li>
<p>LoadingScreenWidthInMeters:加载背景的宽度（单位m）</p>
</li>
<li>
<p>ProgressBarWidthInmeters:加载进度条的宽度(单位m)</p>
</li>
<li>
<p>LoadingScreenDistance: 加载背景的距离，0代表无限远的地方，这里可以不设置，而采用下面两个来设置</p>
</li>
<li>
<p>LoadingScreenTransform：在场景中创建一个空对象，位置代表背景的位置</p>
</li>
<li>
<p>ProgressBarTransform:在常见中创建一个空对象，摆放和背景一个相对的位置，方便调整进度条在背景的某个位置，避免遮挡背景上的文字</p>
</li>
<li>
<p>Front:这6张图，代表天空盒的6个面</p>
</li>
<li>
<p>Back:</p>
</li>
<li>
<p>Right:</p>
</li>
<li>
<p>Top:</p>
</li>
<li>
<p>Bottom:</p>
</li>
<li>
<p>BackgroundColor:背景颜色</p>
</li>
<li>
<p>ShowGrid:是否显示网格</p>
</li>
<li>
<p>Fade Out Time:淡出时间</p>
</li>
<li>
<p>Fade In Time:淡进时间</p>
</li>
<li>
<p>Post Load Settle Time: 场景载入后，还需要等待的时间，为了能够很好的观看加载界面</p>
</li>
<li>
<p>Loading Screen Fade In Time: 加载背景淡入的时间 保持默认</p>
</li>
<li>
<p>Loading Screen Fade Out Time: 加载背景淡出的时间 保持默认</p>
</li>
<li>
<p>Auto Trigger On Enable: 脚本激活就触发加载</p>
</li>
</ul>
<p><strong>注意事项</strong></p>
<p><strong>（1）组件一直处于Loadind状态，导致无法加载</strong></p>
<p>启动launch场景，自动加载 Hall 场景，这个时候如果在加载其他场景时，无效，代码查看是因为 static laoding 一直为 true</p>
<p><strong>解决方案</strong></p>
<p>加载Hall直接使用SceneManager.LoadScene("Hall",Mode.Addtive)来加载</p>
<p>另外使用组件时，使用的是异步加载，不知道换同步是否存在问题</p>
<h3 id="35-teleport"><a class="header" href="#35-teleport">3.5 Teleport</a></h3>
<h4 id="351-配置规则"><a class="header" href="#351-配置规则">3.5.1 配置规则</a></h4>
<p>传送涉及到两个预制体和一个组件</p>
<ul>
<li>
<p><strong>Teleporting(预制体)</strong> ：必要的预制体，拖到场景，没有不行，提供传送的机制逻辑等</p>
</li>
<li>
<p><strong>TeleportPoint(预制体)</strong> ：传送点，定位传送</p>
</li>
<li>
<p><strong>TeleportArea(组件)</strong> ：传送区域，区域传送</p>
</li>
</ul>
<pre><code class="language-diff">- 注意：TeleportPoint 预制体的碰撞体默认是属于UI Layer，所以 Teleporting 检测的层级一定要包含 UI 层，或者你自定义
</code></pre>
<h4 id="352-teleporting"><a class="header" href="#352-teleporting">3.5.2 Teleporting</a></h4>
<p><img src="unity/vr/image/SteamVR/1718163458139.png" alt="1718163458139" /></p>
<p>主要关注图上属性配置，其他的是特效，声音以及调试的配置</p>
<ul>
<li>
<p><strong>TeleportAction</strong> : 动作配置</p>
</li>
<li>
<p><strong>TraceLayerMask</strong> : 检测的图层，如：手柄发送射线传送时，射线被某个物体遮挡，此时，可以将这个物体设置一个独立的图层，然后，这里不勾选这个图层，射线就会穿过这个物体</p>
</li>
<li>
<p><strong>FloorFixupTraceLayerMask</strong> : 将哪些图层识别为地面，和下面的Distace属性共同使用</p>
</li>
<li>
<p><strong>FloorFixupMaximunTraceDistance</strong> ：一个容差，用于角色在传送后，角色始终在地面上而不是在传送区域所在的平面上，举例：传送区域高于地面0.5,若 <strong>FloorFixupTraceLayerMask</strong> 设置的是nothing,那么传送后，角色就会高于地面0.5 ；若 <strong>FloorFixupTraceLayerMask</strong>设置了地面图层，那么会根据这里的distace，假设为1，会在1这个范围内查找地面，如果找到，就设置角色到地面上，这里1&gt;0.5所以，会找到地面图层，会将角色传送到地面上</p>
</li>
</ul>
<p><strong>URP材质替换</strong></p>
<p>在URP渲染模式下：<code>DestinationReticle</code> 对象的材质，默认是 <code>TeleportPointHighlighted</code>,在编辑模式下还正常，但是发布后会出现无线显示传送位置标记的问题，需要替换为URP的材质，如下图：</p>
<p><img src="unity/vr/image/SteamVR/1718164319587.png" alt="1718164319587" /></p>
<h4 id="353-teleportpoint"><a class="header" href="#353-teleportpoint">3.5.3 TeleportPoint</a></h4>
<p><img src="unity/vr/image/SteamVR/1718164329451.png" alt="1718164329451" /></p>
<ul>
<li>
<p><strong>Lockked</strong> ：勾选，将无法传送到此区域，可通过代码来控制此变量，动态解锁传送区域</p>
</li>
<li>
<p><strong>MarkerActive</strong> ：勾选，运行时，传送区域不会显示，当按下传送健的时候才显示出来，否则，一开时就显示</p>
</li>
<li>
<p><strong>TeleportType</strong> ：传送到本地或者是切换场景</p>
</li>
<li>
<p><strong>Title</strong> ：传送的名称，在游戏当中显示</p>
</li>
<li>
<p><strong>SwitchToScene</strong> ：场景名称，需要“TeleportType” 为 “SwitchToNewScene”</p>
</li>
<li>
<p><strong>PlayerSpawnPoint</strong> ：角色初始点，勾选，角色最开始会出现在这个位置</p>
</li>
</ul>
<h2 id="4-player"><a class="header" href="#4-player">4 Player</a></h2>
<p>角色组件</p>
<ul>
<li>
<p>这是一个单例，场景中仅能存在一个，因此该对象在场景切换时不会不销毁，会一直存在</p>
</li>
<li>
<p>使用技巧：现在一个空场景放置一个Player,启动空场景后立刻加载场景，这样切换场景时，Player一直存在</p>
</li>
<li>
<p>或者若你的初始场景是一直存在，加载场景是以“Addtive”的方式，那么可将Player放置在初始场景</p>
</li>
</ul>
<h2 id="5-组件扩展"><a class="header" href="#5-组件扩展">5 组件扩展</a></h2>
<h3 id="51-激光交互响应组件laserhand"><a class="header" href="#51-激光交互响应组件laserhand">5.1 激光交互响应组件（LaserHand）</a></h3>
<p>该组件依赖 <code>SteamVR_LaserPointer</code>,并监听其的 <code>PointerIn</code>、<code>PointerOut</code>、<code>PointerClick</code> 三个事件，以实现对对象的指针移入、移出和点击三种交互事件的处理</p>
<p><strong>代码</strong></p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEngine.EventSystems;
using Valve.VR.Extras;

namespace LFramework
{
    /// &lt;summary&gt;
    /// 激光射线交互，挂手柄上
    /// &lt;/summary&gt;
    [RequireComponent(typeof(SteamVR_LaserPointer))]
    public class LaserHand : MonoBehaviour
    {
        // LaserPointer组件
        private SteamVR_LaserPointer _laser;
        // 是否开启激光指针交互
        public bool isEnabled = true;

        private void Awake()
        {
            // 获取到LaserPointer组件
            _laser = GetComponent&lt;SteamVR_LaserPointer&gt;();
            // 如果不为空
            if (_laser != null)
            {
                // 如果不开启激光指针交互
                if (!isEnabled)
                {
                    // 激光指针不显示
                    _laser.enabled = false;
                    return;
                }
                else // 如果开启激光指针交互
                {
                    _laser.PointerIn += LaserOnPointerIn;
                    _laser.PointerOut += LaserOnPointerOut;
                    _laser.PointerClick += LaserOnPointerClick;
                }
            }
        }

        private void LaserOnPointerIn(object sender, PointerEventArgs e)
        {

            IPointerEnterHandler _pointerEnterHandler = e.target.gameObject.GetComponent&lt;IPointerEnterHandler&gt;();
            if (_pointerEnterHandler != null)
            {
                _laser.color.a = 1;// showColor;
                _pointerEnterHandler.OnPointerEnter(new PointerEventData(EventSystem.current));
            }
        }

        private void LaserOnPointerOut(object sender, PointerEventArgs e)
        {
            IPointerExitHandler _pointerExitHandler = e.target.gameObject.GetComponent&lt;IPointerExitHandler&gt;();
            if (_pointerExitHandler != null)
            {
                _laser.color.a = 0;
                _pointerExitHandler.OnPointerExit(new PointerEventData(EventSystem.current));
            }
        }

        private void LaserOnPointerClick(object sender, PointerEventArgs e)
        {
            IPointerClickHandler _pointerClickHandler = e.target.gameObject.GetComponent&lt;IPointerClickHandler&gt;();
            if (_pointerClickHandler != null)
            {
                Debug.Log("点击了..." + e.target.gameObject.name);
                _pointerClickHandler.OnPointerClick(new PointerEventData(EventSystem.current));
            }
        }

        private void OnDestroy()
        {
            if (_laser != null &amp;&amp; isEnabled)
            {
                _laser.PointerIn -= LaserOnPointerIn;
                _laser.PointerOut -= LaserOnPointerOut;
                _laser.PointerClick -= LaserOnPointerClick;
            }
        }
    }
}

</code></pre>
<p><strong>对UI的交互</strong></p>
<ul>
<li>
<p>和普通开发模式一样，是对Button组件的交互</p>
</li>
<li>
<p>Button按钮上添加BoxCollider组件，用于射线检测</p>
</li>
<li>
<p>注意交互对象所在的Layer(层级),是否在射线检测的层级设置里面</p>
</li>
</ul>
<p><strong>对模型的交互</strong></p>
<ul>
<li>
<p>模型对象上添加BoxCollider组件，用于射线检测</p>
</li>
<li>
<p>注意交互对象所在的Layer(层级),是否在射线检测的层级设置里面</p>
</li>
<li>
<p>在模型上挂载一个组件，该组件根据需求实现：<code>IPointerEnterHandler IPointerExitHandler IPointerClickHandler</code> 三个接口</p>
</li>
</ul>
<p>代码忽略。</p>
<h2 id="6-ui"><a class="header" href="#6-ui">6 UI</a></h2>
<h3 id="61-设置"><a class="header" href="#61-设置">6.1 设置</a></h3>
<ol>
<li>
<p>将Canvas 设置为 World Space 模式</p>
</li>
<li>
<p>Scale 均设置为 0.001,长宽都设置为1（这个没什么影响）</p>
</li>
<li>
<p>其他和普通的UI设置一样</p>
</li>
</ol>
<h3 id="62-ui被模型遮挡"><a class="header" href="#62-ui被模型遮挡">6.2 UI被模型遮挡</a></h3>
<ol>
<li>
<p>使用网上的 uioverlay shader制作材质，赋给 image text rawimage 等</p>
</li>
<li>
<p>对于 TextmeshProUGUI, 它有自己的 overlay shader，我们主要将我们制作的字体材质复制一份，作为ovlerlay材质，将shader换为 Distance filed Overlay shader</p>
</li>
<li>
<p>问题：玩家的手部模型，和射线也会被 设置了Overlay的UI覆盖，导致 无法操作 这种UI，目前还没解决，网上的人很狗屎，没人提这个问题</p>
</li>
</ol>
<h2 id="7-问题汇总"><a class="header" href="#7-问题汇总">7 问题汇总</a></h2>
<h3 id="世界坐标中的canvas在相机距离改变后被遮挡"><a class="header" href="#世界坐标中的canvas在相机距离改变后被遮挡">世界坐标中的Canvas在相机距离改变后被遮挡</a></h3>
<p>图中的箭头是个UI，当相机离它近时，它正常显示在黄色标签的前面，如下图</p>
<p><img src="unity/vr/image/SteamVR/1721199092376.png" alt="1721199092376" /></p>
<p>当相机拉远点时，箭头被标签挡住了</p>
<p><img src="unity/vr/image/SteamVR/1721199097929.png" alt="1721199097929" /></p>
<p>解决办法：将Cavans的Order in Layer 设置为1，要大于0</p>
<p><img src="unity/vr/image/SteamVR/1721199106664.png" alt="1721199106664" /></p>
<h3 id="htc-vive-定位器更新固件后闪烁红灯"><a class="header" href="#htc-vive-定位器更新固件后闪烁红灯">HTC VIVE 定位器更新固件后闪烁红灯</a></h3>
<p><strong>官方回复（失败）</strong></p>
<p>首先联系官方，根据回复指导操作后，未解决问题，以下是官方的回复：</p>
<pre><code>以下是1.0 定位器重置固件的详细操作步骤。

1. 从电源插座上拔下电源适配器。

2. 从基站背面拔下电源适配器。

3. 使用官方自带 USB 线缆（手柄充电线）将基站与计算机连接。

4. 按住“频道键”不放。

5. 将电源适配器连接到基站背面，然后将另一端插入电源插座。

6. 在计算机上，您将看到一个新设备显示为CRP DISABLD.

7. 打开它并删除文件 firmware.bin.

8. 在计算机上，转到SteamVR的安装文件夹。

9. 找到到固件版本为436的文件夹。文件夹路径如下： VIVE\Steam\steamapps\common\SteamVR\tools\lighthouse\firmware\lighthou setx\archive\htc2.0

10. 复制 lighthousetxhtc_2.0-436-2016-09-20.bin 到 CRP DISABLD 中。

11. 等候约 1分钟，然后拔下USB线缆。
</code></pre>
<p><strong>网友方法(成功)</strong></p>
<p>注意：若修复成功，定位器会显示一个感叹号，提示更新，千万不要更新，就是因为更新出现的问题，我们的操作就是回退固件。
{.is-warning}</p>
<p>在SteamVR安装目录下找到以下两个文件，安装目录：D:\Program Files (x86)\Steam\steamapps\common\SteamVR\tools\lighthouse\firmware\lighthouse_tx\archive\htc_2.0</p>
<p>lighthouse_tx_htc_2_0-calibration-rescue-244.bin
lighthouse_tx_htc_2_0-244-2016-03-12.bin</p>
<p>附件根据自己的具体路径查找</p>
<ol>
<li>
<p>将好的定位器先断电</p>
</li>
<li>
<p>在基站未通电情况下，将其通过micro-B USB（手柄充电线）传输线连接到PC。</p>
</li>
<li>
<p>按住基站背后的模式键并插入电源线.</p>
</li>
<li>
<p>一旦PC端确认为USB大容量存储设备(USB mass storage device)，才可以释放模式键。</p>
</li>
<li>
<p>被连接的基站储存设备名为“CRP_DISABLED”，打开后包含一个文件“firmware.bin”，删除它。</p>
</li>
<li>
<p>将“lighthouse_tx_htc_2_0-calibration-rescue-244.bin”文件复制到基站的储存空间上。</p>
</li>
<li>
<p>复制完成后，拔掉电源线。</p>
</li>
<li>
<p>等几秒，然后再次插上电源。在此过程中不要按模式键。几秒后基站应该会快速的闪烁绿灯或者红灯。绿灯表示修复成功。</p>
</li>
<li>
<p>如果它闪烁红灯，这表示不能自动修复，请您送修。</p>
</li>
<li>
<p>再此拔下电源。</p>
</li>
<li>
<p>重复步骤1到7，但第5步复制文件改为“lighthouse_tx_htc_2_0-244-2016-03-12.bin"。</p>
</li>
<li>
<p>完整后基站就恢复正常了，讲其频道设置为“A”并单独跟踪（另一个基站不通电）来确认运行情况。一旦确认工作正常，再打开另一个基站。</p>
</li>
</ol>
<p>其他：</p>
<ul>
<li>
<p>若单独使用一个定位器：设置为A模式</p>
</li>
<li>
<p>若使用两个定位器（有线连接）：AB模式</p>
</li>
<li>
<p>若使用两个定位器（无线连接）：BC模式</p>
</li>
</ul>
<h3 id="urp渲染模式发布后无法显示传送位置"><a class="header" href="#urp渲染模式发布后无法显示传送位置">URP渲染模式发布后无法显示传送位置</a></h3>
<p>需要手动替换下 DestinationReticle 的 材质，具体见 Teleporting章节</p>
<h3 id="发布后手柄无响应"><a class="header" href="#发布后手柄无响应">发布后手柄无响应</a></h3>
<ol>
<li>
<p>发布位置不能有中文</p>
</li>
<li>
<p>按键配置需要替换为默认的配置，操作见 相应章节</p>
</li>
</ol>
<h3 id="左右眼渲染不同视野模糊"><a class="header" href="#左右眼渲染不同视野模糊">左右眼渲染不同，视野模糊</a></h3>
<p>通过 Edit-&gt;ProjectSettings-&gt;XR Plug-in Managerment 下的 openvr设置为多通道</p>
<p>通过设置这个解决问题，但是，项目报错  “IsMatrixValid（matrix）”</p>
<p>以下是一个解决方案，待测试</p>
<p><a href="https://forum.unity.com/threads/ismatrixvalid-matrix-error-spam-when-splitting-up-steamvr-eyes.425474/">https://forum.unity.com/threads/ismatrixvalid-matrix-error-spam-when-splitting-up-steamvr-eyes.425474/</a></p>
<p>新建一个脚本，挂在初始场景上</p>
<pre><code class="language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR;
using UnityEngine.XR.Management;
using Valve.VR;
namespace LFramework
{
    public class XRFix : MonoBehaviour
    {
        List&lt;XRDisplaySubsystem&gt; displays = new List&lt;XRDisplaySubsystem&gt;();
        private void Awake()
        {
            //StartXR();
            //SteamVR.Initialize();
        }
        public void StartXR()
        {
            XRGeneralSettings.Instance.Manager.InitializeLoaderSync();
            XRGeneralSettings.Instance.Manager.StartSubsystems();
        }
        private void Update()
        {
            EnforceStereoTexture();
        }
        void EnforceStereoTexture()
        {
            displays.Clear();

            SubsystemManager.GetInstances(displays);
            foreach (var displaySubsystem in displays)
            {
                if (displaySubsystem.running)
                {
                    displaySubsystem.textureLayout = XRDisplaySubsystem.TextureLayout.SeparateTexture2Ds;
                }
            }
        }
    }
}
</code></pre>
<h3 id="非多样采集的贴图绑定到多样采集器上的错误"><a class="header" href="#非多样采集的贴图绑定到多样采集器上的错误">非多样采集的贴图绑定到多样采集器上的错误</a></h3>
<p>版本：untiy 2020.3.40</p>
<p>VR开发</p>
<p>❌错误提示：<code>A non-multisampled texture being bound to a multisampled sampler. Disabling in order to avoid undefined behavior. Please enable the bindMS flag on the texture.</code></p>
<p><strong>报错说明</strong>：将非多样采集的贴图绑定到多样采集器上，为了避免未知的结果应该禁用它，请激活贴图的bindMS</p>
<p><strong>报错的原因</strong>：</p>
<p>在进行VR开发时，场景结构是一个原始场景一直存在，通过Addtive的方式加载其他场景，但是第二次加载的时候就会报错，信息显示是SteamVR_loadlevel的脚本中调用了Shader.WarmupAllShaders();</p>
<p><img src="unity/vr/image/SteamVR/1721198690359.png" alt="1721198690359" /></p>
<p>查找资料： 1 设置抗锯齿（MSAA）导致的，网上说的是要关闭，但是我关闭后，第一次就报错</p>
<p><img src="unity/vr/image/SteamVR/1721198700183.png" alt="1721198700183" /></p>
<p>其他资料
https://docs.unity3d.com/Manual/shader-variant-collections.html</p>
<p>https://github.com/ValveSoftware/unity-xr-plugin/issues/88</p>
<p>https://forum.unity.com/threads/a-non-multisampled-texture-spams-the-console.1143884/</p>
<p>https://blog.csdn.net/u013716859/article/details/124644214</p>
<p>3.目前先注释调这个代码看看</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资源优化"><a class="header" href="#资源优化">资源优化</a></h1>
<h2 id="editorsetting"><a class="header" href="#editorsetting">EditorSetting</a></h2>
<h3 id="layercollisionmatrix"><a class="header" href="#layercollisionmatrix">LayerCollisionMatrix</a></h3>
<p>层级碰撞矩阵，没必要每层都去检测碰撞</p>
<h4 id="检查physics设置中的layercollisionmatrix设置"><a class="header" href="#检查physics设置中的layercollisionmatrix设置">检查Physics设置中的LayerCollisionMatrix设置</a></h4>
<ul>
<li>
<p>这会增加CPU的负担, 应该取消勾选那些没有必要的格子</p>
</li>
<li>
<p>检查Editor -&gt; Project Settings -&gt; Physics -&gt; Layer Collision Matrix的设置</p>
</li>
<li>
<p>在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上</p>
</li>
</ul>
<h4 id="检查physics2d中layercollisionmatrix设置"><a class="header" href="#检查physics2d中layercollisionmatrix设置">检查Physics2D中LayerCollisionMatrix设置</a></h4>
<ul>
<li>
<p>这会增加CPU的负担, 应该取消勾选那些没有必要的格子</p>
</li>
<li>
<p>检查Editor -&gt; Project Settings -&gt; Physics2D -&gt; Layer Collision Matrix的设置</p>
</li>
<li>
<p>在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上</p>
</li>
</ul>
<h2 id="fbx"><a class="header" href="#fbx">FBX</a></h2>
<p><strong>检查读/写标志</strong></p>
<p>开启FBX资源的读/写标志会导致双倍的内存占用，一般禁用掉写</p>
<p><strong>检查动画资源压缩方式</strong></p>
<p>动画资源使用最佳压缩方式可以提高加载效率，查看Inspector -&gt; Animation Tab -&gt; Anim. Compression选项</p>
<p><strong>检查动画资源的OptimizeGameObjects选项</strong></p>
<p>动画资源应该勾选OptimizeGameObjects选项来减少CPU消耗，查看Inspector -&gt; Rig Tab -&gt; Optimize Game Objects选项</p>
<p><strong>检查FBX资源顶点数</strong></p>
<p>FBX资源资源中有太多的顶点, 请检查是否必要，500以下，Custom Parameters: vertexCountLimit : 500</p>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<p><strong>检查动画曲线精度</strong></p>
<p>动画曲线精度过高会增加动画占用内存; 此规则仅面向以文本格式序列化的*.anim文件中的浮点精度
Custom Parameters: precision : 5
用文本编辑器打开.anim动画文件，修改m_EditorCurves::curve::m_Curve下的float值的精度。建议用脚本直接将此文件中所有float精度都调小。</p>
<p>自己编写的优化工具：<a href="https://gitee.com/AByte-L/float-optimize">工具</a></p>
<h2 id="prefab"><a class="header" href="#prefab">Prefab</a></h2>
<h3 id="检查skinned-mesh-renderer"><a class="header" href="#检查skinned-mesh-renderer">检查Skinned Mesh Renderer</a></h3>
<p>启用Skinned Motion Vectors会使渲染器同时使用当前帧和上一帧的蒙皮网络来渲染目标的动画以提高精度，从而需要双倍大小的缓冲区并占用双倍的显存</p>
<h2 id="scene"><a class="header" href="#scene">Scene</a></h2>
<h3 id="检查场景中的audio-listener"><a class="header" href="#检查场景中的audio-listener">检查场景中的Audio Listener</a></h3>
<p>一个场景不应包含多个Audio Listener
检查场景中所有GameObject下的Audio Listener组件</p>
<h3 id="检查场景中mesh-collider"><a class="header" href="#检查场景中mesh-collider">检查场景中mesh collider</a></h3>
<p>Mesh Collider可以在场景中提供更精细化的碰撞检测，随之而来也会消耗大量计算资源，建议审慎使用。
检查场景中所有GameObject下的Mesh Collider组件</p>
<h3 id="检查场景渲染设置"><a class="header" href="#检查场景渲染设置">检查场景渲染设置</a></h3>
<p>在移动平台，建议在渲染设置中关闭对雾的渲染以节省计算资源。
检查Window -&gt; Rendering -&gt; Lighting Settings -&gt; Scene -&gt; Other Settings -&gt; Fog选项</p>
<h3 id="检查canvas中的component数量"><a class="header" href="#检查canvas中的component数量">检查Canvas中的component数量</a></h3>
<p>包含太多组件的Canvas可能会影响UI刷新的性能，并进一步影响应用的帧率。</p>
<h3 id="检查场景animator组件中的cullingmode"><a class="header" href="#检查场景animator组件中的cullingmode">检查场景Animator组件中的cullingMode</a></h3>
<p>场景中Animator组件的cullingMode是AlwaysAnimate会增加CPU使用率。</p>
<h2 id="shader"><a class="header" href="#shader">Shader</a></h2>
<h3 id="检查shader中纹理数量"><a class="header" href="#检查shader中纹理数量">检查Shader中纹理数量</a></h3>
<p>Shader中过多的纹理可能会增加GPU消耗
Custom Parameters: textureCountLimit : 3</p>
<h2 id="texture"><a class="header" href="#texture">Texture</a></h2>
<h3 id="检查纹理读写标记"><a class="header" href="#检查纹理读写标记">检查纹理读/写标记</a></h3>
<p>开启纹理资源的读/写标志会导致双倍的内存占用
检查Inspector -&gt; Advanced -&gt; Read/Write Enabled选项</p>
<h3 id="检查mipmap标记"><a class="header" href="#检查mipmap标记">检查Mipmap标记</a></h3>
<p>未压缩的纹理资源启用Mipmap标志会增加内存占用
检查Inspector -&gt; Advanced -&gt; Generate Mip Maps选项</p>
<ul>
<li>
<p>未压缩的纹理应该禁用mipmap</p>
</li>
<li>
<p>类型为Sprite的纹理应当禁用mipmap</p>
</li>
</ul>
<h3 id="android平台纹理压缩格式"><a class="header" href="#android平台纹理压缩格式">Android平台纹理压缩格式</a></h3>
<p>检查Android平台的纹理压缩格式</p>
<p>如果希望对各平台统一设置压缩格式，检查Inspector -&gt; Default -&gt; Format选项; 如果希望为Android平台单独设置，打开旁边的Android选项卡，勾选Override for Android并检查下面的Format选项</p>
<h3 id="纹理资源大小2的幂次"><a class="header" href="#纹理资源大小2的幂次">纹理资源大小2的幂次</a></h3>
<p>大小非2的幂次的纹理资源将无法使用ETC1和PVRTC压缩格式。在导入时自动伸缩为2的幂次也可能会导致内存占用或者贴图质量问题。</p>
<p>检查Inspector -&gt; Advanced -&gt; Non-Power of 2选项. 建议使用原始大小为2的幂次的贴图.</p>
<h3 id="检查纯色纹理"><a class="header" href="#检查纯色纹理">检查纯色纹理</a></h3>
<p>纯色纹理的使用可能可以由一些设置来代替。由于某些情况下纯色纹理是必不可少的，此警告仅会在所使用的纹理较大(大于设定值, 默认为16x16)时才会触发。</p>
<p>Custom Parameters: heightThreshold : 16widthThreshold : 16</p>
<h3 id="检查重复纹理"><a class="header" href="#检查重复纹理">检查重复纹理</a></h3>
<p>检查重复纹理</p>
<h3 id="检查精灵图纹理填充率"><a class="header" href="#检查精灵图纹理填充率">检查精灵图纹理填充率</a></h3>
<p>填充率是精灵图分割后的有效面积与总面积的比率，较低的精灵图纹理填充率会导致显存的浪费。</p>
<p>Custom Parameters: fillRateThreshold : 0.5onlyCheckSprite : True</p>
<p>尝试重新编排精灵图，尽量缩小总面积以提高填充率</p>
<h2 id="script"><a class="header" href="#script">Script</a></h2>
<h3 id="避免分配托管内存"><a class="header" href="#避免分配托管内存">避免分配托管内存</a></h3>
<p>以下方法会导致分配托管内存，给出了替代的方法</p>
<div class="table-wrapper"><table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody>
<tr><td>Component.GetComponentsInChildren()</td><td>替代：GetComponentsInChildren<T>(bool includeInactive, List<T> result)</td></tr>
<tr><td>AnimationCurve.keys</td><td>替代：AnimationCurve.AddKey()/MoveKey()/RemoveKey()</td></tr>
<tr><td>Resources.FindObjectsOfTypeAll()</td><td>Resources.FindObjectsOfTypeNonAlloc()</td></tr>
<tr><td>Object.FindObjectsOfType()</td><td>尽量避免在频繁更新的代码中调用此方法。理想情况下，该方法应该只在初始化期间使用，如果需要重用结果，则应该缓存结果。</td></tr>
<tr><td>Linq 会分配大量的托管内存</td><td>强烈建议不要在任何频繁更新的代码中使用Linq。完全禁止在项目中使用它，或者将它限制在初始化代码中，并少量使用它。</td></tr>
<tr><td>Component.GetComponentsInParent()</td><td>替代：GetComponentsInParent<T>(bool includeInactive, List<T> results)</td></tr>
<tr><td>Texture2D.GetPixels()</td><td>替代：Texture2D.GetRawTextureData()</td></tr>
</tbody></table>
</div>
<h3 id="减少cpu使用"><a class="header" href="#减少cpu使用">减少CPU使用</a></h3>
<p>以下方法会导致CPU性能的问题，给出了替代的方法</p>
<div class="table-wrapper"><table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody>
<tr><td>AddComponent<T>()</td><td>尽量避免在频繁更新的代码中获得此属性。更喜欢从预制件实例化游戏对象将所有必要的组件。</td></tr>
<tr><td>Instantiate()</td><td>操作昂贵，避免经常使用，内存池处理</td></tr>
<tr><td>反射</td><td>删除依赖于反射的代码，或尽量减少反射的使用，特别是在初始化之外。</td></tr>
<tr><td>空方法</td><td>任何空的MonoBehaviour魔法方法都将包含在构建中并执行，移除任何空的方法</td></tr>
</tbody></table>
</div>
<h3 id="检查空的monobehavior-update方法"><a class="header" href="#检查空的monobehavior-update方法">检查空的MonoBehavior Update方法</a></h3>
<p>MonoBehavior脚本不应具有空的Update方法</p>
<h3 id="检查ongui方法"><a class="header" href="#检查ongui方法">检查OnGUI方法</a></h3>
<p>由于内存使用率高，不应使用OnGUI方法</p>
<p>IMGUI是过时的UI系统，仅建议在开发调试时使用。</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 12px;
    text-align: left;
    vertical-align: top; 
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.excel-table tr:nth-child(even), table tr:nth-child(odd) {
    background-color: transparent; /* 确保所有行背景色一致 */
}

.excel-table tr:hover {
    background-color: inherit;
}

.excel-table tr:nth-child(even) {
    background-color: #f9f9f9;
}

.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    /* width: 30%; */
    width:100px;
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 50%;
}

.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width: 50%;
}
</style>
<h1 id="unity中的特殊文件夹"><a class="header" href="#unity中的特殊文件夹">Unity中的特殊文件夹</a></h1>
<h2 id="文件夹"><a class="header" href="#文件夹">文件夹</a></h2>
<h3 id="editor"><a class="header" href="#editor">Editor</a></h3>
<p><strong>Editor</strong>文件夹可以在<code>Assets</code>目录下，也可以在子目录里，只要名子叫<code>Editor</code>就可以。例如目录<code>Assets/Editor和Assets/Scripts/Editor</code>是一样的，无论多少个叫<code>Editor</code>的文件夹都可以
<code>Editor</code>文件夹下存放的所有资源文件或脚本文件都不会被打进包中，并且脚本也只能在编辑时使用。一般会把一些编辑器扩展的脚本放在这里，或者是一些编辑时用的DLL</p>
<h3 id="editor-default-resources"><a class="header" href="#editor-default-resources">Editor Default Resources</a></h3>
<p>必须放在Assets目录下，可以把编辑器扩展用到的一些资源放在这里，比如图片、文本文件、等等。它和Editor文件夹一样都不会被打到包中，仅仅用于开发时使用
通过 <strong>EditorGUIUtility.Load</strong> 可以读取到该文件夹下的资源</p>
<pre><code class="language-csharp">using UnityEngine;
using UnityEditor;

public class LoadExample
{
    [MenuItem("Examples/Load Editor Texture Example")]
    static void loadExample()
    {
        Texture tex  = (Texture)EditorGUIUtility.Load("aboutwindow.mainheader");
        Debug.Log("Got: " + tex.name + " !");

        Renderer r = GameObject.Find("Cube").GetComponent&lt;Renderer&gt;();
        r.sharedMaterial.mainTexture = tex;
    }
}
</code></pre>
<h3 id="gizmos"><a class="header" href="#gizmos">Gizmos</a></h3>
<p>必须放在<code>Assets</code>目录下，可以将绘制在场景中的<code>Gizmo</code>素材放在这个文件夹下，使用<code>Gizmos.DrawIcon</code>绘制的时候可以直接传入图片路径，打包时会打到包中</p>
<h3 id="plugins"><a class="header" href="#plugins">Plugins</a></h3>
<p>可以将sdk、dll库文件、插件等放在这里，打完包后就会自动将这些文件打到包中</p>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<blockquote>
<p>❗❗❗ <strong>项目开发时不要使用它</strong> ❗❗❗</p>
<p>它只是用来快速构建demo</p>
</blockquote>
<p><strong>Resources</strong>文件夹可以在<code>Assets</code>目录下，也可以在子目录里，只要名子叫<code>Resources</code>就可以，<code>Resources</code>文件夹下的所有资源不管你用还是不用都会被打进包中
可以使用<code>Resource.Load</code>读取此文件夹下的资源
因为<code>Resource</code>文件夹下的所有资源都会被打进包中，所以一般开发时使用<code>AssetDatabase.LoadAssetAtPath</code>，它可以读取<code>Assets</code>目录下的任意文件夹下的资源，只能在编辑器下使用，它的路径是<code>Assets/xx/xx.xxx</code>，需要注意路径带文件的后缀名</p>
<h3 id="streamingassets"><a class="header" href="#streamingassets">StreamingAssets</a></h3>
<p>这个文件夹下的资源也都会被打进包中，它和<code>Resources</code>的区别是<code>Resources</code>会压缩文件，但是<code>StreamingAssets</code>不会压缩而是原封不动的打包进去。并且它是一个只读的文件夹，就是程序运行时只能读不能写。它在各个平台下的路径是不同的
使用<code>Application.streamingAssetsPath</code>会根据当前的平台选择对应的路径</p>
<p>其他文件夹: 如果是没有用到的资源，就不会被打到包中，如果是用到了的资源就会被打到包中</p>
<h2 id="路径"><a class="header" href="#路径">路径</a></h2>
<h3 id="applicationdatapath"><a class="header" href="#applicationdatapath">Application.dataPath</a></h3>
<ul>
<li>这里是列表文本<code>Assets</code>文件夹路径，</li>
<li>只在编辑器模式下有效，打包后该路径不存在</li>
</ul>
<h3 id="applicationstreamingassetspath"><a class="header" href="#applicationstreamingassetspath">Application.streamingAssetsPath</a></h3>
<p>StreamingAssets文件夹路径，不同平台读取方式不同，详细见图：</p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>平台</th>
                <th>File读取</th>
                <th>UnityWebRequest读取</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>PC</td>
                <td>✔️ 无前缀</td>
                <td>✔️</td>
            </tr>
              <tr>
                <td>安卓</td>
                <td>❌</td>
                <td>✔️ 加前缀：<code>jar:file://</code></td>
            </tr>
             <tr>
                <td>IOS</td>
                <td>✔️ 无前缀</td>
                <td>✔️ 加前缀：<code>file://</code></td>
            </tr>
             <tr>
                <td>Mac</td>
                <td>✔️ 无前缀</td>
                <td>✔️ 加前缀：<code>file://</code></td>
            </tr>
        </tbody>
    </table>
</div>
<p>UnityWebRequest读取代码示例：</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 使用UnityWebRequest请求时的地址（根据各个平台处理）
/// 注：这个路径不能使用File来使用
/// &lt;/summary&gt;
/// &lt;param name="fileName"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static string GetRequestURL(string fileName)
{

    string path = Path.Combine(Application.streamingAssetsPath, fileName);

#if UNITY_ANDROID &amp;&amp; !UNITY_EDITOR
            path ="jar:file://" + ptah;
#elif UNITY_EIDITOR_OSX || UNITY_STANDALONE_OSX || UNITY_IPHONE //苹果下是这样
            path ="file://"+ ptah;

// #else // UNITY_EDITOR || UNITY_STANDALONE_WIN || UNITY_IPHONE 这些的路径一样
//             request = new UnityWebRequest(Application.streamingAssetsPath + "/" + fileName);
#endif
    return path;
}
</code></pre>
<h3 id="applicationpersistentdatapath"><a class="header" href="#applicationpersistentdatapath">Application.persistentDataPath</a></h3>
<p>这个文件夹在不同平台下的路径不同</p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>平台</th>
                <th>路径</th>
                <th>读写方式</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>PC</td>
                <td>与普通文件路径相同</td>
                <td>File直接读写</td>
            </tr>
              <tr>
                <td>安卓</td>
                <td>/data/data/xxx.xxx.xxx/files</td>
                <td>File直接读写（安卓端唯一可以用File读写的路径）<br>安卓手机连接电脑，可通过 <code>Android/data/com.xxx.xxx</code>查看</td>
            </tr>
             <tr>
                <td>IOS</td>
                <td>Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</td>
                <td>File直接读写</td>
            </tr>
        </tbody>
    </table>
</div>
<h4 id="读写案例"><a class="header" href="#读写案例">读写案例</a></h4>
<pre><code class="language-csharp">    public UnityEngine.UI.Text infoText;
    public void FileRead()
    {
        System.IO.DirectoryInfo di = new System.IO.DirectoryInfo(Application.persistentDataPath);
        infoText.text = "";
        foreach (FileInfo file in di.GetFiles())
        {
            //Debug.Log(file.Name);
            infoText.text += file.Name.ToString();
            StreamReader sr = file.OpenText();
            infoText.text += ":" + sr.ReadToEnd()+"\n";
            sr.Close();
        }
    }
    public void FileWrite()
    {
        string fileName = "Test.txt";
        string path = Path.Combine(Application.persistentDataPath, fileName);

        if (!File.Exists(path))
        {
            File.WriteAllText(path, "Persistent path test!");
            infoText.text = "添加了 Test.txt 文件 ";
        }
        else
        {
           infoText.text = "已经存在 Test.txt,已删除 ";
           File.Delete(path);
        }
    }
</code></pre>
<h4 id="itextshap插创建字体案例"><a class="header" href="#itextshap插创建字体案例">itextShap插创建字体案例</a></h4>
<p>itextShap 插件是用于创建PDF文档的，但是需要使用我们自己的字体。</p>
<ul>
<li>创建字体函数的方法</li>
</ul>
<pre><code>public static BaseFont CreateFont(string name, string encoding, bool embedded);//底层应该是通过 System.IO.File 来访问创建的
</code></pre>
<ul>
<li>在PC或者IOS上，我们只需要将字体放到 <code>StreamingAssets</code> 文件夹可正常使用接口创建</li>
<li>在安卓端，是不能通过 <strong>System.Io.File</strong>  访问  <strong>StreamingAssets</strong> 的，唯一可以访问的是  <strong>PersistentData</strong> 文件夹，所以我们需要在程序首次启动的时候，将<code>StreamingAssets</code> 中的字体文件 拷贝到 <code>PersistentData</code>中</li>
</ul>
<pre><code class="language-csharp">     const string SIMHEI = "SIMHEI.TTF";
    /// &lt;summary&gt;
    /// 安卓下调用
    /// 将自己使用的字体从 StreamingAssets中复制到 persisentData 中 
    /// StreamingAssets 中的 在 安卓端 被压缩了 不能直接通过  IO读取
    /// &lt;/summary&gt;
    private static void CopyFontToPersistentData()
    {
        string path = Path.Combine(Application.persistentDataPath, SIMHEI);
        //如果持久化目录下没有配置文件，先从streamingAssets里复制一份到持久化目录
        if (!File.Exists(path))
        {
            //先通过 UnityWebRequest 将 streamingAssetsPath 中的 字体读取出来
            UnityWebRequest request = UnityWebRequest.Get(Path.Combine(Application.streamingAssetsPath, SIMHEI));
            request.SendWebRequest();
            while (request.isDone == false) { }
            //写入 persistentDataPath
            File.WriteAllBytes(path, request.downloadHandler.data);
        }

    }

</code></pre>
<h4 id="注意事项-2"><a class="header" href="#注意事项-2">注意事项</a></h4>
<p><strong>该路径常用来存储档案的注意事项</strong></p>
<ul>
<li>卸载软件后该路径会被 <strong>删除</strong> ，再次安装数据被重置了（安卓端测试）</li>
<li>不卸载软件，直接重新安装，原数据还在（安卓端测试）</li>
<li>在PC端，有些时候是免安装版本，该路径是在程序所在的文件夹外，所以不会被删除</li>
<li>总结以上情况：在版本升级中，若对存储的数据结构进行改变了，那应先删除原来的数据，否则程序要出错</li>
</ul>
<h3 id="applicationtemporarycachepath"><a class="header" href="#applicationtemporarycachepath">Application.temporaryCachePath</a></h3>
<p>基本未使用过，未深入研究。</p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>平台</th>
                <th>路径</th>
                <th>读写方式</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>PC</td>
                <td>-</td>
                <td>-</td>
            </tr>
              <tr>
                <td>安卓</td>
                <td>/data/data/xxx.xxx.xxx/cache</td>
                <td>-</td>
            </tr>
             <tr>
                <td>IOS</td>
                <td>Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</td>
                <td>-</td>
            </tr>
        </tbody>
    </table>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发布-window-平台"><a class="header" href="#发布-window-平台">发布 Window 平台</a></h1>
<h2 id="usb调试"><a class="header" href="#usb调试">USB调试</a></h2>
<p>Unity版本：<code>Unity2020.3.38</code></p>
<p><strong>BuildSettings</strong></p>
<p>以Windows端为例</p>
<p><img src="unity/image/build-window/1721891706918.png" alt="1721891706918" /></p>
<ul>
<li>
<p><code>DevelopmentBUild</code>:勾选后激活下面的选项</p>
</li>
<li>
<p><code>ScriptDebugging</code>: 脚本调试，输入日志</p>
</li>
<li>
<p><code>ScirptsOnlyBuild</code>: 当你调试后想更新版本时，若只是更改了代码，那么勾选这个，并会出现两个选项 <code>patch</code> 和 <code>pathc and run</code> ,构建时相当于只更新代码那块，加快构建速度，在移动端，要取消 <code>strip unityEngine code</code></p>
</li>
</ul>
<p><strong>Playersettings</strong></p>
<ul>
<li>
<p><strong>Mono</strong> 环境下，不用更改</p>
<p><img src="unity/image/build-window/1721891713790.png" alt="1721891713790" /></p>
</li>
<li>
<p><strong>IL2CPP</strong> 环境下，需要切换成Debug，否则不能显示日志信息</p>
<p><img src="unity/image/build-window/1721891732543.png" alt="1721891732543" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发布-webgl-平台"><a class="header" href="#发布-webgl-平台">发布 WebGL 平台</a></h1>
<h2 id="模板"><a class="header" href="#模板">模板</a></h2>
<h2 id="压缩"><a class="header" href="#压缩">压缩</a></h2>
<p><strong>参考：</strong></p>
<p><a href="https://docs.unity3d.com/cn/current/Manual/webgl-deploying.html">官网压缩设置手册</a></p>
<p><a href="https://docs.unity3d.com/cn/current/Manual/webgl-server-configuration-code-samples.html">服务器配置手册</a></p>
<h3 id="压缩格式"><a class="header" href="#压缩格式">压缩格式</a></h3>
<p>从 WebGL Player Settings 窗口（菜单：<strong>Edit</strong> &gt; <strong>Project Settings</strong> &gt;  <strong>Player</strong> ），然后选择 <strong>WebGL</strong> 并展开 <strong>Publishing Settings</strong> 部分）,一般选压缩格式 <code> Gzip</code> ：</p>
<p><img src="unity/image/build-webgl/1722581090754.png" alt="1722581090754" title="WebGL Publishing 窗口的图像" /></p>
<div class="table-wrapper"><table><thead><tr><th>压缩方法</th><th>描述</th></tr></thead><tbody>
<tr><td>gzip</td><td>这是默认选项。gzip 文件比 Brotli 文件更大，但构建速度更快，且所有浏览器都基于 HTTP 和 HTTPS 实现此格式的本机支持。</td></tr>
<tr><td>Brotli</td><td>Brotli 压缩提供最佳压缩比。Brotli 压缩文件小于 gzip，但需要更长的压缩时间，因此会增加发布版本的迭代时间。Chrome 和 Firefox 仅原生支持基于 HTTPS 的 Brotli 压缩。</td></tr>
<tr><td>Disabled</td><td>禁用压缩。如果要在后期处理脚本中实现您自己的压缩，请使用此选项。如果计划在托管服务器上使用静态压缩，也应该使用此选项。</td></tr>
</tbody></table>
</div>
<p>有关浏览器对所选压缩方法的支持的更多信息，请参阅有关 <a href="https://docs.unity3d.com/cn/current/Manual/webgl-browsercompatibility.html">WebGL 浏览器兼容性</a>的文档。</p>
<h3 id="web-服务器配置"><a class="header" href="#web-服务器配置"><strong>Web 服务器配置</strong></a></h3>
<p><strong><a href="https://docs.unity3d.com/cn/current/Manual/webgl-server-configuration-code-samples.html">参考</a></strong></p>
<p>文档上提供了服务器配置示例，但是未设置成功，还是提示要配置gzip</p>
<h3 id="解压缩回退"><a class="header" href="#解压缩回退">解压缩回退</a></h3>
<p>解压缩回退选项使 Unity 能够自动将 JavaScript 解压缩器嵌入到您的构建中。该解压缩器与您选择的压缩方法相对应，它在浏览器无法解压缩内容时执行解压缩。</p>
<h4 id="enable-decompression-fallback"><a class="header" href="#enable-decompression-fallback">Enable decompression fallback</a></h4>
<p>从 <strong>Player Settings</strong> 窗口启用解压缩回退（菜单：<strong>Edit</strong> &gt; <strong>Project Settings</strong> &gt;  <strong>Player</strong> ，然后选择 <strong>WebGL</strong> 并展开 <strong>Publishing Settings</strong> 部分）：</p>
<p>如果启用解压缩回退，Unity 会向构建文件添加一个 <code>.unityweb</code> 扩展名。 如果不熟悉服务器配置，或者无法使用服务器配置，应考虑使用  <strong>Decompression Fallback</strong> 。</p>
<p><strong>Note</strong> : Enabling decompression fallback results in a large loader size and a less efficient loading scheme for the build files.</p>
<h4 id="disable-decompression-fallback"><a class="header" href="#disable-decompression-fallback">Disable decompression fallback</a></h4>
<p>The <strong>Decompression Fallback</strong> option is disabled by default. Therefore, by default, build files include an extension that corresponds to the compression method you select.</p>
<p>有两种压缩方法可供选择：gzip 或 Brotli。有关更多信息，请参阅<a href="https://docs.unity3d.com/cn/current/Manual/webgl-deploying.html#content_encoding_header">压缩格式</a>部分。</p>
<p>To enable browsers to natively decompress Unity build files while they’re downloading, you need to configure your web server to serve the compressed files with the appropriate HTTP headers. This is called native browser decompression. It’s faster than the JavaScript decompression fallback, which can reduce your application’s startup time.</p>
<p>原生浏览器解压缩的设置过程取决于 Web 服务器。有关代码示例，请参阅<a href="https://docs.unity3d.com/cn/current/Manual/webgl-server-configuration-code-samples.html">服务器配置代码示例</a>。</p>
<h3 id="内容编码标头"><a class="header" href="#内容编码标头">内容编码标头</a></h3>
<p>Content-Encoding 标头告诉浏览器 Unity 用于压缩文件的压缩类型。这样，浏览器可以原生解压缩文件。</p>
<p>将 Content-Encoding 响应标头设置为在 Player Settings 中选择的压缩方法。</p>
<div class="table-wrapper"><table><thead><tr><th>压缩方法</th><th>文件扩展名</th><th>响应标头</th></tr></thead><tbody>
<tr><td>gzip</td><td>.gz</td><td><code>Content-Encoding: gzip</code></td></tr>
<tr><td>Brotli</td><td>.br</td><td><code>Content-Encoding: br</code></td></tr>
</tbody></table>
</div>
<p>WebAssembly 串流（更高级别的标头）</p>
<p>WebAssembly streaming allows the browser to compile the WebAssembly code while it’s still downloading the code. This significantly improves loading times.</p>
<p>为了进行 WebAssembly 串流编译，服务器需要返回 <code>application/wasm</code> MIME 类型的 WebAssembly 文件。 要使用 WebAssembly 串流，需要使用带 <code>Content-Type: application/wasm</code> 响应标头的 WebAssembly 文件。 Content-Type 标头告诉服务器内容是什么媒体类型。对于 WebAssembly 文件，该值应该设置为 <code>application/wasm</code>。</p>
<div class="table-wrapper"><table><thead><tr><th>文件扩展名</th><th>响应标头</th></tr></thead><tbody>
<tr><td>.wasm、.wasm.gz、.wasm.br</td><td><code>Content-Type: application/wasm</code></td></tr>
</tbody></table>
</div>
<p><strong>Note</strong> : WebAssembly streaming doesn’t work together with JavaScript decompression when the Decompression Fallback option is enabled. The downloaded WebAssembly file must first go through the JavaScript decompressor because the browser can’t stream it during download.</p>
<h3 id="附加标头"><a class="header" href="#附加标头">附加标头</a></h3>
<p>If your file contains JavaScript, you should add the <code>application/javascript</code> Content-Type header. Some servers might include this automatically, while others don’t.</p>
<div class="table-wrapper"><table><thead><tr><th>文件扩展名</th><th>响应标头</th></tr></thead><tbody>
<tr><td>.js、.js.gz、js.br</td><td><code>Content-Type: application/javascript</code></td></tr>
</tbody></table>
</div>
<h2 id="缓存"><a class="header" href="#缓存">缓存</a></h2>
<p>发布Unity WebGL项目时，实现资源缓存可以显著提高应用的加载速度和用户体验。以下是一些常见的方法来实现资源缓存：</p>
<h3 id="使用unity自带的缓存功能"><a class="header" href="#使用unity自带的缓存功能">使用Unity自带的缓存功能</a></h3>
<p>Unity提供了一些内置功能来实现资源缓存：</p>
<ul>
<li><strong>使用PlayerSettings设置压缩和缓存策略</strong> :
在 <code>PlayerSettings &gt; WebGL &gt; Publishing Settings</code>中，可以设置压缩格式（如gzip或brotli）和启用数据缓存。</li>
</ul>
<h3 id="使用浏览器缓存"><a class="header" href="#使用浏览器缓存">使用浏览器缓存</a></h3>
<p>浏览器缓存是最常见的资源缓存方法：</p>
<ul>
<li><strong>设置HTTP头</strong> :
配置服务器来设置适当的HTTP缓存头。可以设置 <code>Cache-Control</code>、<code>Expires</code>和 <code>ETag</code>头来控制资源的缓存策略。
示例：</li>
</ul>
<pre><code class="language-http">Cache-Control: max-age=31536000, public
</code></pre>
<h3 id="使用workbox实现缓存"><a class="header" href="#使用workbox实现缓存">使用Workbox实现缓存</a></h3>
<p><strong>安装Workbox</strong> :</p>
<pre><code class="language-bash">npm install workbox-cli --global
</code></pre>
<p><strong>创建Workbox配置文件</strong>：在你的项目根目录创建一个Workbox配置文件，例如workbox-config.js，配置文件内容如下</p>
<pre><code class="language-javascript">module.exports = {
  globDirectory: 'build/',
  globPatterns: [
    '**/*.{html,js,css,wasm,data}'
  ],
  swDest: 'build/sw.js',
  runtimeCaching: [{
    urlPattern: /\.(?:html|js|css|wasm|data)$/,
    handler: 'CacheFirst',
    options: {
      cacheName: 'my-game-cache',
      expiration: {
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 缓存30天
      },
    },
  }],
   maximumFileSizeToCacheInBytes: 50 * 1024 * 1024, // 设置为50MB
};

</code></pre>
<p>这里指定了要缓存的文件类型（如.html、.js、.css、.wasm、.data、.mem和.framework.js）。</p>
<p><strong>生成Service Worker</strong>：在项目根目录运行以下命令，生成Service Worker文件：</p>
<pre><code class="language-bash">workbox generateSW workbox-config.js
</code></pre>
<p>这将在Build目录中生成一个名为sw.js的Service Worker文件。</p>
<p><strong>注册Service Worker</strong>：在Unity WebGL项目的HTML文件（通常是index.html）中注册Service Worker。在<head>或<body>标签中添加以下代码：</p>
<pre><code class="language-html">&lt;script&gt;
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('/Build/sw.js').then(function(registration) {
        console.log('ServiceWorker registration successful with scope: ', registration.scope);
      }, function(err) {
        console.log('ServiceWorker registration failed: ', err);
      });
    });
  }
&lt;/script&gt;

</code></pre>
<p><strong>部署项目</strong>：将整个Build目录上传到你的Web服务器。确保你的服务器支持HTTPS，因为Service Worker需要在HTTPS环境下才能工作。</p>
<p><strong>配置服务器缓存</strong>：为确保最佳性能，配置你的Web服务器以支持长时间缓存。以下是一个Nginx服务器的示例配置：</p>
<pre><code class="language-nginx">server {
  listen 80;
  server_name yourdomain.com;
  root /path/to/your/build/directory;

  location / {
    try_files $uri $uri/ /index.html;
  }

  location ~* \.(?:manifest|appcache|html?|xml|json)$ {
    expires -1;
  }

  location ~* \.(?:css|js|wasm|data|mem|framework.js)$ {
    expires 1y;
    access_log off;
  }

  location ~* \.(?:png|jpg|jpeg|gif|ico|svg|webp)$ {
    expires 1y;
    access_log off;
  }
}
</code></pre>
<h2 id="unitywebrequest"><a class="header" href="#unitywebrequest">UnityWebRequest</a></h2>
<p><a href="https://docs.unity3d.com/cn/current/Manual/webgl-networking.html">https://docs.unity3d.com/cn/current/Manual/webgl-networking.html</a></p>
<p><strong>下面错误的使用方式</strong></p>
<p>❌错误使用：在 <strong>pc</strong> 端可以，但是在 <strong>webgl</strong> 端要阻塞。</p>
<pre><code class="language-csharp">while(!wwww.isDone){}

</code></pre>
<p><img src="unity/image/build-webgl/1722582220211.png" alt="1722582220211" /></p>
<h2 id="报错汇总"><a class="header" href="#报错汇总">报错汇总</a></h2>
<p>⭕ <strong>GrpcWebSocketBridge</strong>：插件只能使用 <code>.net standard.21</code></p>
<hr />
<p>⭕ <code>&lt;span style="color:red;font-weight:bold;"&gt;</code> Uncaught RuntimeError: null function or function signature mismatch</p>
<p><strong>原因：</strong>：</p>
<p><strong>Addressables</strong> 打包未成功，出现的原因是莫名奇妙的少了 <code>ContentPachking$Loading</code> 这部分，需要点击 **<code>Add Schema</code>**添加</p>
<p>打包后需要在本地选择 Use Exsiting build 模式下测试是否加载成功。</p>
<p><img src="unity/image/build-webgl/1722582624459.png" alt="1722582624459" /></p>
<hr />
<p>⭕ <code>&lt;span style="color:red;font-weight:bold;"&gt;</code>Cannot create FMOD::Sound instance for clip "  " (FMOD error: An error occured that wasn't supposed to.  Contact support. )</p>
<p>**使用场景：**对音频资源使用Addressables打包，然后通过AssetReference 的方式引用。</p>
<p><strong>解决方式</strong>：(未解决) 相关的音频需要设置为流式加载。 <strong>补充：已经设置为Streaming 又出现相同的问题。</strong></p>
<p><img src="unity/image/build-webgl/1722582895900.png" alt="1722582895900" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发布-android-平台"><a class="header" href="#发布-android-平台">发布 Android 平台</a></h1>
<h2 id="1-开发"><a class="header" href="#1-开发">1 开发</a></h2>
<h2 id="2-调试"><a class="header" href="#2-调试">2 调试</a></h2>
<h3 id="21-使用插件android-logcat"><a class="header" href="#21-使用插件android-logcat">2.1 使用插件Android Logcat</a></h3>
<p>在插件包中安装该插件，详情可以看插件的文档</p>
<h3 id="22-unityremot-5"><a class="header" href="#22-unityremot-5">2.2 UnityRemot 5</a></h3>
<p>这个感觉没得上面一个好用，且不是真正在手机端运行，可能和实际情况有不符合的情况</p>
<p>收集的文章</p>
<ul>
<li>https://blog.csdn.net/vegetable_haker/article/details/126864565</li>
</ul>
<h2 id="3-发布"><a class="header" href="#3-发布">3 发布</a></h2>
<h3 id="31-发布设置"><a class="header" href="#31-发布设置">3.1 发布设置</a></h3>
<p><strong>前提条件</strong></p>
<ol>
<li>包体不能大于2G，否则无法安装</li>
</ol>
<h3 id="32-发布报错"><a class="header" href="#32-发布报错">3.2 发布报错</a></h3>
<ol>
<li>
<p>发布失败，提示IL2CPP .... 一推错误。</p>
<ul>
<li>情况1：开始勾选了development build ，发布失败，取消勾选，发布成功，再勾选，也会发布成功</li>
</ul>
</li>
<li>
<p>编辑器下运行正常，发布后失败</p>
<ul>
<li>是否时使用了Addressables， 是否已经打AB包</li>
</ul>
</li>
<li>
<p>repositories.cfg</p>
</li>
</ol>
<p>File C:\Users\Lenovo.android\repositories.cfg could not be loaded.
UnityEngine.GUIUtility:ProcessEvent (int,intptr,bool&amp;)</p>
<ol start="4">
<li>NDK问题</li>
</ol>
<pre><code>Exception: Unity.IL2CPP.Building.BuilderFailedException: C:\Program Files\Unity\Hub\Editor\2020.3.40f1c1\Editor\Data\PlaybackEngines\AndroidPlayer\NDK\toolchains\llvm\prebuilt\windows-x86_64\bin\clang++ @"C:\Users\Lenovo\AppData\Local\Temp\tmp77D3.tmp" -o "E:\Projects\CWSS\Library\il2cpp_android_arm64-v8a\il2cpp_cache\linkresult_744F7712D2E44CF47D673819F69A85D6\libil2cpp.so" -shared -Wl,-soname,libil2cpp.so -Wl,--no-undefined -Wl,-z,noexecstack -Wl,--gc-sections -Wl,--build-id -stdlib=libc++ -static-libstdc++ -target aarch64-linux-android21 -Wl,--wrap,sigaction "C:\Program Files\Unity\Hub\Editor\2020.3.40f1c1\Editor\Data\PlaybackEngines\AndroidPlayer\Variations\il2cpp\Development\StaticLibs\arm64-v8a\baselib.a" -llog -rdynamic -fuse-ld=bfd.exe

</code></pre>
<ol start="5">
<li>【Unity3D IL2CPP】构建失败，异常：Unity.IL2CPP.Building.BuilderFailedException</li>
</ol>
<pre><code>异常提示：预编译头文件来自编译器的早期版本，或者预编译头为 C++ 而在 C 中使用它(或相反)

删除项目目录Library文件夹下il2cpp_cache和Il2cppBuildCache文件夹缓存，然后尝试重新打包。

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 12px;
    text-align: left;
    vertical-align: top; 
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.excel-table tr:nth-child(even), table tr:nth-child(odd) {
    background-color: transparent; /* 确保所有行背景色一致 */
}

.excel-table tr:hover {
    background-color: inherit;
}
/*

.excel-table tr:nth-child(even) {
    background-color: #f9f9f9;
}

.excel-table tr:hover {
    background-color: #e9e9e9;
}
*/
.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    width: 20%;
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 40%;
}

.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width: 40%;
}
</style>
<h1 id="发布-ios-平台"><a class="header" href="#发布-ios-平台">发布 IOS 平台</a></h1>
<p><a href="https://docs.unity.cn/cn/2021.1/Manual/iphone-BuildProcess.html">Unity官方文档 - iOS 构建过程详解</a></p>
<h2 id="上架说明"><a class="header" href="#上架说明">上架说明</a></h2>
<ol>
<li>
<p>注册一个苹果开发者账号，可以个人注册，或者公司注册，公司比较复杂，个人比较简单，个人的年费为688</p>
</li>
<li>
<p>需要一个Mac，主要用于申请一些证书和使用Xcode软件（上架必备）</p>
</li>
<li>
<p>请求证书，以及制作配置文件</p>
</li>
<li>
<p>Unity Build IOS, 此过程在 windows上和mac上都可以进行，结果是得到一个 Xcode项目工程</p>
</li>
<li>
<p>在 mac 上使用xcode 打开 上一步的项目设置分发</p>
</li>
<li>
<p>测试分发：发布测试版本，就是不用上架审核，但是有限制</p>
</li>
<li>
<p>上架分发，需要审核，终极目标。</p>
</li>
</ol>
<h2 id="苹果开发者账号"><a class="header" href="#苹果开发者账号">苹果开发者账号</a></h2>
<h3 id="注册"><a class="header" href="#注册">注册</a></h3>
<p>首先需要开发者账号，且按年付费，具体注册流程如下：</p>
<ol>
<li>
<p>手机下载 developer app 进行注册申请，在手机上下载app安装</p>
</li>
<li>
<p>注意填写信息时，完全按照身份证上的填写，按照英文的格式填写，最好就是找个已经注册好的看下格式来填写（我还是失败了，最后是人工客服完成的，使用电话的方式，她帮你解决；使用邮件会来回折腾，还是不行）</p>
</li>
<li>
<p>客户帮你解决后，回到app,退出再登录，才能继续注册流程，选择个人注册，直到付完费用688，订阅后，马上取消订阅，避免到时候忘了（若上架的账号没有继续订阅，未安装过此app的无法在商店找到此应用，安装过的还是可以找打）</p>
</li>
<li>
<p>此时，在app上显示一个灰色的注册，说是我即将收到一个邮件</p>
</li>
<li>
<p>收到邮件，上传身份证，正反面都要上传，完成激活，此时应该才是注册完成（给的邮件说是带有照片的，我就只上传照片的，最后人工后，说两面都要上传）</p>
</li>
<li>
<p>总结：注册很狗屎，每次错也不晓得哪里错，不停的试，最后都是人工处理。</p>
</li>
</ol>
<blockquote>
<p><strong>注意事项（坑）</strong>：</p>
<ol>
<li>
<p>看siki学院的视频，以为付费完就注册完了，实际上还要上传身份证</p>
</li>
<li>
<p>我也的确收到邮件了，叫我上传身份证，但是我以为是之前注册失败，叫我上传，有几次失败就是叫上传，结果还是不行，所以我也没理</p>
</li>
<li>
<p>我就还在等其他的邮件，在网页端登录，叫我继续注册流程，很郁闷。</p>
</li>
</ol>
</blockquote>
<h3 id="续费"><a class="header" href="#续费">续费</a></h3>
<p>订阅续费在手机上操作：设置/账号头像（名称）/订阅。即可看到已经停用的 <strong>Apple Developer</strong> ，点击续订即可。</p>
<p>网上（ChatGpt）说的在开发者官网上的会员详情里面续订不行，就没有续订按钮。</p>
<h2 id="一钥匙串创建证书"><a class="header" href="#一钥匙串创建证书">一、钥匙串创建证书</a></h2>
<blockquote>
<p>先创建好后面步骤要使用。</p>
</blockquote>
<ol>
<li>
<p>在 mac 上 打开钥匙串app</p>
</li>
<li>
<p>在屏幕左上角：钥匙串访问-》证书助理-》从证书颁发机构请求证书</p>
<p><img src="unity/image/build-ios/image.png" alt="证书助理" /></p>
</li>
<li>
<p>请求是：选择“存储到磁盘”，点击继续，保存即可</p>
</li>
<li>
<p>注意这个证书，只能在本设备上使用，若其他电脑要使用这个证书，需要转换，方法待补充</p>
</li>
</ol>
<h2 id="二证书"><a class="header" href="#二证书">二、证书</a></h2>
<ol>
<li>
<p>登录开发者网站，进入<a href="https://developer.apple.com/account">Developer-账户</a>。</p>
</li>
<li>
<p>选择证书（注意：如果官网存在协议更新，需要重新查看协议，并同意后，才能出现证书的相关操作，否者证书下没有可选操作）。
<img src="unity/image/build-ios/developer-%E8%AF%81%E4%B9%A6.png" alt="证书" /></p>
</li>
<li>
<p>点击 <code>+</code>。
<img src="unity/image/build-ios/certificates-add.png" alt="alt text" /></p>
</li>
<li>
<p>在 <code>Software</code> 下选择证书类型，在 <code>Services</code> 下选择需要的服务，点击继续。</p>
<ul>
<li><code>Apple Development</code>: 苹果所有终端的开发测试证书，包含 mac ios</li>
<li><code>Apple Distribution</code>: 苹果所有终端的上架发布测试证书，包含 mac ios</li>
<li><code>IOS App Development</code>：仅 ios 端的开发测试证书</li>
<li><code>IOS Distribution (App Store and Ad Hoc)</code>：ios 端 的 上架商店证书</li>
<li>其他同理</li>
</ul>
</li>
<li>
<p>上传之前使用钥匙串申请的证书，点击继续。</p>
</li>
<li>
<p>下载申请好的证书，然后<strong>双击</strong>后安装到钥匙串中。</p>
</li>
<li>
<p>最后我们在证书列表里面可以看到当前生气的证书，注：钥匙串申请的证书可以创建测试证书和分发证书。</p>
</li>
<li>
<p>证书会过期（当开发者账号订阅过期时，证书也会过期）</p>
</li>
</ol>
<h2 id="三identifiers标识符"><a class="header" href="#三identifiers标识符">三、Identifiers（标识符）</a></h2>
<ol>
<li>在证书、标识符和描述文件页面，左侧选择 Identifers ,点击 <code>Identifiers +</code></li>
<li>选择 <code>App IDs</code></li>
<li>选择 APP</li>
<li>Regieste an App ID, 输入 bundle identifier，这个需要记住，后面在Unity工程设置中需要使用</li>
<li>设置 App Services，这个根据需要选择，比如推送、支付等，点击 continue</li>
<li>点击 register，注册完成</li>
<li>在 Identifers 列表里面可以看到当前注册的 App ID，注：这个 App ID 会在后面的描述文件中使用到</li>
</ol>
<h2 id="四devices设备"><a class="header" href="#四devices设备">四、Devices（设备）</a></h2>
<p>作用，收集需要参加测试手机的UDID号，添加到这里，在打包测试的时候，只有添加了的设备才能安装测试
上架商店就不需要这个</p>
<p>获取设备UDID
通过下面的地址，在浏览器打开后，提示下载配置文件，然后安装，获取，发送给指定邮箱
<a href="https://www.pgyer.com/tools/udid">https://www.pgyer.com/tools/udid</a></p>
<h2 id="五profiles描述文件"><a class="header" href="#五profiles描述文件">五、Profiles（描述文件）</a></h2>
<ol>
<li>点击 + 。</li>
<li>Register a New Provisioning Profile：选择类型，根据当前的测试设备和类型（测试/分发）来选择。</li>
<li>Generate a Provisioning Profile：选择 App ID，Provisioning Profile Configuration 默认 选择 No,点击 continue.</li>
<li>选择一个证书，点击继续。</li>
<li>选择测试的设备，点击继续。</li>
<li>填写描述文件名称，点击生成。</li>
<li>下载描述文件，备用。</li>
<li>在 Profiles 列表里面可以看到当前生成的描述文件，注：这个描述文件会在后面的打包中使用到。</li>
</ol>
<h2 id="六unity项目设置"><a class="header" href="#六unity项目设置">六、Unity项目设置</a></h2>
<p>此处的设置可以在xcode里面修改，所以如果填写错误，不用再重新发布。</p>
<ol>
<li>可以在window上或者mac上进行</li>
<li>设置公司名称</li>
<li>设置product name：上架审核时，这个名称必须 app store connect上创建的app 名称相同，否审核不过</li>
<li>设置version：只能包含"数字"和“.”，其他都是非法的，可以在xcode里面修改。</li>
<li>设置bundle identifier： 这个必须和后面创建的证书时一致，可以在xcode里面修改。</li>
<li>设置 Target device: 根据你的实际需求来，如果仅在iphone上运行，那么就选 iPhone only，否则在上架审核时，需要你上传其他设备的分辨率截图，多出很多事情，可以在xcode里面修改。</li>
<li>目标最小ios版本，这个根据情况设置，可以在xcode里面修改。</li>
</ol>
<h2 id="七xcode项目设置"><a class="header" href="#七xcode项目设置">七、Xcode项目设置</a></h2>
<blockquote>
<p>version: 15.4</p>
</blockquote>
<p><a href="https://developer.apple.com/documentation/xcode/preparing-your-app-for-distribution">官网文档</a></p>
<ol>
<li>将Unity工程打包成Xcode工程，可以在Windows打包，也可以在mac上打包（未知原因：在mac上无法打开工程，一致卡在fbx的导入）</li>
<li>双击Xcode文件，打开工程</li>
<li>选中TARGETS 下的 第一个</li>
</ol>
<h3 id="1geneeral"><a class="header" href="#1geneeral">（1）Geneeral</a></h3>
<ol>
<li>
<p><code>Suported Destinations</code>：设置支持的设备，这里删除掉ipad的设备，如果这里支持iPad,上架审核的时候，会叫你整ipad的截图，很多事情。</p>
</li>
<li>
<p><code>Minimum Deployments</code>：设置最小的IOS版本。</p>
</li>
<li>
<p><code>Identity</code>：主要设置下面两个选项</p>
<ul>
<li><code>Bundle Identifier</code>：证书里面填写的id，unity 中配置的一致。</li>
<li><code>Version</code>：设置版本号，一种方式就是在unity里面设置好，另外一种方式就是在xcode 里面设置，这个只能包含 “数字”、“.”, 如 “1.0.1”， 不能有字母或者空格，如果发布的是测试版本，版本号可以不变，如果是上架审核，版本号增加比较好，不增加不会报错。</li>
</ul>
</li>
<li>
<p>设置 <code>app icon</code> ,这个在上架的时候必须有</p>
</li>
</ol>
<h3 id="2signingcapabilities"><a class="header" href="#2signingcapabilities">（2）Signing&amp;Capabilities</a></h3>
<p>Bundle Identifiers: 同创建证书时的一致</p>
<p>在 all 标签下，选择profile，这里如果是构建测试的就import 测试的 配置，就是前面下载下来的，同理选择分发上架类型的，如果找不到文件，重启下xcode.</p>
<p>错误信息：</p>
<p><img src="unity/image/build-ios/provisioning%20profile-error.png" alt="alt text" /></p>
<p>解决(根据提示，xcode 11 及之后都要 apple distribution)：</p>
<p><img src="unity/image/build-ios/provisioning%20profile-error-ok.png" alt="alt text" /></p>
<p>如果连接手机测试，此处要这样配置</p>
<p><img src="unity/image/build-ios/auto-mng-signing.png" alt="alt text" /></p>
<h3 id="3resources-tages"><a class="header" href="#3resources-tages">（3）Resources Tages</a></h3>
<p>暂无配置</p>
<h3 id="4info"><a class="header" href="#4info">（4）Info</a></h3>
<p><strong>Custom iOS Target Properties:</strong></p>
<ul>
<li>
<p><code>App Transport Securiy Settings</code>：</p>
<ul>
<li><code>Allow Arbitrary Loads</code>：<code>Yes</code>,（这样就允许了http 未加密的方式访问网站，否则会报错）</li>
</ul>
</li>
<li>
<p>【新版xcode 没有这个】设置不使用出口合规证明 (仅在上架审核的时候需要)  <code>&lt;key&gt;ITSAppUsesNonExemptEncryption&lt;/key&gt;&lt;false/&gt;</code></p>
</li>
</ul>
<h3 id="5build-settings"><a class="header" href="#5build-settings">（5）Build Settings</a></h3>
<ul>
<li>
<p>User-Defined</p>
<ul>
<li>Eenable Bitcode : 设置为 false (打包的时候说是不赞成这个，不让通过)</li>
</ul>
</li>
</ul>
<h3 id="6连接手机测试"><a class="header" href="#6连接手机测试">（6）连接手机测试</a></h3>
<ul>
<li>需要手机和电脑连接，直接将app安装到手机上，适用于调试方式。</li>
<li>在xcode上点击菜单：Product-&gt;Run。</li>
</ul>
<h3 id="7xcode-操作"><a class="header" href="#7xcode-操作">（7）Xcode 操作</a></h3>
<h4 id="菜单"><a class="header" href="#菜单">菜单</a></h4>
<ol>
<li>菜单：Produr/Run: 直接连接手机，安装到手机运行</li>
<li>菜单：ProdurArechive: 归档，用于构建 ipa 文件、上架商店，通过Testflight 测试</li>
<li>菜单：Window/Organizer: 打开归档的窗口</li>
</ol>
<h4 id="navigator"><a class="header" href="#navigator">Navigator</a></h4>
<p>左侧导航栏。</p>
<ol>
<li>Unity 中的 <code>StreamingAssets</code> 下的资源对应 <code>Data/Raw</code>，当需要修改这些资源时，不需要重新打包
<img src="unity/image/build-ios/data-raw.png" alt="data/raw" /></li>
<li></li>
</ol>
<h2 id="八分发app"><a class="header" href="#八分发app">八、分发APP</a></h2>
<p>该章节说明怎么进行 Testflight 测试、第三方分发Ipa包测试、以及最终上架苹果商店。</p>
<p>ipa文件不能直接通过苹果手机安装，需要通过分发平台进行分发安装。</p>
<p><a href="https://developer.apple.com/documentation/xcode/distributing-your-app-for-beta-testing-and-releases">Xcode 操作文档（英文）</a></p>
<p><a href="https://developer.apple.com/cn/help/app-store-connect/test-a-beta-version/testflight-overview/">App Store Connect 帮助 - 中文文档： add app,</a></p>
<p><strong>各种运行方式</strong></p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>运行方式</th>
                <th>分发类型</th>
                <th>说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>手机直接连接</td>
                <td>无</td>
                <td>调试</td>
            </tr>
              <tr>
                <td>分发ipa</td>
                <td>app store connect/testfliht only/ad hoc 都可以，仅是在中途将ipa 文件导出保存下来</td>
                <td>构建之前要获取目标设备udid号进行注册<br>可以使用蒲公英云平台分发<br>不适合非注册人员安装<br>这种方式似乎不需要支付688费用，未确定</td>
            </tr>
              <tr>
                <td>testflight</td>
                <td>app store connect/testfliht only都可以</td>
                <td>要运行的手机首先要在构建之前手机设备udid号进行注册<br>可以使用蒲公英云平台分发</td>
            </tr>
             <tr>
                <td>app store</td>
                <td>app store connect</td>
                <td>正常用户使用</td>
            </tr>
        </tbody>
    </table>
</div>
<h3 id="1创建您的应用程序的存档"><a class="header" href="#1创建您的应用程序的存档">（1）创建您的应用程序的存档</a></h3>
<p>要使用任何分发方法，请先创建应用程序的存档。存档是应用程序的构建，包括调试信息，Xcode存储在捆绑包中。Xcode根据您为分发选择的分发配置重新打包存档的内容。</p>
<p>在Xcode项目的主窗口中，从Scheme工具栏菜单中选择要构建的方案和运行目标。然后，选择 <code>Produnct&gt;Archive</code> ，为您选择的设备类构建该方案中包含的目标，并创建出现在档案管理器中的存档。</p>
<p><img src="https://docs-assets.developer.apple.com/published/394197047da27d4eb6d4dc6ffe161cf4/distributing-your-app-for-beta-testing-and-releases-1@2x.png" alt="档案组织者的屏幕截图，显示已选择的档案和分发应用程序按钮。" /></p>
<p>您可以通过选择 <code>Window&gt;Organizer</code> 直接打开档案管理器。如果您想确认您的应用程序已准备好在未提交的情况下提交到TestFlight或App Store，请选择您的存档，然后单击 <code>Validate App</code> 。Xcode将对应用程序执行有限的自动初始验证并提供反馈。
对于使用Mac Catalyst构建的Mac应用程序，请为iPad和Mac版本创建单独的存档。为Mac版本创建存档时，请选择“我的Mac”作为运行目标。</p>
<h3 id="2选择一种分发方法"><a class="header" href="#2选择一种分发方法">（2）选择一种分发方法</a></h3>
<p>您可以导出存档或将其上传到App Store Connect。如果您导出存档，您可以在App Store之外分发（通过第三方平台分发Ipa）。否则，将存档上传到App Store Connect，以通过TestFlight或App Store分发。</p>
<p>从Xcode的 <strong>Organizer</strong> 窗口中，在边栏中选择“存档”，然后单击“分发应用程序”。</p>
<p><img src="https://docs-assets.developer.apple.com/published/ba54e01600bd0fc98291583e7215d2bd/distributing-your-app-for-beta-testing-and-releases-2@2x.png" alt="Archives Organizer的屏幕截图，显示选择分发方法对话框，并选择预配置的TestFlight和App Store选项。" /></p>
<p>选择以下选项之一，使用推荐的设置进行分发：</p>
<p>TestFlight &amp; App Store</p>
<p>通过TestFlight分发并提交到App Store的默认设置。使用此选项更新存档中内容的构建号，执行自动代码签名，并使用符号上传应用程序。</p>
<p>TestFlight Internal Only</p>
<p>通过TestFlight分发的默认设置，并限制对团队的访问。使用此选项可防止应用程序的开发构建被提交到App Store。</p>
<p>Release Testing 发布测试</p>
<p>默认设置是在发布前分发要测试的版本。使用此选项执行类似于App Store分发选项的自动代码签名，并导出以安装在您的团队在App Store Connect注册的设备上。这种分发方法不适用于为Mac构建的应用程序。</p>
<p>Enterprise（企业）</p>
<p>分配给组织成员的默认设置。如果您是Apple Developer企业计划的一部分，请使用此选项。这种分发方法不适用于为Mac构建的应用程序。</p>
<p>Direct Distribution（直接分销）</p>
<p>直接分发macOS应用程序的默认设置。使用此选项对开发人员ID应用程序进行公证，以便直接分发。这种分发方法仅适用于为Mac构建的应用程序。</p>
<p>Debugging 调试</p>
<p>分发版本进行调试的默认设置。使用此选项导出版本，在您的团队在App Store Connect注册的设备上安装和调试。这使沙盒测试环境能够为一些支持它们的功能提供支持。</p>
<p>选择分发选项后，单击分发按钮。Xcode开始处理、打包和上传。单击末尾的链接以访问App Store Connect上应用程序的构建页面，或单击导出按钮以在本地访问资产。</p>
<blockquote>
<p>笔记
在您首次将应用程序上传到App Store之前，请创建一个应用程序记录以在App Store Connect中注册您的应用程序。如果您还没有这样做，Xcode会要求您提&gt; 供为您创建此记录所需的信息。有关更多信息，请参阅<a href="https://developer.apple.com/help/app-store-connect/create-an-app-record/add-a-new-app">创建应用程序记录</a>。</p>
</blockquote>
<h3 id="3创建自定义发行版"><a class="header" href="#3创建自定义发行版">（3）创建自定义发行版</a></h3>
<p>要开始自定义分发，允许您配置自己的设置，请单击自定义选项。</p>
<p><img src="https://docs-assets.developer.apple.com/published/1ebd7fcf079ce9cf3d0331cfa2c7c518/distributing-your-app-for-beta-testing-and-releases-3@2x.png" alt="分发方法选择步骤的屏幕截图，显示所选的临时分发。" /></p>
<p>从以下分发方法中选择：</p>
<p>App Store Connect</p>
<p>使用TestFlight或通过App Store进行分发。</p>
<p>Ad Hoc（临时）</p>
<p>分发到您在App Store Connect中注册的有限数量的设备。有关分发到您注册的设备的更多信息，请参阅<a href="https://developer.apple.com/documentation/xcode/distributing-your-app-to-registered-devices">将应用程序分发到注册设备</a>。</p>
<p>Enterprise（企业）</p>
<p>如果您是Apple Developer Enterprise Program的一部分，并准备将应用程序发布给组织中的用户，请分发给您的组织成员。</p>
<p>Developer ID（开发人员ID）</p>
<p>在App Store之外分发由苹果公证或使用开发人员ID签名的macOS应用程序。这种分发方法仅适用于为Mac构建的应用程序。</p>
<p>Development（开发）</p>
<p>分发到您在App Store Connect中注册的有限数量的设备。有关分发到您注册的设备的更多信息，请参阅<a href="https://developer.apple.com/documentation/xcode/distributing-your-app-to-registered-devices">将应用程序分发到注册设备</a>。</p>
<p>Copy App（复制应用程序）</p>
<p>在没有代码签名的情况下分发macOS应用程序。这种分发方法仅适用于为Mac构建的应用程序。</p>
<p>如果您选择App Store Connect或Developer ID作为分发方法，您也会选择一个目标选项。您可以选择将构建版本上传到App Store，或将构建版本导出到本地以稍后上传。</p>
<p><img src="https://docs-assets.developer.apple.com/published/42129fbe9643b7d6d49e6b714d240933/distributing-your-app-for-beta-testing-and-releases-4@2x.png" alt="分发流程的屏幕截图，显示目标选项以及上传或导出选项。上传被选中" /></p>
<p>在TestFlight或App Store上分发应用程序时，请选择如何管理符号和构建数字：</p>
<p><img src="https://docs-assets.developer.apple.com/published/c9577bec89092a11e40b6ff4c8528605/distributing-your-app-for-beta-testing-and-releases-5@2x.png" alt="分发流程的屏幕截图显示App Store Connect分发选项，带有复选框，用于上传应用程序的符号，管理版本和构建版本号，以及仅限TestFlight内部测试。选中“上传应用程序的符号”和“管理版本和构建数字”复选框" /></p>
<p>Strip Swift symbols 剥离Swift符号</p>
<p>通过从Swift标准库中剥离符号来减小应用程序的大小。仅当您的项目嵌入了swift库时，此设置才可用。</p>
<p>Upload your app’s symbols 上传您的应用程序的符号</p>
<p>允许苹果为您提供符号崩溃日志和其他诊断信息。符号日志将日志中的内存地址替换为人类可读的函数名和行号。这些符号在测试您的应用程序与苹果产品和服务的兼容性方面也很有用。</p>
<p>Manage version and build number 管理版本和构建号</p>
<p>允许Xcode更新存档中所有内容的构建号。</p>
<p>TestFlight internal testing only 仅限TestFlight内部测试</p>
<p>准备通过TestFlight分发应用程序，并限制对您团队的访问。使用此选项可防止应用程序的开发构建被提交到App Store。</p>
<p>在选择涉及代码签名的分发方法时，请选择代码签名方法。</p>
<p><img src="https://docs-assets.developer.apple.com/published/f018d363495f18c2d8872aeb7d2a48c6/distributing-your-app-for-beta-testing-and-releases-6@2x.png" alt="分发流程的屏幕截图显示了自动管理签名和手动管理签名分发的复选框。选中自动管理签名复选框" /></p>
<p>选择“自动管理签名”允许Xcode为您管理签名。要手动对应用程序进行签名，您可以使用签名证书。有关共享签名证书的信息，请参阅将您的代码签名身份与Apple Developer Portal同步。</p>
<p>当使用Ad Hoc或Development选项进行自我分发打包时，请选择是启用还是禁用App Thinning并配置按需资源设置。有关应用程序稀薄和按需资源的更多信息，请参阅减少应用程序的大小和进行高级优化以进一步减少应用程序的大小。</p>
<p><img src="https://docs-assets.developer.apple.com/published/8701513eaeb5a39fbda9c970a6f685c5/distributing-your-app-for-beta-testing-and-releases-7@2x.png" alt="显示临时分发设置的分发流程屏幕截图。该对话框包括应用程序瘦身弹出式菜单，其中选项为“无”，其他选项包括一个带有“包括无线安装清单”标签的复选框" /></p>
<h3 id="4分发测试版"><a class="header" href="#4分发测试版">（4）分发测试版</a></h3>
<p>要分发应用程序的测试版，以提供即将发布的版本的预览，请选择与您的测试资源一致的分发方法：</p>
<ul>
<li>
<p>使用TestFlight将应用程序的测试版分发给内部和外部测试人员。TestFlight应用程序允许受邀用户安装、测试版测试、提供反馈并获取应用程序的更新。苹果为您分发测试版，您可以在App Store Connect中管理构建版本和用户。要了解更多信息，请参阅<a href="https://developer.apple.com/cn/help/app-store-connect/test-a-beta-version/overview-of-testflight">TestFlight概述</a>。</p>
<p>在 Xcode 上传后，在网站上查看状态，如下图</p>
<p><img src="unity/image/build-ios/testflight%20%E6%B5%8B%E8%AF%95%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="alt text" /></p>
</li>
<li>
<p>将测试版分发到开发人员帐户中的注册设备。仅当您可以保留部分有限的开发设备用于beta测试时，才选择此选项。要了解更多信息，请参阅<a href="https://developer.apple.com/documentation/xcode/distributing-your-app-to-registered-devices">将应用程序分发到注册设备</a>。</p>
</li>
<li>
<p>对于macOS应用程序，在通过App Store分发应用程序之前，先将经过苹果公证的构建版本分发给测试人员。要了解更多信息，请参阅<a href="https://developer.apple.com/documentation/xcode/distributing-your-app-to-registered-devices">在分发前对macOS软件进行公证</a>。</p>
</li>
</ul>
<p><img src="https://docs-assets.developer.apple.com/published/c67e305f2a0af926d2c0551f08aebb1d/distributing-your-app-for-beta-testing-and-releases-8@2x.png" alt="App Store Connect的屏幕截图显示了从Xcode上传的构建版本" /></p>
<h3 id="5在app-store上发布"><a class="header" href="#5在app-store上发布">（5）在App Store上发布</a></h3>
<p>测试最终版本后，将其提交到App Review，然后在App Store上提供。有关发布过程的更多信息，请参阅<a href="https://developer.apple.com/cn/help/app-store-connect/manage-your-apps-availability/overview-of-publishing-your-app">发布应用程序的概述</a>。</p>
<p>转到App Review查看App Store和人机界面指南。有关特定平台的指导，请参阅<a href="https://developer.apple.com/cn/app-store/submitting">立即提交您的应用程序</a>。</p>
<p>您可能需要在App Store Connect中输入其他信息，然后才能将应用程序提交到App Review。在您的应用程序上传或发布后，您无法更改其中一些元数据，因此仔细选择设置很重要。有关此元数据的更多信息，请转到App Store Connect帮助中的必需、可本地化和可编辑属性。</p>
<p>如果您使用TestFlight分发测试版，并输入了App Store发布所需的其他信息，只需将App Store Connect中显示的最后一个版本提交到App Review即可。
App Store Connect的屏幕截图，显示版本信息和提交以供审核。</p>
<p>如果您没有使用TestFlight分发最终构建版本，请准备应用程序分发并创建应用程序的存档。在继续之前验证存档并修复任何验证错误。然后，将其上传到App Store Connect，并等待它通过App Store Connect验证测试。</p>
<p>要将构建提交到App Review，请转到Submit for Review。</p>
<h3 id="6注意事项"><a class="header" href="#6注意事项">（6）注意事项</a></h3>
<p>有关注意事项可参考：<a href="https://developer.apple.com/cn/help/app-store-connect/reference/app-information">官方文档</a></p>
<ol>
<li><a href="https://developer.apple.com/cn/help/app-store-connect/create-an-app-record/add-a-new-app">添加App</a>时，填写app名称和unity里面的名称最好一样，两个名称不同或者相差很大，导致审核不通过，这里写的名称是商店里软件显示的名称，unity里面的名称，是安装后在手机桌面显示的名称，提交后，苹果会提示里两个名称不一样，会导致用户找不到下载的软件。</li>
</ol>
<p><img src="unity/image/build-ios/1718095073433.png" alt="1718095073433" /></p>
<ol start="2">
<li>
<p>上传完成后，在 App store connect 里的TestFlight 标签页查看，这个时候还不能在app store 页查看，因为还没提交</p>
</li>
<li>
<p>在xcode 上传后，并不能立即进行testflight 测试，一般要显示“已批准/通知测试人员”才可以开始测试。
<img src="unity/image/build-ios/testflight%20%E6%B5%8B%E8%AF%95%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="" /></p>
</li>
<li>
<p>管理 APP ID 不能参加测试，也就是开发者账户不能参加测试。</p>
</li>
<li>
<p>提交构建版本，多个版本的时候选择最新的版本</p>
</li>
<li>
<p>除了可选填的，都是必须填写的</p>
</li>
<li>
<p>隐审核流程：私项填写完成后需要 <strong>发布</strong></p>
</li>
<li>
<p>审核流程：各种网址（技术网址，隐私网址），填写公司网址，或者个人网址即可</p>
</li>
<li>
<p><a href="https://developer.apple.com/cn/help/app-store-connect/reference/maximum-build-file-sizes">构建版本大小要求</a></p>
</li>
<li>
<p>审核流程：<a href="https://developer.apple.com/cn/help/app-store-connect/reference/screenshot-specifications">截屏规范</a>，用一个手机截图后，ps处理成对应分辨率的，上传失败会提示里，应该上传什么分辨率</p>
</li>
<li>
<p>审核流程：只要你有登录界面，那么需要在testflight -》 测试信息中，勾选 “需要登录”，且输入登录审核的账号信息，即使输入任何账号和密码都可以，也需要勾选需求要登录，然后明确的输入一个账号和密码，否者审核不过。</p>
</li>
</ol>
<p>若是企业定制版本的软件，不需要上架商店，而是希望通过内部分发的方式，参考：<a href="https://support.apple.com/zh-cn/guide/deployment/depe1553f932/web">分发类型</a></p>
<p><a href="https://developer.apple.com/contact/request/unlisted-app/">使用非公开发方式发布</a></p>
<h3 id="7问题汇总"><a class="header" href="#7问题汇总">（7）问题汇总</a></h3>
<ol>
<li>
<p>提示邀请已被撤销或无效,请要求开发者发出新的邀请。</p>
<blockquote>
<p>看是否使用的是管理 APP ID。</p>
</blockquote>
</li>
<li>
<p>此Beta 版本现在不接受任何新的测试人员</p>
<blockquote>
<p>应该是该APP还未被批准使用TestFlight测试，首次提交一般上传后需要1天（头天下午上传，第二天10点可以）左右的时间，会收到一封邮件提示已批准使用TestFlight测试，然后可以发送邀请链接了，后面提交很快，基本上提交等待几分钟就可以测试。</p>
</blockquote>
</li>
<li>
<p>构建时提示禁用 bitcode</p>
<blockquote>
<p><a href="https://www.likecs.com/show-203846296.html">参考文章</a>:在 Xcode中 选择 buildsettings, 搜索 bitcode,设置为 <code>false</code>。</p>
</blockquote>
</li>
</ol>
<h2 id="九蒲公英分发"><a class="header" href="#九蒲公英分发">九、蒲公英分发</a></h2>
<p>ipa文件不能直接通过苹果手机安装，需要通过分发平台进行分发安装。</p>
<ol>
<li>Product-&gt;Archive，等待编译完成</li>
<li>编译完成后，Xcode会自动打开“Organizer”窗口</li>
<li>你可以选择导出的配置文件和导出选项，然后点击“Export”按钮，选择“Save for Ad Hoc Deployment”或“Save for Enterprise Deployment”</li>
<li>最后选择保存路径和文件名，完成IPA文件的生成。</li>
<li>将ipa通过<a href="https://www.pgyer.com/">蒲公英分发平台</a>分发app</li>
<li>打开蒲公英分发平台网站，注册账号上传ipa（名字最短那个文件） 分发app</li>
</ol>
<p>若提示需要钥匙串的密码，输入开机密码。并非用户账户密码。</p>
<h2 id="十错误汇总"><a class="header" href="#十错误汇总">十、错误汇总</a></h2>
<h3 id="pc端正常构建ios后无法进入场景"><a class="header" href="#pc端正常构建ios后无法进入场景">PC端正常，构建IOS后无法进入场景</a></h3>
<p>情况说明：</p>
<p>当前同个项目会发布4个软件（APP），前面两个正常，后面两个加载场景后无法进入场景</p>
<p>后面两个场景有5个任务场景，当发布一个的时候又正常</p>
<p>错误提示</p>
<pre><code>MissingMethodException: Default constructor not found for type UnityEngine.ResourceManagement.AsyncOperations.ProviderOperation`1[[UnityEngine.AddressableAssets.Initialization.ResourceManagerRuntimeData, Unity.Addressables, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]
  at System.RuntimeType.CreateInstanceMono (System.Boolean nonPublic) [0x00000] in &lt;00000000000000000000000000000000&gt;:0 
  at System.Activator.CreateInstance (System.Type type, System.Boolean nonPublic) [0x00000] in &lt;00000000000000000000000000000000&gt;:0 
  at UnityEngine.ResourceManagement.Util.LRUCacheAllocationStrategy.New (System.Type type, System.Int32 typeHash) [0x00000] in &lt;00000000000000000000000000000000&gt;:0 
  at UnityEngine.ResourceManagement.ResourceManager.CreateOperation[T] (System.Type actualType, System.Int32 typeHash, UnityEngine.ResourceManagement.Util.IOperationCacheKey cacheKey, System.Action`1[T] onDestroyAction) [0x00000] in &lt;00000000000000000000000000000000&gt;:0 

</code></pre>
<p>尝试解决方案：<a href="https://blog.csdn.net/hack_yin/article/details/126028734">参考文章</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unitask"><a class="header" href="#unitask">UniTask</a></h1>
<p><a href="https://github.com/Cysharp/UniTask">官网</a></p>
<h2 id="runonthreadpool"><a class="header" href="#runonthreadpool">RunOnThreadPool</a></h2>
<p>❌❌❌ RunOnThreadPool <strong>不支持</strong> WEBGL❌❌❌</p>
<p>在WebGL平台上，这个方法可能不起作用，因为WebGL不支持标准的线程池或异步编程模型。</p>
<p>如下示例：</p>
<pre><code class="language-c#">private async UniTask Execute()
{
    await UniTask.Delay(1000);
    Debug.Log($"Delay 1000!");
    UniTask.RunOnThreadPool(async e =&gt;
    {
        await UniTask.Delay(2000); //在PC上这里可以执行，但是在WEBGL中，这里不会执行
        Debug.Log($"Delay 2000!");
    },true).Forget();
}

       
</code></pre>
<p>更新后</p>
<pre><code class="language-c#">private async UniTask Execute(ICommand command, EventDataBase evt)
{
    await UniTask.Delay(1000);
    Debug.Log($"Delay 1000!");
    MyDelay().Forget();
}

private async UniTaskVoid MyDelay()
{
    await UniTask.Delay(2000);
    Debug.Log($"Delay 2000!");
}
</code></pre>
<h2 id="cancellationtokensource"><a class="header" href="#cancellationtokensource">CancellationTokenSource</a></h2>
<ol>
<li>
<p>每次使用要 new</p>
</li>
<li>
<p>Cancel 和 Dispose</p>
</li>
</ol>
<pre><code class="language-c#">    CancellationTokenSource  Cancel = new CancellationTokenSource();

    UniTask.Delay(5000, cancellationToken: Cancel.Token).ContinueWith(() =&gt;
    {
        Debug.Log("执行了");
    }).Forget();

</code></pre>
<p>Cancel： 不会输出 执行了</p>
<p>Dispose： 会输出 执行了</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Unity针对Sqlite的处理方法根据版本不同有不同的处理，在Unity2020以及之前，Unity官方没有给出自己的解决方案，但是在Unity2021之后，根据VisaulScrptApi，可以采用官方的方案来实现</p>
</blockquote>
<h2 id="unity2020及之前版本"><a class="header" href="#unity2020及之前版本">Unity2020及之前版本</a></h2>
<h3 id="导入dll"><a class="header" href="#导入dll">导入DLL</a></h3>
<p>见Unity中的DLL引用章节</p>
<h3 id="使用教程"><a class="header" href="#使用教程">使用教程</a></h3>
<p><a href="https://warl.top/posts/unity-sqlite/">Unity-sqlite使用教程</a>
参照这个教程，导入相关的DLL，以及一些规定，不用使用他编写的插件，因为比较繁重，自己编写帮助类即可</p>
<p>帮助类脚本</p>
<pre><code class="language-c#">using Mono.Data.Sqlite;
using System;
using System.Collections.Generic;

namespace LFrame
{
    public class SqlHelper
    {
// 注意：连接字符串 "Data Source="+文件路径
       // public static string connStr = "";// Utils.ConfigHelper.ConnectionString;

        public static string ip;

        /// &lt;summary&gt;
        /// 尝试连接数据库
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool TryConnectDB(string connStr)
        {
            using (SqliteConnection conn = new SqliteConnection(connStr))
            {
                try
                {
                    conn.Open();
                    ip = $"数据库地址:[{conn.DataSource}]";
                    conn.Close();
                    return true;
                }
                catch (System.Exception)
                {
                    return false;
                }
            }
        }

        /// &lt;summary&gt;
        /// 执行非查询语句，如delete、insert update等 创建表等
        /// &lt;param name="sql"&gt;&lt;/param&gt;
        /// &lt;param name="sqlpars"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static int ExecuteNonQuery(string connStr,string sql, params SqliteParameter[] sqlpars)
        {
            using (SqliteConnection conn = new SqliteConnection(connStr))
            {
                conn.Open();
                using (SqliteCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = sql;
                    cmd.Parameters.AddRange(sqlpars);
                    return cmd.ExecuteNonQuery();
                }
            }
        }

        /// &lt;summary&gt;
        /// 执行只查询一行、一列的数据 当添加一条数据需要返回自增字段时也使用该函数
        /// &lt;/summary&gt;
        /// &lt;param name="sql"&gt;&lt;/param&gt;
        /// &lt;param name="sqlpars"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static object ExecuteScalar(string connStr,string sql, params SqliteParameter[] sqlpars)
        {
            using (SqliteConnection conn = new SqliteConnection(connStr))
            {
                conn.Open();
                using (SqliteCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = sql;
                    cmd.Parameters.AddRange(sqlpars);
                    return cmd.ExecuteScalar();
                }
            }
        }


        /// &lt;summary&gt;
        /// 使用事务执行多条语句
        /// &lt;/summary&gt;
        /// &lt;param name="sqlList"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool ExecuteTransaction(string connStr,List&lt;string&gt; sqlList)
        {
            using (SqliteConnection conn = new SqliteConnection(connStr))
            {
                conn.Open();
                using (SqliteTransaction tran = conn.BeginTransaction())
                {
                    using (SqliteCommand cmd = conn.CreateCommand())
                    {
                        cmd.Transaction = tran;
                        try
                        {
                            foreach (var sql in sqlList)
                            {
                                cmd.CommandType = System.Data.CommandType.Text;
                                cmd.CommandText = sql;
                                cmd.ExecuteNonQuery();
                            }

                            tran.Commit();//提交事务
                            return true;
                        }
                        catch (Exception)
                        {
                            tran.Rollback();
                            return false;
                        }
                    }
                }

            }
        }

        /// &lt;summary&gt;
        /// 查询多个数据，返回的是一个DataTable,并且该结果集是保存在本地的
        /// &lt;/summary&gt;
        /// &lt;param name="sql"&gt;&lt;/param&gt;
        /// &lt;param name="sqlpars"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static System.Data.DataTable ExecuteDataTable(string connStr,string sql, params SqliteParameter[] sqlpars)
        {
            using (SqliteConnection conn = new SqliteConnection(connStr))
            {
                conn.Open();
                using (SqliteCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = sql;
                    cmd.Parameters.AddRange(sqlpars);
                    SqliteDataAdapter adp = new SqliteDataAdapter(cmd);
                    System.Data.DataSet dataset = new System.Data.DataSet();
                    adp.Fill(dataset);
                    return dataset.Tables[0];
                }
            }
        }

        /// &lt;summary&gt;
        /// 表格是否存在
        /// &lt;/summary&gt;
        /// &lt;param name="tableName"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool ExistTable(string connStr, string tableName)
        {
            string sql = $"SELECT COUNT(*) FROM sqlite_master where type='table' and name='{tableName}';";
            int result = System.Convert.ToInt32(ExecuteScalar(connStr, sql));
            return (result &gt; 0);
        }



        /// &lt;summary&gt;
        /// 获取某类型的表的集合
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static List&lt;string&gt; GetTableListByType(string connStr,string tableType)
        {
            List&lt;string&gt; list = new List&lt;string&gt;();
            string sql = "select * from INFORMATION_SCHEMA.TABLES";
            System.Data.DataTable schemaTables = SqlHelper.ExecuteDataTable(connStr,sql);
            foreach (System.Data.DataRow dr in schemaTables.Rows)
            {
                string tableName = dr["TABLE_NAME"].ToString();
                if (tableName.StartsWith(tableType) &amp;&amp; !tableName.Contains("#"))
                {
                    list.Add(tableName);
                }
            }
            return list;
        }

        /// &lt;summary&gt;
        /// 创建表
        /// &lt;/summary&gt;
        /// &lt;param name="sql"&gt;如："CREATE TABLE myTable (myId INTEGER CONSTRAINT PKeyMyId PRIMARY KEY, myName CHAR(50), myAddress CHAR(255), myBalance FLOAT)"&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static int CreateTable(string connStr,string sql)
        {
            using (SqliteConnection conn = new SqliteConnection(connStr))
            {
                conn.Open();
                using (SqliteCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = sql;
                    return cmd.ExecuteNonQuery();
                }
            }
        }

        /// &lt;summary&gt;
        /// 事务操作
        /// &lt;/summary&gt;
        /// &lt;param name="sqlTrans"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static bool TransactionOp(string connStr,string[] sqlTrans)
        {
            // 事务成功返回true，事务失败返回false  
            bool result = false;
            SqliteConnection cn = new SqliteConnection(connStr);
            SqliteCommand cmd = new SqliteCommand();
            SqliteTransaction transaction = null;
            try
            {
                // 打开数据库  
                if (cn.State == System.Data.ConnectionState.Closed)
                {
                    cn.Open();
                }

                // 开始事务  
                transaction = cn.BeginTransaction();
                cmd.Transaction = transaction;
                cmd.Connection = cn;

                //遍历所有的sql语句
                if (sqlTrans != null &amp;&amp; sqlTrans.Length &gt; 0)
                {
                    foreach (var sql in sqlTrans)
                    {
                        // 执行第一条SQL语句  
                        cmd.CommandType = System.Data.CommandType.Text;
                        cmd.CommandText = sql;
                        if (cmd.ExecuteNonQuery() &lt; 0)
                            throw new Exception();
                    }
                }

                // 提交事务  
                transaction.Commit();
                result = true;
            }
            catch
            {
                result = false;
                // 回滚事务  
                transaction.Rollback();
            }
            finally
            {
                // 关闭数据库  
                if (cn.State == System.Data.ConnectionState.Open)
                {
                    cn.Close();
                }
                cn.Dispose();
                cmd.Dispose();
                transaction.Dispose();
            }
            return result;
        }

    }

}

</code></pre>
<h2 id="unity2021及之后版本"><a class="header" href="#unity2021及之后版本">Unity2021及之后版本</a></h2>
<p>在这个版本之后，官方已经给出了ORM框架来实现，可以自己定义实体，操作起来比较方便了。
博客园：https://www.cnblogs.com/Lulus/p/16414538.html
官网：https://docs.unity3d.com/Packages/com.unity.visualscripting@1.7/api/Unity.VisualScripting.Dependencies.Sqlite.SQLiteConnection.html</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="第一人称控制跳跃时角色一直往天上飞"><a class="header" href="#第一人称控制跳跃时角色一直往天上飞">第一人称控制，跳跃时，角色一直往天上飞</a></h2>
<p>角色模型加了碰撞体，角色节点要设置为 postprocessing 层级，如下图所示</p>
<p><img src="unity/packages/image/StarterAssets/1718094417048.png" alt="1718094417048" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addressables"><a class="header" href="#addressables">Addressables</a></h1>
<h2 id="使用说明"><a class="header" href="#使用说明">使用说明</a></h2>
<p>https://blog.csdn.net/linxinfa/article/details/122390621?spm=1001.2014.3001.5501</p>
<h2 id="addressablesgroups-窗口"><a class="header" href="#addressablesgroups-窗口">AddressablesGroups 窗口</a></h2>
<h3 id="注意事项-3"><a class="header" href="#注意事项-3">注意事项</a></h3>
<ol>
<li>
<p>不用时关闭它，当打开状态下，选中场景中的对象，对属性面板进行改动时，会导致取消对场景中对象的选中</p>
</li>
<li>
<p>调试android时，当我们仅更改代码，勾选 scripts only build 以加快发布，不要卸载手机上的应用，因为资源不会再重新构建</p>
</li>
</ol>
<h2 id="unity代码剥离导致resourcemanagerruntimedata为空"><a class="header" href="#unity代码剥离导致resourcemanagerruntimedata为空">Unity代码剥离导致ResourceManagerRuntimeData为空</a></h2>
<p>Unity代码剥离为High，代码剥离，但我们遇到了 Addressables 包的问题。由于使用反射，ProviderOperation 被剥离。导致ResourceManagerRuntimeData为空</p>
<p>大概报错如下：</p>
<pre><code class="language-txt">MissingMethodException: Default constructor not found for type UnityEngine.ResourceManagement.AsyncOperations.ProviderOperation`1[[UnityEngine.AddressableAssets.Initialization.ResourceManagerRuntimeData, Unity.Addressables, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]
  at System.RuntimeType.CreateInstanceMono (System.Boolean nonPublic) [0x0007b] in &lt;71d402037f2643fe94cabbbe0d22d04d&gt;:0
  at System.RuntimeType.CreateInstanceSlow (System.Boolean publicOnly, System.Boolean skipCheckThis, System.Boolean fillCache, System.Threading.StackCrawlMark&amp; stackMark) [0x00009] in &lt;71d402037f2643fe94cabbbe0d22d04d&gt;:0
  at System.RuntimeType.CreateInstanceDefaultCtor (System.Boolean publicOnly, System.Boolean skipCheckThis, System.Boolean fillCache, System.Threading.StackCrawlMark&amp; stackMark) [0x00027] in &lt;71d402037f2643fe94cabbbe0d22d04d&gt;:0
  at System.Activator.CreateInstance (System.Type type, System.Boolean nonPublic) [0x00020] in &lt;71d402037f2643fe94cabbbe0d22d04d&gt;:0
  at System.Activator.CreateInstance (System.Type type) [0x00000] in &lt;71d402037f2643fe94cabbbe0d22d04d&gt;:0
  at UnityEngine.ResourceManagement.Util.LRUCacheAllocationStrategy.New (System.Type type, System.Int32 typeHash) [0x00055] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\ResourceManager\Util\ResourceManagerConfig.cs:134
  at UnityEngine.ResourceManagement.ResourceManager.CreateOperation[T] (System.Type actualType, System.Int32 typeHash, System.Int32 operationHash, System.Action`1[T] onDestroyAction) [0x00032] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\ResourceManager\ResourceManager.cs:358
  at UnityEngine.ResourceManagement.ResourceManager.ProvideResource (UnityEngine.ResourceManagement.ResourceLocations.IResourceLocation location, System.Type desiredType) [0x000d1] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\ResourceManager\ResourceManager.cs:260
  at UnityEngine.ResourceManagement.ResourceManager.ProvideResource[TObject] (UnityEngine.ResourceManagement.ResourceLocations.IResourceLocation location) [0x00001] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\ResourceManager\ResourceManager.cs:287
  at UnityEngine.AddressableAssets.Initialization.InitializationOperation.CreateInitializationOperation (UnityEngine.AddressableAssets.AddressablesImpl aa, System.String playerSettingsLocation, System.String providerSuffix) [0x0009a] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\Initialization\InitializationOperation.cs:42
  at UnityEngine.AddressableAssets.AddressablesImpl.InitializeAsync (System.String runtimeDataPath, System.String providerSuffix) [0x0008d] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\AddressablesImpl.cs:280
  at UnityEngine.AddressableAssets.AddressablesImpl.InitializeAsync () [0x00013] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\AddressablesImpl.cs:289
  at UnityEngine.AddressableAssets.AddressablesImpl.get_InitializationOperation () [0x00013] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\AddressablesImpl.cs:306
  at UnityEngine.AddressableAssets.AddressablesImpl.LoadContentCatalogAsync (System.String catalogPath, System.String providerSuffix) [0x0004c] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\AddressablesImpl.cs:296
  at UnityEngine.AddressableAssets.Addressables.LoadContentCatalogAsync (System.String catalogPath, System.String providerSuffix) [0x00001] in D:\Project\Designer\Designer\Library\PackageCache\com.unity.addressables@1.1.9\Runtime\Addressables.cs:231
  at Ubiant.Common.Adressables.AddressablesLoader+&lt;InitializeAddressables&gt;d__2.MoveNext () [0x00020] in D:\Project\Designer\Designer\Assets\Scripts\Runtime\Addressables\AddressablesLoader.cs:49
  at UnityEngine.SetupCoroutine.InvokeMoveNext (System.Collections.IEnumerator enumerator, System.IntPtr returnValueAddress) [0x00027] in &lt;1cc3984764e64bdeb5a66b5d2a3bc7e1&gt;:0
UnityEngine.MonoBehaviour:StartCoroutineManaged2(IEnumerator)
UnityEngine.MonoBehaviour:StartCoroutine(IEnumerator)
</code></pre>
<p>解决方案：</p>
<p>在Assets文件夹里面添加 link.xml文件，内容如下：</p>
<pre><code class="language-xml">
 
&lt;linker&gt;
    &lt;assembly fullname="Unity.ResourceManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null" preserve="all"&gt;
    &lt;type fullname="UnityEngine.ResourceManagement.ResourceProviders.LegacyResourcesProvider" preserve="all" /&gt;
    &lt;type fullname="UnityEngine.ResourceManagement.ResourceProviders.AssetBundleProvider" preserve="all" /&gt;
    &lt;type fullname="UnityEngine.ResourceManagement.ResourceProviders.BundledAssetProvider" preserve="all" /&gt;
    &lt;type fullname="UnityEngine.ResourceManagement.ResourceProviders.InstanceProvider" preserve="all" /&gt;
    &lt;type fullname="UnityEngine.ResourceManagement.AsyncOperations" preserve="all" /&gt;
    &lt;/assembly&gt;
    &lt;assembly fullname="Unity.Addressables, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null" preserve="all"&gt;
    &lt;type fullname="UnityEngine.AddressableAssets.Addressables" preserve="all" /&gt;
    &lt;/assembly&gt;
&lt;/linker&gt;
</code></pre>
<p>若项目中已经存在 <code>link.xml</code> 直接追加即可。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://discussions.unity.com/t/addressables-and-code-stripping-il2cpp/748486">CSDN：Unity代码剥离导致ResourceManagerRuntimeData为空</a></li>
<li><a href="https://discussions.unity.com/t/addressables-and-code-stripping-il2cpp/748486">Unity 社区：addressables and code stripping il2cpp</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="终极曲线解决方案"><a class="header" href="#终极曲线解决方案">终极曲线解决方案</a></h1>
<h2 id="文档"><a class="header" href="#文档">文档</a></h2>
<ul>
<li><a href="https://curvyeditor.com/documentation/start">官方文档</a>，edge浏览器有时不能翻译为中文，使用google浏览器翻译中文，结合英文阅读比较好</li>
</ul>
<h2 id="列车控制"><a class="header" href="#列车控制">列车控制</a></h2>
<ul>
<li>
<p>列车组件：TrainManager，依赖组件：CurvySpine(轨道路径)</p>
</li>
<li>
<p>车厢组件：CarManager</p>
</li>
<li>
<p>列车由车厢和贯通道的遮蓬拼接而成，实际控制的是车厢，贯通到根据两个切面自动跟随绑定的车厢运动</p>
</li>
<li>
<p>运行原理：控制每个车厢在轨道上的距离，根据当前列车速度计算出单位时间上的距离，更新列车位置</p>
</li>
<li>
<p>列车启动：列车状态变为加速状态，列车速度为0变为列车运行最大速度，列车状态更新为匀速状态，此时，列车不再加速</p>
</li>
<li>
<p>列车刹车：列车状态变为刹车状态，刹车是从当前速度，直到速度为0，列车状态更新为None，此时需要一个刹车距离来求得需要多大的加速度，</p>
</li>
<li>
<p>列车停车：列车状态变为None状态，列车的速度立即设置为0，列车停在当前位置</p>
</li>
<li>
<p>切换运行方向：调换运行方向，切换控制组件的Direction属性，同时切换检测刚体</p>
</li>
<li>
<p>列车检测刚体：在列车的头尾各有一个检测刚体，用于检测轨道上的“刹车触发器”和“停车触发器”，列车上行运行时启用上行检测刚体，下行运行时启用下行检测刚体</p>
</li>
</ul>
<p>注意事项，列车的根节点不会产生位移，只有根节点下的车厢节点会产生移动</p>
<h2 id="连接点"><a class="header" href="#连接点">连接点</a></h2>
<p>应用场景：轨道道岔切换</p>
<h3 id="创建连接点"><a class="header" href="#创建连接点">创建连接点</a></h3>
<ul>
<li>
<p>官网文档 https://curvyeditor.com/documentation/splines/connections</p>
</li>
<li>
<p>简要创建举例</p>
</li>
</ul>
<p>创建：</p>
<p><img src="unity/packages/image/CurvySpine/1718094508590.png" alt="1718094508590" /></p>
<p>结果：</p>
<p><img src="unity/packages/image/CurvySpine/1718094532126.png" alt="1718094532126" /></p>
<h3 id="连接点控制"><a class="header" href="#连接点控制">连接点控制</a></h3>
<p>https://curvyeditor.com/documentation/splines/connections</p>
<p>使用连接组件，可设置到达连接点后，运行路径</p>
<p><strong>官方文档描述：</strong></p>
<p>仅样条控制器。</p>
<p>这允许您指定样条控制器在到达连接时应如何移动。您可以设置以下行为之一：</p>
<ul>
<li>
<p>当前文本样条线：控制器将继续在当前样条线上移动，就好像没有连接一样。</p>
</li>
<li>
<p>Follow Up Spline：控制器将继续在包含 Follow-Up 的样条线上移动（如果有），否则将继续在当前样条线上移动。</p>
</li>
<li>
<p>随机样条线：控制器继​​续在随机选择的连接样条线之一上移动。</p>
</li>
<li>
<p>Follow Up 否则 Random：控制器将继续在包含 Follow-Up 的样条线上移动（如果有的话），否则将继续在随机选择的连接样条线之一上移动。</p>
</li>
<li>
<p>自定义：定义您自己的连接样条线选择逻辑。您可以通过分配具有继承自 ConnectedControlPointsSelector 的组件的 GameObject 来实现此目的。</p>
</li>
</ul>
<h3 id="道岔控制的应用"><a class="header" href="#道岔控制的应用">道岔控制的应用</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dotween"><a class="header" href="#dotween">Dotween</a></h1>
<p>官网：http://dotween.demigiant.com/</p>
<h2 id="tween-tweener"><a class="header" href="#tween-tweener">Tween （Tweener）</a></h2>
<h3 id="属性"><a class="header" href="#属性">属性</a></h3>
<h3 id="回调事件监听"><a class="header" href="#回调事件监听">回调（事件监听）</a></h3>
<ul>
<li>在补间完成时调用（包括循环）,每到达终点一次调用一次</li>
</ul>
<pre><code>public TweenCallback onComplete;
</code></pre>
<ul>
<li>暂停事件，若  autoKill set to FALSE，播放完成后触发</li>
</ul>
<pre><code>public TweenCallback onPause;
</code></pre>
<ul>
<li>播放时调用</li>
</ul>
<pre><code>public TweenCallback onPlay;
</code></pre>
<ul>
<li>onUpdate</li>
</ul>
<pre><code>public TweenCallback onUpdate;
</code></pre>
<ul>
<li>onStepComplete</li>
</ul>
<pre><code>public TweenCallback onStepComplete;
</code></pre>
<ul>
<li>onKill</li>
</ul>
<pre><code>public TweenCallback onKill;
</code></pre>
<ul>
<li>倒播到起始位置的回调，监听，注意，若 Tween 已经是倒播到起始位置，再调用倒播接口，不会触发此事件</li>
</ul>
<pre><code>public TweenCallback onRewind;
</code></pre>
<h3 id="扩展"><a class="header" href="#扩展">扩展</a></h3>
<p>补间的播放等是通过扩展里面的方法来实现的</p>
<ul>
<li>Play()</li>
</ul>
<p>播放：首次播放时使用</p>
<ul>
<li>Restart()</li>
</ul>
<p>重新启动：再次播放时使用</p>
<ul>
<li>PlayBackwards()</li>
</ul>
<p>倒播：回退补间时使用</p>
<h2 id="案例-1"><a class="header" href="#案例-1">案例</a></h2>
<p><strong>实现一个侧边目录窗口，点击按钮，从左侧往右出现，并停住，点击关闭按钮，回退回去</strong></p>
<p>代码</p>
<pre><code>         [SerializeField] GameObject flowBtnGameobject; //打开面板的按钮

         [SerializeField] RectTransform showStopPos;// 面板目标位置
        
         Tweener teachFlowTweener;//流程面板动画
         /// &lt;summary&gt;
         /// 打开教学目录
         /// &lt;/summary&gt;
         public void OnClickTeachCatalogue()   
         {
             if (teachFlowTweener == null)//为空，首次播放
             {                                
                 //teachFlowPlane.ShowUpdateStep(gameModel.timelineStepId.Value);//TODO:面板显示逻辑处理,替换为自己的
                 teachFlowTweener = teachFlowPlane.transform.DOMoveX(showStopPos.position.x, 0.5f).SetAutoKill(false).SetEase(Ease.InOutFlash).Pause(); //首次播放
                 teachFlowTweener.Play();
                 teachFlowTweener.onRewind += onRewindHandler; //监听倒播结束事件，为了显示打开面板的按钮
             }
             else
             {
                 if (teachFlowTweener.IsPlaying()) return;
                //teachFlowPlane.ShowUpdateStep(gameModel.timelineStepId.Value);//TODO:面板显示逻辑处理,替换为自己的
                 teachFlowTweener.Restart();//重新启动 和 play 同效果
             }
             flowBtnGameobject.SetActive(false); //隐藏按钮
        
         }
        //关闭面板的方法
        public void OnCloseFlowPanel()
        {
            if (teachFlowTweener.IsPlaying()) return;
            teachFlowTweener.PlayBackwards();//倒播关闭

        }
   

        //面板回到初始位置后调用
        private void onRewindHandler()
        {
            flowBtnGameobject.SetActive(true);//显示打开按钮
        }

        private void OnDestroy()
        {
            teachFlowTweener.onComplete -= onRewindHandler; //删除监听

        }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<ol>
<li>软件刚启动时，执行某个 Save 操作，但是文件夹中未发现序列化成功，很奇怪，目前解决方法是，在之后的某个操作后进行Save</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>https://github.com/egametang/ET</p>
<p>https://www.taikr.com/goods/show/554?targetId=1053&amp;preview=0</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>Unity 新的输入系统</p>
</blockquote>
<h3 id="使用说明-1"><a class="header" href="#使用说明-1">使用说明</a></h3>
<h4 id="插件设置"><a class="header" href="#插件设置">插件设置</a></h4>
<p>（1） InputSystemPackage 设置界面，需要设置为 Dynamic Update模式，这样操作虚拟控件时才不卡顿</p>
<p><img src="unity/packages/image/InputSystemPackage/1718094580288.png" alt="1718094580288" /></p>
<p>（2）FirstPersionController，第一人称控制器，目前</p>
<p><img src="unity/packages/image/InputSystemPackage/1718094594239.png" alt="1718094594239" /></p>
<h3 id="问题和解决方案"><a class="header" href="#问题和解决方案">问题和解决方案</a></h3>
<h4 id="bangbang-type-of-instance-in-array-does-not-match-expected-type"><a class="header" href="#bangbang-type-of-instance-in-array-does-not-match-expected-type">:bangbang: <font color=#FF0000>Type of instance in array does not match expected type</font></a></h4>
<p><strong>现象</strong>
当退出游戏的时候会出现这个报错</p>
<p><strong>解决办法</strong>
<a href="https://forum.unity.com/threads/type-of-instance-in-array-does-not-match-expected-type.1320564/">InputSystem社区</a>
回退到 1.3.0 版本</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>学习任何一个插件，最好的方式就是去仔细阅读它的官方文档，先原文（英语）阅读一遍，然后再阅读译文，一遍不够，再来一遍！！！</p>
</blockquote>
<h1 id="magiconion"><a class="header" href="#magiconion">MagicOnion</a></h1>
<blockquote>
<p>知识无国界，作者是一个日本大佬，非常崇拜，Unitask,MemoryPack 等都是它写的</p>
</blockquote>
<p>官网：https://github.com/Cysharp/MagicOnion, 原为阅读和翻译阅读</p>
<p>我认为最合适的轻便服务器，提供RPC,实时通信，用在WPF unity上都不错，WPF或者.net的桌面端开发看官网文档就行了，下面主要记录Unity方面的开发</p>
<h1 id="unity开发过程"><a class="header" href="#unity开发过程">Unity开发过程</a></h1>
<h2 id="项目说明"><a class="header" href="#项目说明">项目说明</a></h2>
<p>使用此框架实现一个 <code>CS</code> 架构的系统</p>
<ol>
<li>工程目录结构设计,项目文件夹结构如下，便于后期的插件注册</li>
</ol>
<pre><code class="language-txt">
- TSIM.Server //服务器解决方案
    TSIM.Server //服务器项目
    TSIM.Shared //共享接口库
+ TSIM.Unity //Unity项目

</code></pre>
<p><strong>Server项目</strong></p>
<ol>
<li>
<p>创建 AspNetCore.APP空项目(net7.0)</p>
</li>
<li>
<p>在Nuget下载包：</p>
</li>
</ol>
<ul>
<li>
<p>MagicOnion.Server</p>
</li>
<li>
<p>Grpc.AspNetCore</p>
</li>
</ul>
<ol start="3">
<li>版本管理：gitee,国内最大的开源版本库（适合非游戏类型的工程管理）</li>
</ol>
<p><strong>Shared项目</strong></p>
<ol>
<li>
<p>创建 库项目 (netstandard2.0)，2.1 grpc没有支持</p>
</li>
<li>
<p>在Nuget下载包：</p>
</li>
</ol>
<ul>
<li>
<p>MagicOnion.Abstractions</p>
</li>
<li>
<p>MagicOnion.Shared</p>
</li>
<li>
<p>MessagePack.UnityShims：这个是对Unity的支持，提供了Unity里面的结构类型</p>
</li>
</ul>
<p><strong>Unity项目</strong></p>
<ol>
<li>
<p>Unity 版本： Unity2022</p>
</li>
<li>
<p>版本管理：svn,(群晖上自建的SVN服务器)</p>
</li>
</ol>
<h2 id="项目搭建过程"><a class="header" href="#项目搭建过程">项目搭建过程</a></h2>
<h3 id="magiconion-unitypackge-包使用"><a class="header" href="#magiconion-unitypackge-包使用">MagicOnion UnityPackge 包使用</a></h3>
<p>该包在发布版本下载UnityPackge ，导入到Unity项目中</p>
<p>https://github.com/cysharp/MagicOnion/releases</p>
<h3 id="grpc-library-for-unity-client"><a class="header" href="#grpc-library-for-unity-client">Grpc library for Unity client</a></h3>
<p>Grpc 在 netstandard2.0 时候，提供了对Unity的支持，但是当出现跨平台的 .net 之后，就移除对Unity的支持了，MagicOnion的作者正在实现这部分的支持。</p>
<p>目前的处理方式，通过MagicOnion 案例中的 Unity项目，复制拷贝过来</p>
<p><strong>问题</strong></p>
<ul>
<li>
<p>开发环境：Mac M1，在Window上正常，mac上不正常</p>
</li>
<li>
<p>Unity版本：2023.1.4f1c1 silicon</p>
</li>
<li>
<p>错误信息</p>
</li>
</ul>
<pre><code>DllNotFoundException: grpc_csharp_ext assembly:&lt;unknown assembly&gt; type:&lt;unknown type&gt; member:(null)
</code></pre>
<p><strong>解决过程</strong></p>
<ul>
<li>相关问题的连接</li>
</ul>
<p>https://github.com/grpc/grpc/issues/30068</p>
<p>https://github.com/grpc/grpc/issues/25223</p>
<ul>
<li>
<p>简要说明：就是grpc 不支持 unity 了，他们觉得维护成本很高，不再支持， unity intel 版本不存在问题，但是 silicon 版本可能缺少本机库的支持</p>
</li>
<li>
<p>nugetforunity 不是官方出品，即使使用这个插件将nuget里面的包倒入unity ，可能存在问题。</p>
</li>
<li>
<p>最好的状态：就是magiconion作者大佬，实现支持，期待中</p>
</li>
</ul>
<h3 id="messagepack-1"><a class="header" href="#messagepack-1">MessagePack</a></h3>
<p>下载地址</p>
<p>https://github.com/neuecc/MessagePack-CSharp#unity</p>
<h3 id="magiconion-code-generator-for-il2cpp"><a class="header" href="#magiconion-code-generator-for-il2cpp">MagicOnion code generator (for IL2CPP)</a></h3>
<p>MagicOnion 默认仅支持UnityEditor 或者 非 IL2CPP，也就是不能发布：windows-il2cpp、 安卓、苹果这些版本，显然是不行的。如果要支持还需要做其他的工作，将我们的Shared项目生产客户端并且注册到Unity项目，生成客户端们这里分别对 MessagePack 和 MagicOnion 都要操作</p>
<p><strong>准备工作</strong></p>
<ol>
<li>
<p>安装 dotnetcore3 runtime,这里下载3.1就可以了</p>
</li>
<li>
<p>使用vs 非预览版，在使用vs2022 preview版本时，出现错误，换成非预览版正常</p>
</li>
</ol>
<p><strong>操作过程</strong></p>
<ol>
<li>安装 <strong>MessagePack.Generator</strong></li>
</ol>
<p>安装分全局安装和本地安装。</p>
<ul>
<li>全局安装</li>
</ul>
<pre><code class="language-shell">dotnet tool install --global MessagePack.Generator
</code></pre>
<ul>
<li>本地安装，在服务器解决方案的根目录，打开cmd</li>
</ul>
<p><img src="unity/packages/image/MagicOnion/1718094651927.png" alt="1718094651927" /></p>
<ul>
<li>执行下面的命令</li>
</ul>
<pre><code class="language-cmd">
dotnet new tool-manifest 
dotnet tool install MessagePack.Generator
dotnet tool install MagicOnion.Generator

</code></pre>
<ul>
<li>若提示如下错误</li>
</ul>
<pre><code>C:\Users\ABYTE\AppData\Local\Temp\8e12065c-69cb-4bf3-92cf-7fbfc1dd389c\restore.csproj : error NU1301: 无法加载源 https://dot
net.myget.org/F/roslyn/api/v3/index.json 的服务索引。
无法还原工具包。
工具“messagepack.generator”安装失败。此故障可能由以下原因导致:

* 你尝试安装预览版，但未使用 --version 选项来指定该版本。
* 已找到具有此名称的包，但是它不是 .NET 工具。
* 无法访问所需的 NuGet 源，这可能是由于 Internet 连接问题导致。
* 工具名称输入错误。

有关更多原因(包括强制包命名)，请访问 https://aka.ms/failure-installing-tool
</code></pre>
<ul>
<li>提示我们需要指定一个版本，通过 <code>dotnet tool search 包名</code> 来搜索包</li>
</ul>
<pre><code class="language-cmd">F:\000-TZJ\TSIM\MagicOnion-main\samples\ChatApp&gt;dotnet tool search messagepack.generator
包 ID                       最新版本         作者                  下载          已验证
---------------------------------------------------------------------------
messagepack.generator      2.5.124      neuecc,aarnott      100885
tapper.generator           1.8.3        nenoNaninu          6792
</code></pre>
<ul>
<li>安装指定版本的包</li>
</ul>
<pre><code class="language-shell">dotnet tool install messagepack.generator --version 2.5.124
</code></pre>
<ul>
<li>查看命令信息</li>
</ul>
<pre><code class="language-shell">dotnet mpc 
</code></pre>
<ul>
<li>安装 <code>mpc</code> 和 <code>moc</code> 的截图信息</li>
</ul>
<p><img src="unity/packages/image/MagicOnion/1718094674431.png" alt="1718094674431" /></p>
<ul>
<li>json文件</li>
</ul>
<p><img src="unity/packages/image/MagicOnion/1718094681088.png" alt="1718094681088" /></p>
<ol>
<li>根据命令提示，配置Shared项目</li>
</ol>
<pre><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;   
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="MagicOnion.Abstractions" Version="5.1.8" /&gt;
    &lt;PackageReference Include="MagicOnion.Shared" Version="5.1.8" /&gt;
    &lt;PackageReference Include="MessagePack.UnityShims" Version="2.5.124" /&gt;
  &lt;/ItemGroup&gt;

	&lt;Target Name="RestoreLocalTools" BeforeTargets="GenerateMessagePack;GenerateMagicOnion"&gt;
		&lt;Exec Command="dotnet tool restore" /&gt;
	&lt;/Target&gt;
	&lt;Target Name="GenerateMessagePack" AfterTargets="Build"&gt;
		&lt;PropertyGroup&gt;
			&lt;_MessagePackGeneratorArguments&gt;-i ./TSIM.Shared.csproj -o ../../TSIM.Unity/Assets/Scripts/Generated/MessagePack.Generated.cs&lt;/_MessagePackGeneratorArguments&gt;
		&lt;/PropertyGroup&gt;
		&lt;Exec Command="dotnet tool run mpc $(_MessagePackGeneratorArguments)" /&gt;
	&lt;/Target&gt;
	&lt;Target Name="GenerateMagicOnion" AfterTargets="Build"&gt;
		&lt;PropertyGroup&gt;
			&lt;_MagicOnionGeneratorArguments&gt;-i ./TSIM.Shared.csproj -o ../../TSIM.Unity/Assets/Scripts/Generated/MagicOnion.Generated.cs&lt;/_MagicOnionGeneratorArguments&gt;
		&lt;/PropertyGroup&gt;
		&lt;Exec Command="dotnet tool run dotnet-moc $(_MagicOnionGeneratorArguments)" /&gt;
	&lt;/Target&gt;
&lt;/Project&gt;

</code></pre>
<p>注意：<strong>TSIM.Unity/Assets/Scripts/Generated/MagicOnion.Generated.cs</strong> 此路径要对应Unity项目和Shared项目的相对路径，应该也可以写绝对路径，目的就是将 Shared项目 生成到 Unity项目中</p>
<ol start="3">
<li>上面将 Shared项目生成客户端，下面将注册到Unity中</li>
</ol>
<p>在unity项目中新建脚本InitialSettings，下面的脚本包含了注册，以及Grpc的通道设置（且是必须的）</p>
<pre><code>using System.IO;
using Grpc.Core;
#if USE_GRPC_NET_CLIENT
using Grpc.Net.Client;
#endif
using MagicOnion.Unity;
using MessagePack;
using MessagePack.Resolvers;
using UnityEngine;

namespace Assets.Scripts
{
    class InitialSettings
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        static void RegisterResolvers()
        {
            // NOTE: Currently, CompositeResolver doesn't work on Unity IL2CPP build. Use StaticCompositeResolver instead of it.
            StaticCompositeResolver.Instance.Register(
                MagicOnion.Resolvers.MagicOnionResolver.Instance,
                MessagePack.Resolvers.GeneratedResolver.Instance,
                BuiltinResolver.Instance,
                PrimitiveObjectResolver.Instance
            );
        
            MessagePackSerializer.DefaultOptions = MessagePackSerializer.DefaultOptions
                .WithResolver(StaticCompositeResolver.Instance);
        }

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void OnRuntimeInitialize()
        {
            // Initialize gRPC channel provider when the application is loaded.
            GrpcChannelProviderHost.Initialize(new DefaultGrpcChannelProvider(new GrpcCCoreChannelOptions(new[]
            {
                // send keepalive ping every 5 second, default is 2 hours
                new ChannelOption("grpc.keepalive_time_ms", 5000),
                // keepalive ping time out after 5 seconds, default is 20 seconds
                new ChannelOption("grpc.keepalive_timeout_ms", 5 * 1000),
            })));

            // NOTE: If you want to use self-signed certificate for SSL/TLS connection
            //var cred = new SslCredentials(File.ReadAllText(Path.Combine(Application.streamingAssetsPath, "server.crt")));
            //GrpcChannelProviderHost.Initialize(new DefaultGrpcChannelProvider(new GrpcCCoreChannelOptions(channelCredentials: cred)));

            // Use Grpc.Net.Client instead of C-core gRPC library.
            //GrpcChannelProviderHost.Initialize(new GrpcNetClientGrpcChannelProvider(new GrpcChannelOptions() { HttpHandler = ... }));
        }
    }
}

</code></pre>
<h2 id="unity端使用共享库"><a class="header" href="#unity端使用共享库">Unity端使用共享库</a></h2>
<p>服务端可以通过项目引用直接使用共享库，但是Unity端因为依赖不同不能直接使用共享库dll,需要直接使用共享库的源代码，官方的解决方案是，通过 源码链接来实现，没搞懂，直接将代码考本到Unity，作为一个本地包来导入</p>
<ol>
<li>在 Unity项目的 Pacakges 文件夹下，创建  <strong>TSIM.Shared</strong>  文件夹（TSIM 是我的项目名称），创建  <strong>package.json</strong>  和 程序定义文件  <strong>TSIM.Shared.Unity.asmdef</strong></li>
</ol>
<p>package.json</p>
<pre><code class="language-json">{
  "name": "com.abyte.tsim.shared.unity",
  "version": "1.0.0",
  "displayName": "TSIM.Shared.Unity",
  "description": "服务端-客户端共享源文件，由于MessagePack所依赖的库不同，不能使用dll，处理方式在服务端写完后，拷贝到Unity",
  "unity": "2020.3"
}
</code></pre>
<h2 id="问题和处理"><a class="header" href="#问题和处理">问题和处理</a></h2>
<h3 id="其他电脑连接服务器失败"><a class="header" href="#其他电脑连接服务器失败">其他电脑连接服务器失败</a></h3>
<p>确保服务器的配置为 0.0.0.0，表示监听所有IP的连接</p>
<pre><code>{
  "Kestrel": {
    "Endpoints": {
      "Grpc": {
        "Url": "http://0.0.0.0:7000",
        "Protocols": "Http2"
      },
      "Https": {
        "Url": "https://0.0.0.0:7001",
        "Protocols": "Http1AndHttp2"
      },
      "Http": {
        "Url": "http://0.0.0.0:7002",
        "Protocols": "Http1"
      }
    }
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

</code></pre>
<h3 id="安卓端打包错误-找不到grpc_csharp_extdll"><a class="header" href="#安卓端打包错误-找不到grpc_csharp_extdll">安卓端打包错误 找不到grpc_csharp_ext.dll</a></h3>
<ul>
<li>
<p>Unity版本：Unity2022 / Unity2023</p>
</li>
<li>
<p>设置：IL2CPP  ARM64</p>
</li>
</ul>
<p><img src="unity/packages/image/MagicOnion/1718094706135.png" alt="1718094706135" /></p>
<p><strong>原因：</strong></p>
<p>DLL文件设置需要根据项目设置同步调整</p>
<p><img src="unity/packages/image/MagicOnion/1718094712023.png" alt="1718094712023" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nativefileso"><a class="header" href="#nativefileso">Nativefileso</a></h1>
<blockquote>
<p>商店资源</p>
</blockquote>
<blockquote>
<p>！！注意：插件已经停止更新，Unity 商店已经下架</p>
</blockquote>
<ul>
<li>
<p><a href="https://assetstore.unity.com/packages/tools/integration/native-share-for-android-ios-112731">商店地址</a></p>
</li>
<li>
<p><a href="https://assetstore.unity.com/packages/tools/integration/native-share-for-android-ios-112731">Github地址，使用教程</a></p>
</li>
</ul>
<p>发布 <code>Android</code> 和 <code>IOS</code> 需要不同的设置，参考教程</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nativefileso-1"><a class="header" href="#nativefileso-1">Nativefileso</a></h1>
<blockquote>
<p>Github 上的资源</p>
<p>功能：跨平台的文件操作插件，是一个国外大牛在github上的unity插件，提供调用应用程序分享功能，如：微信分享，你不用去注册微信的开放平台。直接可以分享到微信，钉钉等。非常强大</p>
</blockquote>
<h2 id="说明-1"><a class="header" href="#说明-1">说明</a></h2>
<p><a href="https://github.com/keiwando/nativefileso">仓库地址</a></p>
<p>注意事项：</p>
<ol>
<li>在发布安卓端时，删除掉 Mac os, IOS对应的插件，否则打包会报错</li>
<li>Windows 发布， 提示 .forms.dll 警告</li>
</ol>
<p>最后说明：使用起来不是很满意，用 Unity商城里面的 <a href="https://assetstore.unity.com/packages/tools/integration/native-share-for-android-ios-112731">NativeShare</a> 代替</p>
<h2 id="android-设置"><a class="header" href="#android-设置">Android 设置</a></h2>
<p>NativeShare 不再需要在 Android 上进行任何手动设置。如果您使用的是旧版本的插件，则需要&lt;provider ... /&gt;从AndroidManifest.xml中删除 NativeShare 。</p>
<p>作为参考，旧文档可在以下位置找到：https：//github.com/yasirkula/UnityNativeShare/wiki/Manual-Setup-for-Android</p>
<h2 id="ios-设置"><a class="header" href="#ios-设置">iOS 设置</a></h2>
<p>有两种方法可以在 iOS 上设置插件：</p>
<p>a. 自动设置：在Unity中（ 可选）在项目设置/yasirkula/Native Share中勾选自动设置，并添加更改照片库使用说明描述：“该应用程序需要访问照片才能将媒体保存到其中”
b. 手动设置：参见：https://github.com/yasirkula/UnityNativeShare/wiki/Manual-Setup-for-iOS</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newtonsoft"><a class="header" href="#newtonsoft">Newtonsoft</a></h1>
<ul>
<li>功能：json序列化工具</li>
<li>注意事项：必须使用 for unity 版本的，否则在打包时（特别是打包il2cpp）会报错</li>
</ul>
<p>github:https://github.com/SaladLab/Json.Net.Unity3D
下载：https://github.com/SaladLab/Json.Net.Unity3D/releases
保险起见，下载这个完整的包</p>
<p>版本后续可能会更新，下载最新的即可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-uiwidgets"><a class="header" href="#new-uiwidgets">New UIWidgets</a></h1>
<blockquote>
<p>UI插件，功能模板非常强大</p>
<ul>
<li>提供了大量的容器组件，如列表，树等</li>
<li>容器组件支持拖拽，但是此时鼠标按下内容区域无法滚动视图，若需要滚动，移除支持拖拽的组件</li>
<li>支持定位，如打开面板的时候希望定位到某个位置，Unity内置功能里面很垃圾，搞了半天，效果不好，这个组件里提供了方便的接口，如定位到我选择的item的位置，定位到最后等，注意定位到最后的位置并不是1，需要求出最后一个item的位置</li>
</ul>
</blockquote>
<h2 id="textmeshpro_ugui的支持"><a class="header" href="#textmeshpro_ugui的支持">TextMeshPro_UGUI的支持</a></h2>
<p>若要对TMPRO_UGUI的支持，需要添加 脚本定义符号</p>
<pre><code class="language-xml">UIWIDGETS_TMPRO_SUPPORT
</code></pre>
<h2 id="添加自定义程序集"><a class="header" href="#添加自定义程序集">添加自定义程序集</a></h2>
<p>当项目定义了不同的程序集时，如对UI相关的功能自定义了程序集，此时需要使用New UI Widgets插件，需要为New UI Widgets 添加程序集，包含运行时和编辑器两个。</p>
<ol>
<li>
<p>添加运行时程序集</p>
<ul>
<li>运行时程序集文件</li>
</ul>
<p><img src="unity/packages/image/NewUIWidgets/1721187393095.png" alt="运行时程序集文件" /></p>
<ul>
<li>运行时程序集属性，需要添加相应的依赖</li>
</ul>
<p><img src="unity/packages/image/NewUIWidgets/1721187444670.png" alt="运行时程序集属性，需要添加相应的依赖" /></p>
</li>
<li>
<p>添加编辑器程序集</p>
<ul>
<li>编辑器程序集</li>
</ul>
<p><img src="unity/packages/image/NewUIWidgets/1721187463878.png" alt="1721187463878" /></p>
<ul>
<li>编辑器程序集属性</li>
</ul>
<p><img src="unity/packages/image/NewUIWidgets/1721187474618.png" alt="1721187474618" /></p>
</li>
</ol>
<h2 id="部件生成器widgets-generator"><a class="header" href="#部件生成器widgets-generator">部件生成器(Widgets Generator)</a></h2>
<p><a href="https://ilih.name/unity-assets/UIWidgets/docs/generator.html?spm=wolaidingtalk.workspace.0.0.3d622714p3RBiF#list-of-generated-widgets">官方文档</a></p>
<h3 id="操作说明"><a class="header" href="#操作说明">操作说明</a></h3>
<p><strong>创建一个数据类，如果不需要执行数据更新，普通类即可，若需要数据更新，需要实现<code>INotifyPropertyChanged</code> 或<code> IObservable</code>，其中<code>IObservable</code>具有更少的内存分配，脚本模板如下：</strong></p>
<p>继承 <code>INotifyPropertyChanged</code> 接口示例脚本：</p>
<pre><code class="language-C#">public class ListViewIconsItemDescription : INotifyPropertyChanged
{
   [SerializeField]
   string name;
   public string Name
   {
      get
      {
         return name;
      }
      set
      {
         if (name != value)
         {
            name = value;
            Changed("Name");
         }
      }
   }
   public event PropertyChangedEventHandler PropertyChanged;
   protected void Changed(string propertyName)
   {
      PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
   }
   ...
}
</code></pre>
<p>继承 <code>IObservable</code> 接口示例脚本：</p>
<pre><code class="language-C#">public class ListViewIconsItemDescription : IObservable
{
   [SerializeField]
   string name;
   public string Name
   {
      get
      {
         return name;
      }
      set
      {
         if (name != value)
         {
            name = value;
            Changed();
         }
      }
   }
   public event OnChange OnChange;
   protected void Changed()
   {
      OnChange?.Invoke();
   }
   ...
}
</code></pre>
<p><strong>右键脚本，创建&gt;New UI Widgets&gt;Widgets Gennerator 注意需要鼠标选中数据类右键</strong></p>
<h3 id="自定义程序集时生成部件处理"><a class="header" href="#自定义程序集时生成部件处理">自定义程序集时生成部件处理</a></h3>
<p>当使用自定义程序集时，生成部件无法创建预制体和案例场景，因为缺少对 new ui widgets Editor的引用，处理方式：为我们的程序集添加相关依赖。</p>
<p>程序集<code>TSIM.View</code> 是项目中的View层程序集，该程序集需要添加 <code>Nuw（new ui widgets 的 运行时程序集）</code>的依赖，如图所示：</p>
<p><img src="unity/packages/image/NewUIWidgets/1721188114253.png" alt="添加对Editor的依赖" /></p>
<p>当在生成部件时，由于还需要依赖编辑器里面的内容，所以还需要添加 <code>Nuw.Editor（new ui widgets 的 编辑器程序集）</code>的依赖，并在生成完成后，删除依赖，否则发布时存在问题。</p>
<p><img src="unity/packages/image/NewUIWidgets/1721188151879.png" alt="添加对Editor的依赖" /></p>
<p><strong>特别提醒：生成后删除依赖中的 Nuw.Editor</strong></p>
<h3 id="表格中item添加不参与布局的子对象"><a class="header" href="#表格中item添加不参与布局的子对象">表格中item添加不参与布局的子对象</a></h3>
<p>在生成一个排名表格的需求中，需求将自己的排名item添加一个不同的背景，于是创建了一个子对象图片组件，不参与布局，当是自己时，显示这个对象。</p>
<p>运行时表格header报错找不到子对象，header下的子对象需要和item下的数量相同。</p>
<p>在header下添加一个不参与布局的对象即可，且他们的顺序要一致。</p>
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<ol>
<li>
<p>自动选择指定条目接口：</p>
<pre><code>void SelectNode(TreeNode&lt;TItem&gt; node)
</code></pre>
</li>
<li>
<p>自动滚动显示选择的条目</p>
<ul>
<li>
<p>移这里是列表文本动到指定Item：<code>void ScrollTo(TItem item);</code></p>
</li>
<li>
<p>移动到指定Item(带动画)：<code>void ScrollToAnimated(TItem item);</code></p>
</li>
</ul>
</li>
<li>
<p>移动到指定索引值:</p>
<pre><code>void ScrollTo(int index);
</code></pre>
</li>
<li>
<p>移动到指定滚动位置：</p>
<pre><code>void ScrollToPosition(float position);
</code></pre>
</li>
<li>
<p>移动到指定位置:</p>
<pre><code>void ScrollToPosition(Vector2 position);
</code></pre>
</li>
</ol>
<h2 id="树控件"><a class="header" href="#树控件">树控件</a></h2>
<p>注意：对于树控件，默认未展开的节点，不会被选择，所以如果需要选中，一种方式是先展开节点，另外一种是在属性面板取消勾选  ** Deselect Collapsed Nodes **</p>
<p>展开父级示例代码：</p>
<pre><code class="language-C#"> TreeNode&lt;ICatalogueItem&gt; pNode = node.Parent;                      
 while (pNode != null)
 {
     pNode.IsExpanded = true;
     pNode = pNode.Parent;
 }
</code></pre>
<p>在开发中遇到一个问题，用Timeline制作一个教学流程，然后根据时间节点设计了目录，使用树控件来显示目录，能够点击跳转。但是在这个流程中第 6 章节 和 第 3 章节的内容是一样的，配置Timeline 时就没配置 第6章节的，但是在目录中需要有，点击第6章节，跳转到第3章节的内容，这个时候就导致了 节点的id相同，所以自动选择的时候出现错乱，需要做特殊处理</p>
<h2 id="虚拟化"><a class="header" href="#虚拟化">虚拟化</a></h2>
<p>开启比较好，否则，在树控件中，如果大量节点导致拖动很卡顿</p>
<h2 id="easylayout"><a class="header" href="#easylayout">EasyLayout</a></h2>
<blockquote>
<p>布局组件，对应引擎自带的 VerticalLoayout 和 HorizontalLayout</p>
</blockquote>
<p>插件自带使用的这个，不使用这个会导致代码更新滚动视图位置无效</p>
<p><img src="unity/packages/image/NewUIWidgets/1718094735942.png" alt="1718094735942" /></p>
<ul>
<li>Main Axis: 搞不懂这个属性，似乎没影响</li>
<li>Sikp Inactive: 勾选时，被隐藏的子对象不会参加布局，此时和引擎自带的功能一直，否则即使隐藏，也会占位置</li>
</ul>
<hr />
<h2 id="输入框组件"><a class="header" href="#输入框组件">输入框组件</a></h2>
<p><img src="unity/packages/image/NewUIWidgets/1718094742970.png" alt="1718094742970" /></p>
<ul>
<li>Character Limit: 设置字符的个数，用于在设置密码、或者激活码等，可以显示个数</li>
<li>Content Type: 数据类型： 如激活码，只能输入整数 Integer Number</li>
<li>Caret Blink Rate: 光标闪烁的频率</li>
<li>Caret Width: 光标宽度： 默认的宽度比较小，基本看不见，建议这里设置大点</li>
<li>Custom Caret Color: 光标颜色</li>
</ul>
<h2 id="listviewcustombase"><a class="header" href="#listviewcustombase">ListViewCustomBase</a></h2>
<p>这个基类当中有一个属性：ListType ， 当你对面板进行布局的时候，可能需要重写这个变量的值来满足布局要求
<strong>ListViewCustom&lt;TComponent, TItem&gt;</strong> 继承于它。
也就是基本上所有的容器都可以使用这个功能</p>
<pre><code> public class TaskCatalogueTreeView : TreeViewCustom&lt;CatalogueComponent, ICatalogueItem&gt;
 {
    //需要重写
    public override ListViewType ListType { get =&gt;ListViewType.ListViewWithVariableSize; }
    //..
}
</code></pre>
<hr />
<p><strong>已知问题</strong>：在某些Unity版本的命名空间中，无法使用结构（Strcut）或接口(Interface)类型,需要使用Class</p>
<hr />
<h2 id="treeviewcustomtcomponent-titem"><a class="header" href="#treeviewcustomtcomponent-titem">TreeViewCustom&lt;TComponent, TItem&gt;</a></h2>
<ul>
<li>树形控件视图，一一般我们要编写自己的组件来继承此组件</li>
<li>TCompoenet: 树形控件中每个节点上挂载的 monobehavior组件，需要继承：TreeViewComponentBase<ICatalogueItem></li>
<li>Item: TCompoenet对应的数据接口，需要继承 INotifyPropertyChanged</li>
<li>根据插件自带的例子，参照实现接口和组件</li>
</ul>
<hr />
<h2 id="inotifypropertychanged-support"><a class="header" href="#inotifypropertychanged-support">INotifyPropertyChanged Support</a></h2>
<blockquote>
<p>插件使用的ObservableList提供了对数据类型的INotifyPropertyChanged接口的支持，因此如果属性更新并引发PropertyChanged事件，那么视图将被更新。</p>
</blockquote>
<blockquote>
<p>如果您想在项目数据更改时自动更新集合小部件(如ListView、TileView、Table)，那么你需要添加 <code>INotifyPropertyChanged</code> 实现到你的数据类型。</p>
</blockquote>
<ul>
<li>例子</li>
</ul>
<pre><code>public class ListViewIconsItemDescription : INotifyPropertyChanged
{
    [SerializeField]
    string name;
    public string Name
    {
        get
        {
            return name;
        }
        set
        {
            name = value;
            Changed("Name");
        }
    }
    public event PropertyChangedEventHandler PropertyChanged = (x, y) =&gt; { };
    protected void Changed(string propertyName)
    {
        PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
    }
    ...
}
</code></pre>
<ul>
<li>通过这种方式，界面的第一个将被更新为新的名称</li>
</ul>
<pre><code>ListView.DataSource[0].Name = "New name";
</code></pre>
<ul>
<li>可以通过属性 ObserveItems 来禁用通知行为</li>
</ul>
<pre><code>ListView.DataSource.ObserveItems = false;
// name displayed with the widget will be not changed
ListView.DataSource[0].Name = "New name";
</code></pre>
<h2 id="案例-2"><a class="header" href="#案例-2">案例</a></h2>
<h3 id="制作目录章节的树形案例"><a class="header" href="#制作目录章节的树形案例">制作目录章节的树形案例</a></h3>
<ul>
<li>存在节点嵌套</li>
<li>当节点是一个组（类似文件夹）节点时，应显示 三角图标，打开时，箭头向下，关闭时，箭头向右</li>
<li>当节点是一个数据（类似文件）节点时，不显示图标</li>
</ul>
<p>TeachFlowCatalogue 脚本：</p>
<p>数目录组件</p>
<pre><code> public class TeachFlowCatalogue : TreeViewCustom&lt;CatalogueComponent, ICatalogueItem&gt;
    {
        public override ListViewType ListType { get =&gt; ListViewType.ListViewWithVariableSize; }//布局需要
    }

</code></pre>
<p><img src="unity/packages/image/NewUIWidgets/1718094755079.png" alt="1718094755079" /></p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="listview中修改item的显示状态文本颜色失败"><a class="header" href="#listview中修改item的显示状态文本颜色失败">ListView中修改Item的显示状态（文本颜色）失败</a></h3>
<blockquote>
<p>答：ListView 使用的 DataSource 来绑定数据并显示，如果要改变状态的显示，那么你要改变DataSource的源数据，需要注意两点</p>
</blockquote>
<ul>
<li>数据类型不能是Struct 和 interface,必须是class</li>
<li>需要提供 INotifyPropertyChanged 支持,详见 INotifyPropertyChanged 的介绍</li>
<li><strong>提示：通过单独修改Item的Color是无效的，因为源数据没改变</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="nodegraphprocessor"><a class="header" href="#nodegraphprocessor">NodeGraphProcessor</a></h2>
<ul>
<li>
<p><strong>功能</strong>
节点编辑器插件，用于配置任务流程，需要自己编写逻辑节点和处理流程。这是github上一个外国人基于Unity UIElement编写的。</p>
</li>
<li>
<p><strong>安装</strong>
● 通过 UPM 安装插件
● 更新指定版本</p>
</li>
<li>
<p><strong>样式扩展</strong>
在Resources目录下创建 PortViewTypes.uss，这个文件的名称是固定的，在这里面添加自己的样式</p>
</li>
</ul>
<pre><code>outflow 更改无效，不知原因
.Port_FlowLink {
    --port-color: #FFFF30;
}

.Port_ActionLink {
    --port-color: #FFFF30;
}
#contents #top .inflow #connector,
#contents #top .outflow #connector {
    border-radius: 0px;
}
</code></pre>
<ul>
<li><strong>插件存在问题</strong>
● 1.3.0 版本：图形界面很卡，回退到了1.2.0
● 大半年没更新了，不过基本满足自己的需求了</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生成pdf的插件"><a class="header" href="#生成pdf的插件">生成PDF的插件</a></h1>
<p>列举了几个在.net下使用的插件，但是最后只有ItextSharp使用成功了</p>
<h2 id="itextsharp"><a class="header" href="#itextsharp">iTextSharp</a></h2>
<h3 id="说明-2"><a class="header" href="#说明-2">说明</a></h3>
<p>进入官网的时候，提示itextsharp已经停止维护，请使用itext7,然后又去了解itext7,，但是最后发现要使用itext7需要很多dll，并且还报错，没成功，最后还是使用iTextSharp，主要是在网上可以找到使用列子。</p>
<ul>
<li><strong>官网</strong> ：https://github.com/itext/itextsharp</li>
<li><strong>教程</strong> ：http://t.zoukankan.com/springsnow-p-13156025.html （实用）https://cloud.tencent.com/developer/article/1013339</li>
</ul>
<h3 id="使用手册"><a class="header" href="#使用手册">使用手册</a></h3>
<h4 id="安装"><a class="header" href="#安装">安装</a></h4>
<ol>
<li>
<p>使用vs nuget安装 ITextsharp后，在工程的packages文件夹下拷贝 BouncyCastle.Crypto.dll 和 itetshrp.dll到Pluins 文件夹下</p>
</li>
<li>
<p>拷贝Unity对应版本下的 I18N.dll 和 I18.West.dll(这两个没有在安卓端报错)，对应路径（假设为Unity2019.3.15f）：   Unity\Hub\Editor\2019.3.15f1\Editor\Data\MonoBleedingEdge\lib\mono\unityjit 下的i18N dll</p>
</li>
<li>
<p>最后的dll如下图</p>
</li>
</ol>
<p><img src="unity/packages/image/PDF%E6%8F%92%E4%BB%B6/1718094807127.png" alt="1718094807127" /></p>
<h4 id="字体"><a class="header" href="#字体">字体</a></h4>
<p>itextsharp 需要配置字体，使用file读取字体的，在PC IOS 上，直接将字体丢在 stremingassets下就可以了，但是 android 下  不支持 file 读取 stremingassets，解决办法是将 字体复制到 persentAssets下</p>
<h3 id="报错处理"><a class="header" href="#报错处理">报错处理</a></h3>
<ol>
<li>
<p>Encoding 1252 data could not be found</p>
<p>打包安卓端（确保路径正确），发现报错 <code>NotSupportedException: Encoding 1252 data could not be found </code>
在百度或者国内找了一辈子没解决问题，还是google：https://forum.unity.com/threads/notsupportedexception-encoding-1252-data-could-not-be-found-2020-2-3-f1.1058102/ . 解决方法：https://answers.unity.com/questions/1756912/invalid-il-code-in-build.html ，就是要添加 I18n ，按照以下的方式添加（就是要使用 Unity\Hub\Editor\2019.3.15f1\Editor\Data\MonoBleedingEdge\lib\mono\unityjit 下的i18N dll,最后要添加的dll如下:）：</p>
</li>
</ol>
<pre><code>Okay nevermind, just had to snoop around a little more. The I18N dlls that I was using came from the Unity\Hub\Editor\2019.3.15f1\Editor\Data\MonoBleedingEdge\lib\mono\unity folder, and using the ones in the Unity\Hub\Editor\2019.3.15f1\Editor\Data\MonoBleedingEdge\lib\mono\unityjit worked. I don't understand why but it works anyways !

</code></pre>
<p><img src="unity/packages/image/PDF%E6%8F%92%E4%BB%B6/1718094807127.png" alt="1718094807127" /></p>
<ol start="2">
<li>
<p>打包安卓时，未生成PDF，导致程序未执行后续逻辑</p>
<ul>
<li>
<p>没有显示生成的PDF，确定PDF有问题</p>
</li>
<li>
<p>通过手机USB连接电脑，在电脑上查看手机的文件夹，定位到 包文件夹，找到生成的 pdf ，打不开，说明 未成功生成 pdf</p>
</li>
<li>
<p>对每次 document.Add(element); 进行try 捕获错误，得到 <code>1.not.found.as.a.resource？</code>，定位是哪个 element 出现问题发现在下面语句时出现错误，</p>
</li>
</ul>
</li>
</ol>
<pre><code>//绘制一条横线
elements.Add(new Chunk(new iTextSharp.text.pdf.draw.LineSeparator(0.0F, 100.0F, BaseColor.BLACK, Element.ALIGN_LEFT, 1)));

</code></pre>
<p>删除了这条语句</p>
<p>未清除的地方：第一次会报错，但是后续有时候又不报错</p>
<h2 id="itext7"><a class="header" href="#itext7">itext7</a></h2>
<ul>
<li>
<p><strong>官网</strong> ：https://github.com/itext/itext7-dotnet/releases/tag/7.2.2</p>
</li>
<li>
<p><strong>Unity教程(失败)</strong> ： https://www.ngui.cc/article/show-124951.html</p>
</li>
<li>
<p><strong>官方手册</strong>  https://kb.itextpdf.com/home/it7kb/examples/itext-7-jump-start-tutorial-chapter-2</p>
</li>
<li>
<p><strong>绘图教程，易懂</strong> https://blog.csdn.net/u012397189/article/details/76726576</p>
</li>
</ul>
<p>注意：需要安装</p>
<ul>
<li>
<p>itext7</p>
</li>
<li>
<p>itext7.bouncy-castle-adapter(这个在编程的时候并没有体现出来需要，但是没有在加载文件的时候就会报错)</p>
</li>
</ul>
<h2 id="questpdf"><a class="header" href="#questpdf">Questpdf</a></h2>
<p><strong>官网</strong> ：https://github.com/QuestPDF/QuestPDF</p>
<p>这个官方文档比较清楚，比较好用，但是在Unity端要报错，用不了，在.net端倒是比较好用，如在WPF上使用</p>
<h2 id="pdf-renderer渲染"><a class="header" href="#pdf-renderer渲染">PDF Renderer（渲染）</a></h2>
<p>Unity 商店中的一款插件，收费较高，目前最新版本 5.51，自己目前最新为 5.30</p>
<p>注 在 csdn上有个资源为 5.51 是假的</p>
<p>导入包后有相关文档 <code>ApiDocumentation.chm</code> 和 <code>Documentation.pdf</code></p>
<h3 id="新输入系统new-input-system报错"><a class="header" href="#新输入系统new-input-system报错">新输入系统（new input system）报错</a></h3>
<ol>
<li>
<p>若项目使用新输入系统， <code>PDFViewerPage.cs</code> 脚本会报错，原因是插件默认使用的是旧输入系统的输入方式</p>
</li>
<li>
<p>在 <code>PDF Renderer</code> 文件夹的程序集定义文件中，添加 <code>InputSystem</code> 的依赖</p>
</li>
</ol>
<pre><code class="language-asmdef">{
    "name": "Paroxe.PDFRenderer",
    "rootNamespace": "",
    "references": [
        "Unity.InputSystem"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
</code></pre>
<ol start="3">
<li>打开 PDFViewerPage.cs，修改脚本</li>
</ol>
<pre><code class="language-C#">
    //添加新输入系统的命名空间
    using UnityEngine.InputSystem;
    //....


    //大概在265行
    //Vector2 pointerPosition = Input.mousePosition;//注释
    Vector2 pointerPosition = Mouse.current.position.ReadValue();

</code></pre>
<h3 id="构建"><a class="header" href="#构建">构建</a></h3>
<ol>
<li>
<p>先确认build平台相关的文件是否存在，不存在需要重新导入，或者拖入文件夹</p>
</li>
<li>
<p>其他平台的文件可能会影响构建，需要暂时删除</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vscode-环境配置"><a class="header" href="#vscode-环境配置">VSCODE 环境配置</a></h1>
<ul>
<li>
<p>安装 .net core</p>
</li>
<li>
<p>安装 .net framework 4.7.1 这个根据提示来，在vscode 提示里面搜索 version=,下载地址：https://dotnet.microsoft.com/zh-cn/download/dotnet-framework</p>
</li>
<li>
<p>安装各种插件包</p>
</li>
<li>
<p>在mac上始终不行，仔细看c#扩展</p>
</li>
</ul>
<p><img src="unity/../../assets/Unity/20230406/1.png" alt="输入图片说明" /></p>
<div style="break-before: page; page-break-before: always;"></div><style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 12px;
    text-align: left;
    vertical-align: top; 
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.excel-table tr:nth-child(even), table tr:nth-child(odd) {
    background-color: transparent; /* 确保所有行背景色一致 */
}

.excel-table tr:hover {
    background-color: inherit;
}

.excel-table tr:hover {
    background-color: #e9e9e9;
}
.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    width:200px;
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 100%;
}

</style>
<h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<p><a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Rust 编程语言</a></p>
<p><strong>Windows上安装</strong></p>
<p>下载安装文件进行安装：<a href="https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe">rustup-init.exe</a></p>
<p><strong>Linux Mac上安装</strong></p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h2 id="更新和卸载"><a class="header" href="#更新和卸载">更新和卸载</a></h2>
<p>通过 安装 Rust 后rustup，更新到新发布的版本就很容易了。从 shell 运行以下更新脚本：</p>
<pre><code>rustup update
</code></pre>
<p>要卸载 Rust 和rustup，请从 shell 运行以下卸载脚本：</p>
<pre><code>rustup self uninstall
</code></pre>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p><a href="https://doc.rust-lang.org/stable/cargo/index.html">Cargo Book</a></p>
<h3 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h3>
<p>注意命令全是小写，错误示范：Cargo run hello❌</p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>功能/命令</th>
                <th>说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>创建项目<br><br><code>cargo new hello_cargo</code></td>
                <td>创建项目</td>
            </tr>
             <tr>
                <td>构建项目<br><br><code>cargo build --release</code></td>
                <td>此命令在`target/debug/hello_cargo（或 Windows 上的target\debug\hello_cargo.exe ）`中创建一个可执行文件，而不是在当前目录中。由于默认构建是调试构建，因此 Cargo 将二进制文件放在名为debug的目录中。</td>
            </tr>
              <tr>
                <td>构建发布<br><br><code>cargo build</code></td>
                <td>当您的项目最终准备好发布时，您可以使用cargo build --release优化来编译它。此命令将在target/release而不是target/debug中创建可执行文件。</td>
            </tr>
              <tr>
                <td>运行项目<br><br><code>cargo run</code></td>
                <td>编译和运行一键执行
                </td>
            </tr>
             <tr>
                <td>检查项目<br><br><code>cargo check</code></td>
                <td>此命令可以快速检查您的代码，以确保它可以编译但不会产生可执行文件</td>
            </tr>
            <tr>
                <td>测试<br><br><code>cargo test</code></td>
                <td>测试</td>
            </tr>
        </tbody>
    </table>
</div>
<h3 id="配置子项目在父项目中运行"><a class="header" href="#配置子项目在父项目中运行">配置子项目在父项目中运行</a></h3>
<p>通过配置工作区来实现，<a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">官方文档</a></p>
<p>首先创建父级项目：</p>
<pre><code>cargo new rust_examples
</code></pre>
<p>然后在 rust_examples 下创建 hello 等其他一系列子项目，</p>
<p>切换到 rust_examples</p>
<pre><code>cd rust_examples

</code></pre>
<p>创建hello</p>
<pre><code>cargo new hello
</code></pre>
<p>项目目录结构如下：</p>
<p><img src="rust/image/rust/1721616093714.png" alt="1721616093714" /></p>
<p><strong>配置方式：</strong></p>
<p>首先在 rust_examples 项目的 Cargo.toml 文件中配置 <code>workspace</code> 工作区成员，</p>
<pre><code class="language-toml">[package]
name = "rust_examples"
version = "0.1.0"
edition = "2021"

[workspace]
members = [
    "hello"
]
[dependencies]
</code></pre>
<p>运行hello项目：</p>
<pre><code>cargo run --package hello
</code></pre>
<p>其他命令如 <code>build</code> 均可以用，但是构建的文件在 rust_examples 的 target文件夹下。</p>
<h2 id="问题汇总-2"><a class="header" href="#问题汇总-2">问题汇总</a></h2>
<h3 id="cargo-config-deprecated"><a class="header" href="#cargo-config-deprecated">Cargo config deprecated</a></h3>
<p>当构建或者运行时，显示警告：</p>
<pre><code>warning: `C:\Users\ABYTE\.cargo\config` is deprecated in favor of `config.toml`
note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`
</code></pre>
<h3 id="构建的gui程序运行时会出现控制台窗口"><a class="header" href="#构建的gui程序运行时会出现控制台窗口">构建的GUI程序，运行时会出现控制台窗口</a></h3>
<p>当使用 <code>iced</code> 来构建GUI程序，启动时出现控制台窗口，可以在<code>main.rs</code>文件的顶部添加以下代码来去除该控制台窗口：</p>
<pre><code>#![windows_subsystem = "windows"]
</code></pre>
<h2 id="国内源"><a class="header" href="#国内源">国内源</a></h2>
<p><a href="https://rsproxy.cn">子节跳动镜像</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tauri"><a class="header" href="#tauri">Tauri</a></h1>
<blockquote>
<p>UI 框架</p>
</blockquote>
<ul>
<li><a href="https://tauri.app">Tauri 官网</a></li>
<li><a href="https://vuejs.org/">Vue 官网</a></li>
<li><a href="https://element-plus.org/zh-CN/guide/installation.html">基于VUE的UI框架 Element-UI</a></li>
</ul>
<h2 id="执行后不出现窗口"><a class="header" href="#执行后不出现窗口">执行后不出现窗口</a></h2>
<p>可能的原因是还没编译完，编译完会出现 <code>Finished</code></p>
<pre><code class="language-bash">&gt; rttve@0.1.0 tauri
&gt; tauri dev

    Running BeforeDevCommand (`npm run dev`)

&gt; rttve@0.1.0 dev
&gt; vite


  VITE v5.4.8  ready in 589 ms

  ➜  Local:   http://localhost:1420/
    Info Watching F:\000-Labyte\Rust\tauri\rttve\src-tauri for changes...
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Blocking waiting for file lock on package cache
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1m 36s
</code></pre>
<h2 id="调试"><a class="header" href="#调试">调试</a></h2>
<h3 id="前端调试"><a class="header" href="#前端调试">前端调试</a></h3>
<p><strong>第一种方式</strong>：通过 <code>Ctr+shift+I</code> 来打开 <code>DevTools</code> 调试工具，和浏览器的 <code>F12</code> 调试浏览器相同</p>
<p><strong>第二种方式</strong>：前端的调试可以通过点击链接在浏览器上进行渲染，按下 <code>F12</code> 来调试。</p>
<h3 id="后端调试"><a class="header" href="#后端调试">后端调试</a></h3>
<p>根据 <a href="https://tauri.app/zh-cn/develop/debug/vscode/">Tauri 官网文档进行配置 </a></p>
<h2 id="vue"><a class="header" href="#vue">Vue</a></h2>
<ul>
<li>路由</li>
</ul>
<h2 id="element-plus"><a class="header" href="#element-plus">Element-plus</a></h2>
<ul>
<li>国际化</li>
<li></li>
</ul>
<h2 id="相关开源项目"><a class="header" href="#相关开源项目">相关开源项目</a></h2>
<ul>
<li><a href="https://github.com/tw93/Pake">Pake：网页打包工具</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slint"><a class="header" href="#slint">Slint</a></h1>
<blockquote>
<p>UI 框架</p>
</blockquote>
<p><a href="https://slint.dev/" title="slint">Slint 官网首页</a></p>
<p><a href="https://releases.slint.dev/1.7.0/docs/rust/slint/index.html">.slint 和 rust 分离</a></p>
<p><a href="https://github.com/syf20020816/slint_learn">国内B站UP主代码，比较详细</a></p>
<h2 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h2>
<h3 id="手动创建项目"><a class="header" href="#手动创建项目">手动创建项目</a></h3>
<p>创建项目：</p>
<pre><code class="language-bash">cargo new slint_component
</code></pre>
<p>在  <code>Cargo.toml</code> 中添加依赖 <code>slint </code>和 <code>slint-build</code>，两者的版本号相同</p>
<pre><code class="language-toml">[package]
name = "slint_component"
version = "0.1.0"
edition = "2021"

[dependencies]
slint = "1.7.0"

[build-dependencies]
slint-build = "1.7.0"
</code></pre>
<p>创建组件文件夹 <code>ui(或者命名为 component)</code>，用于放置 <code>slint</code>文件，在文件中创建 <code>Window.slint</code> 文件，</p>
<pre><code class="language-slint">import { AboutSlint, Button, VerticalBox } from "std-widgets.slint";
component Demo {

    VerticalBox {
        alignment: center;
    

        Text {
            text: "Hello World!";
            font-size: 24px;
            horizontal-alignment: center;
        }
        AboutSlint {
            preferred-height: 150px;
        }
        HorizontalLayout { alignment: LayoutAlignment.center; Button { text: "O1K!"; } }
    }
}

export component MainWindow inherits Window {
    width: 800px;
    height: 600px;
    title: "slint 测试";
    Demo{
    }
}
</code></pre>
<p>在根目（与src同层级）创建 <code>build.rs</code> 文件：</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main(){
    slint_build::compile("src/ui/Window.slint").unwrap();
}
</code></pre></pre>
<p>在 src/main.rs 中添加如下代码：</p>
<p>⚠️<code>slint::include_modules!();</code> 提示错误 <code>failed to load file UNRESOLVED_ENV_VAR</code>，但是不影响运行</p>
<pre><pre class="playground"><code class="language-rust edition2021">slint::include_modules!();
fn main() {
    MainWindow::new().unwrap().run().unwrap();
}
</code></pre></pre>
<h3 id="使用-slint-rust-模板"><a class="header" href="#使用-slint-rust-模板">使用 Slint Rust 模板</a></h3>
<p>类似于WPF中的 prim 框架模板一样，自动创建项目文件结构</p>
<p>首先确保安装了 <code>cargo-generate</code></p>
<pre><code class="language-shell">cargo install cargo-generate
</code></pre>
<p>使用模板创建</p>
<pre><code class="language-shell">cargo generate --git https://github.com/slint-ui/slint-rust-template
</code></pre>
<p>稍等下，提示输入项目名称：</p>
<pre><code class="language-shell">PS F:\000-SHING\Rust\rust_examples&gt; cargo generate --git https://github.com/slint-ui/slint-rust-template
 Project Name: slint-02
 project-name: slint-02 ...
 Generating template ...
 Moving generated files into: `F:\000-SHING\Rust\rust_examples\slint-02`...
 Initializing a fresh Git repository
 Done! New project created F:\000-SHING\Rust\rust_examples\slint-02
PS F:\000-SHING\Rust\rust_examples&gt; cargo run --package slint-02
</code></pre>
<p>创建后文档结构：</p>
<p><img src="rust/image/slint/1721877459941.png" alt="1721877459941" /></p>
<p>✅ 使用模板方式创建后： <code>slint::include_modules!();</code> 提示错误 <code>failed to load file UNRESOLVED_ENV_VAR</code> 问题修复了，前面手动创建的项目的错误也消除了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iced"><a class="header" href="#iced">Iced</a></h1>
<blockquote>
<p>UI 框架</p>
</blockquote>
<p>api不稳定，一天一个样，不适合。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecs"><a class="header" href="#ecs">ECS</a></h1>
<h2 id="specs"><a class="header" href="#specs">Specs</a></h2>
<p><a href="https://amethyst.github.io/specs/docs/tutorials/">官方手册</a></p>
<p><a href="https://www.bilibili.com/video/BV17b42177fw/?spm_id_from=333.1007.tianma.4-1-11.click&amp;vd_source=ae505290000a9de26b4d6c8111c5e5dd">B站视频</a></p>
<ul>
<li>纯ECS框架</li>
<li>轻量</li>
<li>入门应该较容易</li>
</ul>
<h2 id="bevy_ecs"><a class="header" href="#bevy_ecs">Bevy_ecs</a></h2>
<p><a href="https://bevyengine.org/">官网</a></p>
<p><a href="https://taintedcoders.com/">国外博主编写的使用指南</a></p>
<ul>
<li>星数最多</li>
<li>包含了ECS和GUI部分</li>
<li>入门较难</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook"><a class="header" href="#mdbook">mdBook</a></h1>
<ul>
<li>
<p>将markdown 文件转换为html的工具</p>
</li>
<li>
<p><a href="https://github.com/rust-lang/mdBook">仓库地址</a></p>
</li>
<li>
<p><a href="https://rust-lang.github.io/mdBook">官方文档</a></p>
</li>
</ul>
<p>注意：国内有很多个人翻译的中文版本，时间比较久远，还是看官网的英文版本或者翻译为中文来查看。</p>
<h2 id="常用命令-1"><a class="header" href="#常用命令-1">常用命令</a></h2>
<p>构建：<code>--open</code> 可选，自动打开本地文件，但不是以服务方式运行</p>
<pre><code>mdbook build --open
</code></pre>
<p>运行服务，然后访问：<a href="http://localhost:3000">http://localhost:3000</a></p>
<pre><code>mdbook server
</code></pre>
<h2 id="基于默认主题微调"><a class="header" href="#基于默认主题微调">基于默认主题微调</a></h2>
<h3 id="设置界面字体"><a class="header" href="#设置界面字体">设置界面字体</a></h3>
<ul>
<li>
<p><code>theme/css/general.css</code> 中的 <code>:root</code> 和 <code>Body</code> 可整体调整左侧章节目录和整文的字体大小</p>
</li>
<li>
<p><code>theme/css/chrome.css</code> 中的 <code>.sidebar</code> 可整体调整左侧章节目录字体大小，两者结合，可满足相关需求</p>
</li>
</ul>
<h3 id="设置整文行间距"><a class="header" href="#设置整文行间距">设置整文行间距</a></h3>
<p>theme/css/general.css:</p>
<pre><code class="language-css">.content p { line-height: 1.5em; }
.content ol { line-height: 1.5em; }
.content ul { line-height: 1.5em; }

</code></pre>
<h2 id="主题"><a class="header" href="#主题">主题</a></h2>
<p><strong>PageToc</strong>：比较简单容易配置的目录插件，但是显示感觉怪怪的，在加上目录后，文章内容还是居中，就导致布局不合理</p>
<p><strong><a href="https://github.com/zjp-CN/mdbook-theme?tab=readme-ov-file">可自定义标题目录，为配置成功</a></strong>，该主题在Pagetoc的基础上添加了自定义功能，可配置文章内容全屏显示，但是配置后运行不起来，即使克隆作者的仓库也运行不起来。</p>
<h2 id="中文支持"><a class="header" href="#中文支持">中文支持</a></h2>
<p>网页的工具栏等都是英文显示，在国内使用需要更改为中文。</p>
<ol>
<li>设置网页为中文</li>
</ol>
<p>在国内使用应该使用中文</p>
<ul>
<li>在 <code>book.toml</code>中设置为中文 <code>language = "zh-CN"</code>，这仅仅是说明我们的网页使用的是中文</li>
</ul>
<pre><code class="language-C#">[book]
authors = ["LIXINGJUN"]
language = "zh-CN"
multilingual = false
src = "src"
title = "成都轨道学院培训楼使用指南"
description = "该文档仅用于成都轨道学院培训楼使用，禁止外传。"
</code></pre>
<ol start="2">
<li>设置工具栏为中文</li>
</ol>
<ul>
<li>工具栏默认提示为英文，如下图中的目录切换：</li>
</ul>
<p><img src="rust/image/mdbook/1716796122067.png" alt="1716796122067" /></p>
<ul>
<li>这需要通过修改主题来实现，在默认创建的书中没有主题的配置，根据官网文档，通过执行命令 <code>mdbook init --theme</code> 来创建默认的主题文件，然后通过修改文件中内容来修改.</li>
<li>通过修改 <code> index.hbs</code> 文件中的对应内容</li>
</ul>
<p><img src="rust/image/mdbook/1716796153384.png" alt="1716796153384" /></p>
<p><img src="rust/image/mdbook/1716796162203.png" alt="1716796162203" /></p>
<p><img src="rust/image/mdbook/1716796171171.png" alt="1716796171171" /></p>
<p><img src="rust/image/mdbook/1716796178418.png" alt="1716796178418" /></p>
<ol start="3">
<li>支持中文搜索</li>
</ol>
<p><strong>说明</strong>： 默认不支持中文搜索，也就是在搜索框总输入中文，搜索不到结果，具体见社区： <a href="https://rustcc.cn/article?id=fd75c670-4e8a-40be-855c-4a5ad1da350a">Rust社区支持中文说明</a>，总结以下的处理方式：</p>
<ol>
<li>安装指定插件</li>
</ol>
<pre><code class="language-shell">cargo install mdbook-mermaid
cargo install mdbook-plantuml
</code></pre>
<ol start="2">
<li>本地创建 <code>assets</code>，在社区中指示的仓库下载指定的文件到 <code>assets</code>中</li>
<li>配置 <code>book.toml</code></li>
</ol>
<pre><code class="language-Toml">[output.html]
mathjax-support = true
additional-css = ["assets/mermaid.css", "assets/print.css", "assets/all-page.css"]
additional-js = ["assets/fzf.umd.js", "assets/elasticlunr.js", "assets/mermaid.min.js", "assets/import-html.js","assets/searcher.js"]
</code></pre>
<ol start="4">
<li>配置成功案例 <a href="https://gitee.com/shtzj/userguide.git">https://gitee.com/shtzj/userguide.git</a> 项目设置。</li>
</ol>
<h3 id="搜索结果描述的修改"><a class="header" href="#搜索结果描述的修改">搜索结果描述的修改</a></h3>
<p>如下图显示，我们搜索到内容后提示有多少个结果，默认是英文显示的，要改为中文，这里通过 <code> index.hbs</code>无法修改，因为这个数据是动态显示的，在后端实现。</p>
<p><img src="rust/image/mdbook/1716796189226.png" alt="1716796189226" /></p>
<p>通过在渲染输出中，通过字符串查找，在 <code>seracher.js</code> 文件中找到了响应的代码位置，简单的操作，就是每次我们只要将对应的地方改为中文即可，但是存在一个问题，每次构建都会覆盖改好的内容。</p>
<p><strong>原代码</strong></p>
<pre><code class="language-JavaScript">    function formatSearchMetric(count, searchterm) {
        if (count == 1) {
            return count + " search result for '" + searchterm + "':";
        } else if (count == 0) {
            return "No search results for '" + searchterm + "'.";
        } else {
            return count + " search results for '" + searchterm + "':";
        }
    }
</code></pre>
<p><strong>希望的代码</strong></p>
<pre><code class="language-JavaScript">    function formatSearchMetric(count, searchterm) {
        if (count == 1) {
            return count + " 个搜索结果 '" + searchterm + "':";
        } else if (count == 0) {
            return "无搜索结果 '" + searchterm + "'.";
        } else {
            return count + " 个搜索结果 '" + searchterm + "':";
        }
    }
</code></pre>
<p><strong>临时解决方式（不理想）</strong></p>
<ol>
<li>将 <code>seracher.js</code>  先改好，拷贝到 <code>assets </code>文件夹下；</li>
<li>配置 <code> book.toml</code> 文件，如下图增加 <code>searcher.js</code> 的引用</li>
</ol>
<pre><code class="language-Toml">[output.html]
mathjax-support = true
additional-css = ["assets/mermaid.css", "assets/print.css", "assets/all-page.css"]
additional-js = ["assets/fzf.umd.js", "assets/elasticlunr.js", "assets/mermaid.min.js", "assets/import-html.js","assets/searcher.js"]
</code></pre>
<ol start="3">
<li>每次构建后，会在输出目录的assts下，创建 <code>searcher.js</code>文件，但是同时根目也有相同的文件，需要删除根目下的 <code>searcher.js</code> 文件，否则导致点击 搜索按钮无效。</li>
</ol>
<h2 id="异常汇总"><a class="header" href="#异常汇总">异常汇总</a></h2>
<h2 id="1部署github章节显示空白"><a class="header" href="#1部署github章节显示空白">(1)部署github章节显示空白</a></h2>
<ol>
<li>在本地测试所有内容正常，部署到Github上后， <code>csharp</code> 文件夹下的所有章节都显示空白，将<code>csharp</code>改为 <code>c-sharp</code> 后显示正常。</li>
</ol>
<h2 id="章节跳转"><a class="header" href="#章节跳转">章节跳转</a></h2>
<h3 id="本页跳转"><a class="header" href="#本页跳转">本页跳转</a></h3>
<pre><code class="language-markdown">[跳转到章节](#chapter-1)
 
...
 
&lt;a name="chapter-1"&gt;&lt;/a&gt;
# 章节1
这里是章节1的内容。
</code></pre>
<h3 id="跨页跳转"><a class="header" href="#跨页跳转">跨页跳转</a></h3>
<p>假设 <code>a.md</code> 和 <code>b.md</code> 在同一个目录下</p>
<p>a内容：</p>
<pre><code class="language-markdown">&lt;a name="chapter-1"&gt;&lt;/a&gt;
# 章节1
这里是章节1的内容。

&lt;a name="chapter-2"&gt;&lt;/a&gt;
# 章节2
这里是章节2的内容。
</code></pre>
<p>在 <code>b</code> 中跳转到 <code>a</code> 的章节2</p>
<pre><code class="language-markdown">[跳转到 a 的章节2](a.md#chapter-2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptyhon"><a class="header" href="#ptyhon">Ptyhon</a></h1>
<h2 id="模块"><a class="header" href="#模块">模块</a></h2>
<p>一个.py文件就是一个模块，模块的作用是为了封装规范代码，创建模块就是创建一个.py文件，导入模块：<code>import 模块名； from 模块名 import member</code>。</p>
<p>导入模块时，程序搜索模块的顺序为：</p>
<ol>
<li>
<p>在当前目录（即执行Python脚本文件所在的目录）下查找</p>
</li>
<li>
<p>到PYTHONPATH(环境变量）下的每个目录中查找</p>
</li>
<li>
<p>到Python的默认安装目录查找</p>
</li>
</ol>
<p>以上目录的具体位置保存在标准模块sys.path变量中，可以通过以下代码输出查看</p>
<pre><code class="language-py">import sys
print(sys.path)
</code></pre>
<p>如果要导入的模块不在以上目录中，会报错：<code>ModuleNotFoundError: No module named 'xxxx'</code></p>
<p>模块的目录结构</p>
<p><img src="python/image/python/1719555305558.png" alt="1719555305558" /></p>
<p><code>SizeModule.py</code> 中的代码</p>
<pre><code class="language-py">width = 100
height = 200
</code></pre>
<p>与 <code>SizeModule.py</code> 同目录的 <code>test.py</code> 调用方法（直接导入即可）</p>
<pre><code class="language-py">import SizeModule
print(SizeModule.width)
print(SizeModule.height)
</code></pre>
<p>如果我们要在外层 <code>Test.py</code> 中导入 <code>TestPackge</code> 文件夹下的 <code>SizeModule.py</code> 模块，需要先将包的路径加入到 <code>sys.path</code> 中。</p>
<p>第一种方式：根据当前路径将包路径加入到<code>sys.path</code></p>
<pre><code class="language-py">import sys
import os

# 输出当前文件的绝对路径
current_dir = os.path.dirname(os.path.abspath(__file__))
# 将需要导入模块代码文件相对于当前文件目录的绝对路径加入到sys.path中
sys.path.append(os.path.join(current_dir, ".."))

from TestPackge import SizeModule
print(SizeModule.width)

</code></pre>
<p>第二种方式：将工作目录添加到<code>sys.path</code>中，然后根据层级关系导入</p>
<pre><code class="language-py">import sys
import os
sys.path.append(os.getcwd()) # 工作目录，项目根目录
import 模块和包.TestPackge.SizeModule as size
print(size.width)
</code></pre>
<h2 id="包"><a class="header" href="#包">包</a></h2>
<p>创建一个包就是创建一个文件夹，文件夹下创建 <code>__init__.py</code> 文件，里面可以为空，如果写了逻辑，导入包时会执行，在介绍模块的目录结构时，实际上就是一个包的目录结构，导入包中的模块（举例一种方式）</p>
<pre><code class="language-py">from TestPackge import SizeModule # TestPackge: 包， SizeMoudle:模块
from TestPackge import SizeModule as newName  # TestPackge: 包， SizeMoudle:模块 ,导入为新的名称
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-server"><a class="header" href="#sql-server">SQL Server</a></h1>
<h2 id="不是有效的安装文件夹未解决"><a class="header" href="#不是有效的安装文件夹未解决">不是有效的安装文件夹（未解决）</a></h2>
<p>系统：Windows Server 2022 Datacenter</p>
<p>数据库版本：Sql Server 2022</p>
<p>下载安装的时，默认安装了命名示例，需要增加一个默认示例，通过安装中心-》安装-》向现有安装添加功能，选择安装文件夹后，出现：</p>
<p><img src="database/image/sql-server/1721350378227.png" alt="1721350378227" /></p>
<h2 id="ip地址远程连接"><a class="header" href="#ip地址远程连接">IP地址远程连接</a></h2>
<h3 id="sql-server相关配置"><a class="header" href="#sql-server相关配置">SQL Server相关配置</a></h3>
<ol>
<li>
<p>启动<strong>混合模式</strong>登录：打开 <code>SQL Server Management Studio (SSMS)</code>，连接到 SQL Server 实例，在对象资源管理器中，右键点击服务器名称，选择“属性”。在“安全性”页面上，选择“SQL Server 和 Windows 身份验证模式”</p>
<p><img src="database/image/sql-server/1721354379160.png" alt="1721354379160" /></p>
</li>
<li>
<p>配置 SQL Server 允许远程连接：在“连接”页面上，'远程服务器连接’选择“允许远程连接到此服务器”。</p>
<p><img src="database/image/sql-server/1721354442672.png" alt="1721354442672" /></p>
</li>
<li>
<p>启动 SQL Server Browser 服务（必须启动）：SQL Server Browser 服务用于为 SQL Server 实例提供实例名称解析，确保此服务在 Windows Server 上是启动的，打开 SQL Server Configuration Manager(SQL Server 配置管理器)。</p>
<p><img src="database/image/sql-server/1721355014528.png" alt="1721355014528" /></p>
<p>如果此处无法启动，先到 <strong>服务</strong> 窗口中启动对应的服务，然后再启动</p>
<p><img src="database/image/sql-server/1721355285786.png" alt="1721355285786" /></p>
</li>
<li>
<p>配置网络和 TCP/IP，打开 <strong>SQL Server Configuration Manager</strong>，在左侧导航窗格中，展开 <strong>SQL Server 网络配置</strong>，再次点击对应的协议展开，如“<strong>MSSQLSERVER</strong> 的协议”。在“协议”页面上，确保“TCP/IP”是启用的。</p>
<p><img src="database/image/sql-server/1721355721120.png" alt="1721355721120" /></p>
</li>
<li>
<p>设置端口（默认1433，应该可忽略）：右键点击“TCP/IP”，选择“属性”。在“IP 地址”选项卡上，为 IPAll 设置 TCP 端口为 1433（或者设置为 SQL Server 配置的其他端口）。注意，使用了特定的 IP 地址，确保在 TCP 动态端口和 TCP 静态端口中没有设置冲突（默认的一般都没有冲突）。</p>
<p><img src="database/image/sql-server/1721355860096.png" alt="1721355860096" /></p>
</li>
<li>
<p>重启服务</p>
<p><img src="database/image/sql-server/1721355777952.png" alt="1721355777952" /></p>
</li>
</ol>
<h3 id="设置防火墙阿里云服务器忽略"><a class="header" href="#设置防火墙阿里云服务器忽略">设置防火墙（阿里云服务器忽略）</a></h3>
<pre><code>基于 `1433` 端口，添加入站出站规则（具体操作略）。

注：阿里云的防火墙是禁用的，通过安全组来配置。
</code></pre>
<h3 id="阿里云添加安全组"><a class="header" href="#阿里云添加安全组">阿里云添加安全组</a></h3>
<p>在 云服务器 ECS -&gt; 安全组 上，添加入方向和出方向的访问规则。</p>
<p>入方向规则（出方向相同）：</p>
<p><img src="database/image/sql-server/1721356321240.png" alt="1721356321240" /></p>
<h3 id="参考-1"><a class="header" href="#参考-1">参考</a></h3>
<p><a href="https://blog.csdn.net/weixin_46766584/article/details/135489786">CSDN：阿里云 WindowsServer 使用之 配置 SQL Server 允许远程连接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql"><a class="header" href="#mysql">MySql</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mongodb"><a class="header" href="#mongodb">MongoDb</a></h1>
<p><a href="https://mongodb.github.io/mongo-csharp-driver/2.0/reference/bson/mapping/">官方文档</a></p>
<p><a href="https://www.mongodb.com/docs/drivers/csharp/current/">MongoDB C#驱动程序</a></p>
<p><a href="https://www.mongodb.com/zh-cn/docs/mongodb-shell/#std-label-mdb-shell-overview">Mongosh 文档</a></p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<h3 id="重启"><a class="header" href="#重启">重启</a></h3>
<p>在 Windows 上安装 MongoDB 后，你可以按照以下步骤重启 MongoDB 服务：</p>
<h4 id="使用命令提示符适用于服务安装"><a class="header" href="#使用命令提示符适用于服务安装">使用命令提示符（适用于服务安装）</a></h4>
<p>打开命令提示符：以管理员身份运行命令提示符。</p>
<p>停止 MongoDB 服务：</p>
<pre><code class="language-bash">net stop MongoDB
</code></pre>
<p>启动 MongoDB 服务：</p>
<pre><code class="language-bash">net start MongoDB
</code></pre>
<p>重启 MongoDB 服务（可以直接使用此命令代替上述两个命令）：</p>
<pre><code class="language-bash">net stop MongoDB &amp;&amp; net start MongoDB
</code></pre>
<h4 id="使用-windows-服务管理器"><a class="header" href="#使用-windows-服务管理器">使用 Windows 服务管理器</a></h4>
<p>打开服务管理器：</p>
<p>按 Win + R，输入 services.msc，然后按回车。
找到 MongoDB 服务：</p>
<p>在服务列表中找到 MongoDB 或者 MongoDB Server。
重启服务：</p>
<p>右键点击 MongoDB 服务，选择 重启。或者选择 停止，然后再点击 启动。</p>
<h4 id="手动启动和停止适用于手动启动的-mongodb"><a class="header" href="#手动启动和停止适用于手动启动的-mongodb">手动启动和停止（适用于手动启动的 MongoDB）</a></h4>
<p>停止 MongoDB：</p>
<p>打开命令提示符，执行以下命令找到并终止 MongoDB 进程：</p>
<pre><code class="language-bash">taskkill /f /im mongod.exe
</code></pre>
<p>启动 MongoDB：</p>
<p>通过命令提示符进入 MongoDB 安装目录，然后执行以下命令：</p>
<pre><code class="language-bash">mongod --config "C:\Program Files\MongoDB\Server\5.0\bin\mongod.cfg"
</code></pre>
<p>配置文件路径根据你的安装路径调整。</p>
<p>通过这些步骤，你可以在 Windows 上重启 MongoDB 服务。</p>
<h3 id="远程连接"><a class="header" href="#远程连接">远程连接</a></h3>
<p>⚠️⚠️⚠️ 设置远程连接，容易遭到攻击，谨慎使用 ⚠️⚠️⚠️</p>
<blockquote>
<p>失败信息：mongodb远程连接出现connect ECONNREFUSED（连接被拒绝）错误的解决方法</p>
</blockquote>
<p><strong>阿里云ECS(Windows Server)</strong></p>
<p>在 Windows 上安装，Mongodb 的配置文件中的 bind_ip 默认为 <code>127.0.0.1</code>，默认只有本机 IP 可以连接，需要将 <code>bind_ip</code> 配置为：<code>0.0.0.0</code>，标识接收任何 <code>IP</code> 的连接。默认只绑定了本机IP</p>
<p>配置文件地址： <code>C:\Program Files\MongoDB\Server\7.0\bin\mongod.cfg</code></p>
<p>修改为如下图</p>
<pre><code class="language-bash"># network interfaces
net:
  port: 27017
  bindIp: 0.0.0.0

</code></pre>
<p>重启 <code>net stop MongoDB &amp;&amp; net start MongoDB</code></p>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<h3 id="重启-1"><a class="header" href="#重启-1">重启</a></h3>
<p>macOS 上安装 MongoDB 后，使用以下命令来重启 MongoDB 服务：</p>
<ol>
<li><strong>停止 MongoDB 服务：</strong></li>
</ol>
<pre><code class="language-bash">brew services stop mongodb
</code></pre>
<ol start="2">
<li><strong>启动 MongoDB 服务：</strong></li>
</ol>
<pre><code class="language-bash">brew services stop mongodb
</code></pre>
<ol start="3">
<li><strong>重启 MongoDB 服务：</strong></li>
</ol>
<pre><code class="language-bash">brew services stop mongodb
</code></pre>
<p>如果你是手动启动的 MongoDB（而不是通过 <code>brew</code> 服务管理），你可以使用以下命令：</p>
<ol>
<li><strong>停止 MongoDB：</strong></li>
</ol>
<pre><code class="language-bash">sudo pkill -f mongod
</code></pre>
<ol start="2">
<li><strong>启动 MongoDB：</strong>
进入 MongoDB 的安装目录，然后执行：</li>
</ol>
<pre><code class="language-bash">mongod --config /usr/local/etc/mongod.conf
</code></pre>
<p>这个命令假设你在安装时使用了默认的配置文件路径 <code>/usr/local/etc/mongod.conf</code>。如果你的配置文件位于其他路径，请替换为实际的路径。</p>
<p>通过这些步骤，你可以成功地在 macOS 上重启 MongoDB 服务。</p>
<h2 id="用户管理"><a class="header" href="#用户管理">用户管理</a></h2>
<p>用户管理需要通过 Mongosh 操作，Mongosh 是嵌入到 MongoDB Compass 中的一个Javascript 运行环境，官方文档没怎么看懂</p>
<p><a href="https://www.mongodb.com/zh-cn/docs/mongodb-shell/reference/methods/#user-management-methods">官方 用户管理方式</a></p>
<p><strong>添加用户</strong></p>
<pre><code class="language-javascript">
use admin

db.createUser({
    user:"admin",
    pwd:"tzj001",
    roles:[
    {role:"readWrite",db:"TSIM"}]
})
</code></pre>
<p><strong>删除 <code>admin</code> 用户</strong></p>
<pre><code class="language-shell">db.drop("admin")
</code></pre>
<p><strong>查看当前用户</strong></p>
<pre><code class="language-javascript">db.getUsers()
</code></pre>
<p>或者</p>
<pre><code class="language-javascript">db.system.users.find()
</code></pre>
<p>或者</p>
<pre><code class="language-javascript">show users
</code></pre>
<h2 id="连接字符串"><a class="header" href="#连接字符串">连接字符串</a></h2>
<p>当在Web程序中配置MongoDB的连接字符串，有多种方式，简单的记录两种</p>
<p><strong>第一种</strong>： 连接本机上的 <strong>MongoDB</strong> ,适用于服务程序和数据库在同一个主机</p>
<pre><code class="language-txt">"ConnectionString": "mongodb://localhost:27017/数据库名称?authSource=admin",
</code></pre>
<p><strong>第二种</strong>： 连接非本机上的 <strong>MongoDB</strong> ,使用密码连接</p>
<pre><code class="language-txt">"ConnectionString": "mongodb://userName:password@domain:27017/数据库名称?authSource=admin",
</code></pre>
<p><strong>authSource=admin 说明</strong>：认证源属于管理员级别</p>
<h2 id="过滤器"><a class="header" href="#过滤器">过滤器</a></h2>
<p>当使用 MongoDB C# 驱动程序进行数据查询和操作时，可以通过 Builders <code>&lt;T&gt;</code>.Filter 构造过滤器（Filter），它们用于定义查询条件或者更新/删除操作的条件。以下是一些常用的过滤器方法及其用法解释：</p>
<h3 id="eq-方法"><a class="header" href="#eq-方法">Eq 方法</a></h3>
<p>Eq 方法用于创建一个等于（equal）条件的过滤器。它适用于需要匹配指定字段与特定值相等的情况。</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.Eq("fieldName", value);
</code></pre>
<p>例如，如果要查询字段 "name" 等于 "Alice" 的文档，可以使用：</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.Eq("name", "Alice");
</code></pre>
<h3 id="in-方法"><a class="header" href="#in-方法">In 方法</a></h3>
<p>In 方法用于创建一个包含于（in）条件的过滤器。它用于匹配指定字段的值在一个给定的列表或集合中的情况。</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.In("fieldName", values);
</code></pre>
<p>例如，如果要查询字段 "department" 的值在 ["IT", "HR", "Finance"] 中的文档，可以使用：</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.In("department", new List&lt;string&gt; { "IT", "HR", "Finance" });
</code></pre>
<h3 id="and-方法"><a class="header" href="#and-方法">And 方法</a></h3>
<p>And 方法用于创建一个与（and）条件的过滤器，即多个条件必须同时满足。</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.And(
    Builders&lt;BsonDocument&gt;.Filter.Eq("field1", value1),
    Builders&lt;BsonDocument&gt;.Filter.Eq("field2", value2)
);
</code></pre>
<p>例如，如果要查询同时满足 "name" 等于 "Alice" 和 "age" 大于等于 30 的文档，可以使用：</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.And(
    Builders&lt;BsonDocument&gt;.Filter.Eq("name", "Alice"),
    Builders&lt;BsonDocument&gt;.Filter.Gte("age", 30)
);
</code></pre>
<h3 id="gte-gt-lte-lt-等方法"><a class="header" href="#gte-gt-lte-lt-等方法">Gte, Gt, Lte, Lt 等方法</a></h3>
<p>这些方法用于创建比较条件的过滤器：</p>
<ul>
<li>Gte（greater than or equal）：大于等于</li>
<li>Gt（greater than）：大于</li>
<li>Lte（less than or equal）：小于等于</li>
<li>Lt（less than）：小于</li>
</ul>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.Gte("fieldName", value);
</code></pre>
<p>例如，如果要查询 "score" 大于等于 80 的文档，可以使用：</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.Gte("score", 80);
</code></pre>
<h3 id="组合多种过滤器"><a class="header" href="#组合多种过滤器">组合多种过滤器</a></h3>
<p>你可以通过组合多个过滤器来构建复杂的查询条件。例如，如果要查询 "department" 是 "IT" 或者 "HR" 且 "age" 大于等于 25 的文档，可以这样组合：</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.And(
    Builders&lt;BsonDocument&gt;.Filter.In("department", new List&lt;string&gt; { "IT", "HR" }),
);
</code></pre>
<h3 id="anyin-方法"><a class="header" href="#anyin-方法">AnyIn 方法</a></h3>
<p>在 MongoDB 的 C# 驱动程序中，AnyIn 方法用于创建一个过滤器，用于检查一个数组字段中是否至少包含一个指定的值。这在需要查询数组字段中是否存在特定元素的情况下非常有用。</p>
<p><strong>用法示例</strong></p>
<p>假设你有一个文档结构如下：</p>
<pre><code class="language-json">{
  "_id": ObjectId("60a9e54d95b06b84cf6e832f"),
  "name": "Alice",
  "interests": ["Reading", "Music", "Sports"]
}
</code></pre>
<p>其中，interests 是一个数组字段，包含了 Alice 的兴趣爱好。</p>
<p>如果你想要查询具有特定兴趣爱好的文档，例如查询兴趣包括 "Music" 或 "Sports" 的文档，可以使用 AnyIn 方法来构建过滤器：</p>
<pre><code class="language-csharp">var filter = Builders&lt;BsonDocument&gt;.Filter.AnyIn("interests", new BsonArray { "Music", "Sports" });
</code></pre>
<p><strong>解释</strong></p>
<p>Builders <code>&lt;BsonDocument&gt;</code>.Filter.AnyIn 方法用于创建一个数组字段的过滤器，该方法接受两个参数：</p>
<p>第一个参数是字段名 "interests"，这是你要进行过滤的数组字段。</p>
<p>第二个参数是一个 BsonArray，其中包含了要匹配的值的列表。在上面的例子中，我们使用了 new BsonArray { "Music", "Sports" } 来表示我们要查询包含 "Music" 或 "Sports" 的兴趣爱好的文档。</p>
<p><strong>注意事项</strong></p>
<p>AnyIn 方法是针对数组字段进行查询的一种特定方式。它只匹配数组中至少包含一个指定值的文档。如果数组字段中同时包含了多个指定值，文档也会被匹配。
在实际应用中，可以根据具体的业务需求和数据结构来灵活使用 AnyIn 方法，从而实现复杂的查询操作。
以上是关于 AnyIn 方法在 MongoDB C# 驱动程序中的基本用法和示例解释。</p>
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<p>以上是一些常见的 MongoDB C# 驱动程序中过滤器方法的用法。它们可以帮助你构建灵活且强大的查询条件，以满足各种数据查询、更新和删除的需求。在实际应用中，根据具体的业务需求和数据结构，你可以灵活地组合这些方法来实现复杂的数据操作。</p>
<h2 id="事务"><a class="header" href="#事务">事务</a></h2>
<p><a href="https://www.mongodb.com/docs/manual/core/transactions/">官方文档</a></p>
<pre><code class="language-C#">// For a replica set, include the replica set name and a seedlist of the members in the URI string; e.g.
// string uri = "mongodb://mongodb0.example.com:27017,mongodb1.example.com:27017/?replicaSet=myRepl";
// For a sharded cluster, connect to the mongos instances; e.g.
// string uri = "mongodb://mongos0.example.com:27017,mongos1.example.com:27017/";
var client = new MongoClient(connectionString);

// Prereq: Create collections.
var database1 = client.GetDatabase("mydb1");
var collection1 = database1.GetCollection&lt;BsonDocument&gt;("foo").WithWriteConcern(WriteConcern.WMajority);
collection1.InsertOne(new BsonDocument("abc", 0));

var database2 = client.GetDatabase("mydb2");
var collection2 = database2.GetCollection&lt;BsonDocument&gt;("bar").WithWriteConcern(WriteConcern.WMajority);
collection2.InsertOne(new BsonDocument("xyz", 0));

// Step 1: Start a client session.
using (var session = client.StartSession())
{
    // Step 2: Optional. Define options to use for the transaction.
    var transactionOptions = new TransactionOptions(
        writeConcern: WriteConcern.WMajority);

    // Step 3: Define the sequence of operations to perform inside the transactions
    var cancellationToken = CancellationToken.None; // normally a real token would be used
    result = session.WithTransaction(
        (s, ct) =&gt;
        {
            collection1.InsertOne(s, new BsonDocument("abc", 1), cancellationToken: ct);
            collection2.InsertOne(s, new BsonDocument("xyz", 999), cancellationToken: ct);
            return "Inserted into collections in different databases";
        },
        transactionOptions,
        cancellationToken);
}
</code></pre>
<h2 id="bson序列化特性"><a class="header" href="#bson序列化特性">Bson序列化特性</a></h2>
<h3 id="bsonignoreextraelements"><a class="header" href="#bsonignoreextraelements">BsonIgnoreExtraElements</a></h3>
<p><strong>类特性描述</strong>：反序列化时用来忽略多余的字段，一般版本兼容需要考虑，低版本的协议需要能够反序列化高版本的内容,否则新版本删除字段，旧版本结构反序列化会出错</p>
<p><strong>使用情况</strong></p>
<ol>
<li>新版本中将某个属性或字段删除</li>
<li>新版本中给某个属性或字段添加 <code>BsonIgnore</code> 特性</li>
</ol>
<p>注意，若在基类中定义的属性，也需要在子类中添加此特性才有效！</p>
<h2 id="时区"><a class="header" href="#时区">时区</a></h2>
<p><strong>原因1：</strong> MongoDB自带的Date是UTC的时间，中国是东八区，所以差了8个小时。</p>
<p><strong>解决方法：</strong> 在mongodb可视化工具Robomongo中，我们可以通过"Options" - “Display Dates in…” - "Local Timezone"来设置显示本地时间。</p>
<p><strong>原因2：</strong> MongoDB中存储的时间是标准时间 <code>UTC +0:00</code></p>
<p><strong>解决方法：</strong> C#的驱动支持一个特性，将实体的时间属性上添加上这个特性并指时区就可以了。</p>
<p>例如：</p>
<pre><code class="language-csharp">[BsonDateTimeOptions(Kind = DateTimeKind.Local)]
public DateTime CreateTime{get;set;}
</code></pre>
<h2 id="数据库迁移"><a class="header" href="#数据库迁移">数据库迁移</a></h2>
<blockquote>
<p>Windows 环境
工具：Cmd、PowerShell</p>
</blockquote>
<p>将 MongoDB 数据库迁移到另一台服务器或集群通常涉及以下几个步骤：</p>
<ol>
<li>安装 Mongodb 数据库工具</li>
<li>备份现有数据库</li>
<li>将备份文件传输到目标服务器</li>
<li>在目标服务器上恢复备份</li>
</ol>
<p>具体步骤如下：</p>
<h3 id="安装-mongodb-数据库工具"><a class="header" href="#安装-mongodb-数据库工具">安装 MongoDB 数据库工具</a></h3>
<blockquote>
<p>注意：我们安装 Mongodb 数据库时，并没有附带安装 mongodb 的命令行工具，需要另外下载</p>
</blockquote>
<p><strong>1. 下载工具</strong></p>
<ul>
<li>访问 <a href="https://www.mongodb.com/try/download/database-tools">MongoDB Command Line Database Tools Download</a></li>
<li>选择适用于你的操作系统（Windows）的安装包进行下载。</li>
</ul>
<p><strong>2. 安装工具</strong></p>
<p>下载完成后，解压缩安装包并将其内容放置在你希望安装的目录中，例如 C:\mongodb-database-tools。</p>
<p><strong>3. 配置环境变量</strong></p>
<p>为了在命令提示符中使用 <code>mongodump</code> 和 <code>mongorestore</code> 命令，需要将 MongoDB 数据库工具的安装路径添加到系统的 PATH 环境变量中：</p>
<ul>
<li>右键单击“此电脑”或“计算机”图标，然后选择“属性”。</li>
<li>在左侧菜单中选择“高级系统设置”。</li>
<li>在“系统属性”窗口中，点击“环境变量”按钮。</li>
<li>在“系统变量”部分找到并选择 Path 变量，然后点击“编辑”。</li>
<li>在“编辑环境变量”窗口中，点击“新建”，并输入 MongoDB 数据库工具的安装路径，例如 <code>C:\mongodb-database-tools\bin</code>。</li>
<li>点击“确定”保存更改。</li>
</ul>
<p><strong>4. 重启命令提示符：</strong></p>
<p>关闭所有打开的命令提示符窗口，然后重新打开一个新的命令提示符窗口，以确保更改生效。</p>
<p><strong>5. 验证安装</strong></p>
<p>打开新的命令提示符窗口，输入以下命令以验证 mongodump 是否可用：</p>
<pre><code class="language-powershell">mongodump --version
</code></pre>
<p>如果命令输出了版本信息，则说明安装和配置成功，现在，可以使用 mongodump 和 mongorestore 命令来备份和恢复 MongoDB 数据库。</p>
<h3 id="备份现有数据库"><a class="header" href="#备份现有数据库">备份现有数据库</a></h3>
<p>你可以使用 mongodump 工具来创建数据库的备份。以下是命令示例：</p>
<pre><code class="language-cmd">mongodump --uri="mongodb://username:password@source_host:port/dbname" --out=/path/to/backup
</code></pre>
<p>这个命令会把 dbname 数据库的所有数据导出到指定路径 /path/to/backup。</p>
<h3 id="定时备份"><a class="header" href="#定时备份">定时备份</a></h3>
<blockquote>
<p>☀️最好创建定时任务，定时备份数据，避免数据丢失。</p>
</blockquote>
<p><strong>一、创建定时任务脚本，示例：</strong></p>
<pre><code class="language-bat">@echo off

:: 处理时间的小时数为个位数时，出现空格问题。使用0补位
set t=%time:~0,2%%time:~3,2%%time:~6,2%
set t=%t: =0%


:: 定义备份目录（可以根据需要更改）
set backupDir=C:\TZJ\TSIM\mongodb_backup\backup\%date:~0,4%-%date:~5,2%-%date:~8,2%-%t%

:: 创建备份目录
if not exist %backupDir% (
    mkdir %backupDir%
)

:: 备份 MongoDB 数据库（修改为实际的数据库和路径）
mongodump --uri="mongodb://localhost:27017/TSIM" --out=%backupDir%

:: 输出备份完成信息
echo Backup completed at %date% %time%

</code></pre>
<blockquote>
<p>⚠️ 脚本注意事项</p>
<ul>
<li>需要处理当小时数小于10时出现空格，需要补位0</li>
<li>脚本中不要出现 <code>pause</code>，否则在计划中，当前实例会一直存在，导致后续无法创建新实例（在设置中默认配置“请勿创建新实例”），即使设置了可以并行运行，那也会无限制的创建新实例，资源浪费。</li>
</ul>
</blockquote>
<p><strong>二、配置 Windows 任务计划程序</strong></p>
<p>通过 Windows 任务计划程序来定时执行上面的备份脚本。</p>
<p>步骤：</p>
<ul>
<li>打开任务计划程序：按下 Win + S，搜索“任务计划程序”并打开。</li>
<li>创建基本任务：</li>
<li>在任务计划程序窗口中，点击右侧的“创建基本任务”。</li>
<li>为任务命名，例如“MongoDB 定时备份”。</li>
<li>选择触发器，例如每日、每周、每月等。比如选择“每日”。</li>
<li>设置时间，选择希望执行任务的时间。</li>
<li>设置操作：</li>
<li>在“操作”步骤，选择“启动程序”。</li>
<li>浏览并选择上一步中创建的批处理文件 (例如 backup_mongo.bat)。</li>
<li>完成任务：点击完成，任务将自动按照设置的计划执行。</li>
</ul>
<p><strong>三、验证任务</strong></p>
<p>完成后可以手动运行任务以验证是否正常工作。在任务计划程序中，右键点击任务，选择“运行”，查看备份文件是否生成。</p>
<h3 id="将备份文件传输到目标服务器"><a class="header" href="#将备份文件传输到目标服务器">将备份文件传输到目标服务器</a></h3>
<p>你可以使用 scp 命令（对于 Linux）或其他文件传输工具（如 SFTP、FTP 等）将备份文件传输到目标服务器：</p>
<p>Windows</p>
<p>通过远程桌面直接拷贝即可。</p>
<p>Linux</p>
<pre><code class="language-bash">scp -r /path/to/backup user@target_host:/path/to/destination
</code></pre>
<h3 id="在目标服务器上恢复备份"><a class="header" href="#在目标服务器上恢复备份">在目标服务器上恢复备份</a></h3>
<p>在目标服务器上使用 mongorestore 工具来恢复备份的数据：</p>
<pre><code class="language-bash">mongorestore --uri="mongodb://username:password@target_host:port/dbname" /path/to/destination/backup
</code></pre>
<h3 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h3>
<p>SASL（Simple Authentication and Security Layer）错误通常与身份验证和安全相关，特别是在连接到 MongoDB 时使用用户名和密码进行身份验证时。为了排查和解决这个问题，请按照以下步骤操作：</p>
<p><strong>1. 检查连接字符串</strong></p>
<p>确保你的连接字符串格式正确，包括用户名、密码、主机和端口，例如：</p>
<pre><code class="language-bash">mongodb://username:password@source_host:port/dbname
</code></pre>
<p><strong>2. 使用 URI 编码特殊字符</strong></p>
<p>如果用户名或密码中包含特殊字符（如 @, :, # 等），需要对这些字符进行 URI 编码。你可以使用 <a href="https://www.bejson.com/enc/urlencode/">URL编码在线工具 </a> 来对特殊字符进行编码，常见的有：</p>
<ul>
<li><code>@ 编码为 %40</code></li>
<li><code>: 编码为 %3A</code></li>
<li><code># 编码为 %23</code></li>
<li><code>% 编码为 %25</code></li>
</ul>
<p>例如，如果密码是 pa@ss:word#123，则连接字符串应为：</p>
<pre><code class="language-bash">mongodb://username:pa%40ss%3Aword%23123@source_host:port/dbname
</code></pre>
<p><strong>3. 使用 --authenticationDatabase 选项</strong></p>
<p>如果用户名和密码属于 admin 数据库（或其他非目标数据库），需要指定 --authenticationDatabase 选项。例如：</p>
<p>备份数据库：</p>
<pre><code class="language-bash">mongodump --uri="mongodb://username:password@source_host:27017/dbname" 
--authenticationDatabase="admin" --out="C:\path\to\backup"
</code></pre>
<p>恢复数据库：</p>
<pre><code class="language-bash">mongorestore --uri="mongodb://username:password@target_host:27017/dbname" --authenticationDatabase="
</code></pre>
<p><strong>4. 启用 SCRAM-SHA-1 或 SCRAM-SHA-256</strong></p>
<p>MongoDB 3.0 及以上版本默认使用 SCRAM-SHA-1 进行身份验证，MongoDB 4.0 及以上版本默认使用 SCRAM-SHA-256。如果你的 MongoDB 服务器配置了不同的身份验证机制，需要确保客户端也支持该机制。</p>
<h3 id="其他注意事项"><a class="header" href="#其他注意事项">其他注意事项</a></h3>
<p><strong>确保版本兼容性</strong>：确保源 MongoDB 服务器和目标 MongoDB 服务器的版本兼容。如果版本差异过大，可能需要进行数据格式的转换。</p>
<p><strong>网络带宽和速度</strong>： 考虑到数据传输的时间和速度，特别是对于大数据量的情况下，可能需要更长的时间。</p>
<p><strong>安全性</strong>：在传输敏感数据时，请确保使用安全的传输协议和方法。</p>
<h3 id="使用-mongodb-atlas"><a class="header" href="#使用-mongodb-atlas">使用 MongoDB Atlas</a></h3>
<p>如果你使用的是 MongoDB Atlas，MongoDB 官方提供了一些迁移工具，如 mongomirror，可以帮助你将自托管的 MongoDB 数据库迁移到 Atlas 上。这些工具可以实现实时数据同步和迁移。</p>
<h3 id="在线迁移"><a class="header" href="#在线迁移">在线迁移</a></h3>
<p>如果你需要在迁移过程中保持数据库的高可用性，可以考虑使用 MongoDB 的副本集（replica set）来进行无缝迁移。这个方法更为复杂，但可以确保在迁移过程中数据的持续可用。</p>
<h2 id="windows-账户问题"><a class="header" href="#windows-账户问题">Windows 账户问题</a></h2>
<p>使用 windwos 账户A 安装 MongoDB，切换到 windows 账户B 通过localhost:27017 来访问可能失败</p>
<p>这通常与文件和服务的权限设置有关。以下是详细的解决方法：</p>
<ol>
<li>为账户B授予MongoDB安装目录的访问权限
<ul>
<li>打开 MongoDB 安装目录（通常是 C:\Program Files\MongoDB\Server&lt;version&gt;\）。</li>
<li>右键点击安装目录，选择“属性”。</li>
<li>转到“安全”选项卡，点击“编辑”按钮。</li>
<li>点击“添加”按钮，输入账户B的用户名，然后点击“检查名称”确认。</li>
<li>为账户B授予“读取和运行”、“列出文件夹内容”、“读取”和其他必要的权限。</li>
<li>点击“应用”并保存更改。</li>
</ul>
</li>
<li>配置MongoDB服务的权限（重启即可）
<ul>
<li>打开“服务”窗口（按 Win + R，输入 services.msc，然后按 Enter）。</li>
<li>找到 MongoDB 服务，右键点击选择“属性”。</li>
<li>转到“登录”选项卡。</li>
<li>选择“此账户”，然后输入账户A的用户名和密码。</li>
<li>点击“应用”并重启MongoDB服务。</li>
</ul>
</li>
</ol>
<p><strong>备注：MongoDBCompass 的安装是在账户目录下：<code>C:\Users\XXX\AppData\Local\MongoDBCompass</code></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synology-群晖"><a class="header" href="#synology-群晖">Synology (群晖)</a></h1>
<h2 id="putty-连接"><a class="header" href="#putty-连接">Putty 连接</a></h2>
<h3 id="登录群晖"><a class="header" href="#登录群晖">登录群晖</a></h3>
<ol>
<li>使用SSH，输入地址，端口（22） 打开命令窗口</li>
<li>输入群晖账户和密码</li>
<li>输入 sudo -i 切换到root 下，提供权限，此时，再次输入账号的密</li>
<li>输入: cd /volume1 切换到容器1，这里根据你的容器名称</li>
<li>然后使用 ls 查看内容列表</li>
</ol>
<h3 id="运行python-程序"><a class="header" href="#运行python-程序">运行Python 程序</a></h3>
<p>需要先安装Python，直接在套件中安装即可。</p>
<p>运行python，切换到对应文件夹下，python3 test.py</p>
<h2 id="powershell-连接"><a class="header" href="#powershell-连接">PowerShell 连接</a></h2>
<p>群晖上启动 SSH 功能，并设置一个可以访问的端口默认22如果不能访问，设置其他端口</p>
<p><img src="synology/image/synology/1721886156722.png" alt="1721886156722" /></p>
<p>使用 PowerShell 登录，输入 <code>ssh username@domain -p port</code>，账号和地址真确，会提示 <code>ECDSA host key for ip address 否则提示： not in list of known hosts</code> ，然后提示输入密码，输入密码不可见，输入成功后显示账号和主机名称。</p>
<p><img src="synology/image/synology/1721886427739.png" alt="1721886427739" /></p>
<p>切换到root账户，可以看到当前是 <code>$</code> 符号，表示非root账号，输入：<code>sudo -i</code>， 再次输入密码，此时变为 <code>#</code> ，表示 root 账户</p>
<p><img src="synology/image/synology/1721886444618.png" alt="1721886444618" /></p>
<p>切换到根目录 <code>cd ..</code>,将 ~# 变为 /#，并用 <code>ls</code> ,查看目录</p>
<p><img src="synology/image/synology/1721886458497.png" alt="1721886458497" /></p>
<p><code>/</code> : 表示根节点</p>
<p><code>~</code> : 表示当前登录用户的 home 目录</p>
<p>如果以 <code>root </code>账号登陆，<code>~</code> 代表 <code>/root/</code> 目录，当你任何环境下输入： <code>#cd ~</code> 会进入到 <code>/root</code> 目录。</p>
<h2 id="docker-操作"><a class="header" href="#docker-操作">Docker 操作</a></h2>
<h3 id="查询镜像"><a class="header" href="#查询镜像">查询镜像</a></h3>
<p>docker 安装在 <code>lib64</code> 里面 ，输入 <code>cd lib64</code></p>
<p><strong>列出容器</strong>：<code>docker ps</code>，<a href="https://www.runoob.com/docker/docker-ps-command.html">命令手册</a></p>
<p><img src="synology/image/synology/1721887061068.png" alt="1721887061068" /></p>
<p><strong>获取容器</strong>/镜像的元数据：<code>docker inspect</code>，如：查看WIKI这个容器的所有挂载信息：</p>
<p><img src="synology/image/synology/1721887074140.png" alt="1721887074140" /></p>
<p>命令说明：</p>
<ul>
<li><code>grep</code>: 表示全局正则表达式</li>
<li><code>Mounts</code>: 匹配挂载开始</li>
<li><code>-A</code> : 所有</li>
<li><code>100</code> : 返回的行数</li>
<li><code>Source</code>: 宿主的目录，也就是我们看得见的目录</li>
<li><code>Destination</code>: 容器目录</li>
</ul>
<h3 id="拉取镜像"><a class="header" href="#拉取镜像">拉取镜像</a></h3>
<p>现在的群晖在 <code>Docker hub</code> 里面显示查询镜像失败，获取不到镜像，使用命令行获取</p>
<p><a href="https://www.bilibili.com/video/BV1ns4y1q79g/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ae505290000a9de26b4d6c8111c5e5dd">B站视频</a></p>
<p>参照命令行章节，连接群晖</p>
<p><code>sudo -i</code> 获取到超级用户权限</p>
<p>搜索镜像，如: mongo，如数命令：</p>
<pre><code class="language-shell">docker search mongo
</code></pre>
<p>搜索结果：</p>
<pre><code class="language-shell">NAME                              DESCRIPTION                      STARS     OFFICIAL   AUTOMATED
mongo                             MongoDB document databases ...   1989      [OK]     
mongo-express                     Web-based MongoDB admin int...   22        [OK]     
mvertes/alpine-mongo              light MongoDB container          19                   [OK]
mongooseim/mongooseim-docker      MongooseIM server the lates...   9                    [OK]
torusware/speedus-mongo           Always updated official Mon...   9                    [OK]
jacksoncage/mongo                 Instant MongoDB sharded cluster  6                    [OK]
mongoclient/mongoclient           Official docker image for M...   4                    [OK]
jadsonlourenco/mongo-rocks        Percona Mongodb with Rocksd...   4                    [OK]
asteris/apache-php-mongo          Apache2.4 + PHP + Mongo + m...   2                    [OK]
19hz/mongo-container              Mongodb replicaset for coreos    1                    [OK]
nitra/mongo                       Mongo3 centos7                   1                    [OK]
ackee/mongo                       MongoDB with fixed Bluemix p...  1                    [OK]
kobotoolbox/mongo                 https://github.com/kobotoolb...  1                    [OK]
valtlfelipe/mongo                 Docker Image based on the la...  1                    [OK]
</code></pre>
<p>拉取镜像：<code> docker pull mongo:latest</code>，冒号后面需要跟版本号（latest：表示最新的版本号）</p>
<p>使用中转加速拉取，在群晖里面配置加速</p>
<p><strong>本期涉及的一些网站和链接</strong>：</p>
<ul>
<li><a href="https://hub.docker.com/">Dockerhub仓库1</a></li>
<li><a href="https://registry.hub.docker.com">Dockerhub仓库2</a></li>
<li><a href="https://dockerproxy.com/">镜像代理加速网站</a></li>
<li><a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6">镜像加速器地址</a></li>
<li><a href="https://www.putty.be/latest.html">putty官网</a></li>
</ul>
<h2 id="mysql-1"><a class="header" href="#mysql-1">MySQL</a></h2>
<p><code>&lt;a name="mysql-install"&gt;&lt;/a&gt;</code></p>
<h3 id="安装-2"><a class="header" href="#安装-2">安装</a></h3>
<p>下载镜像后启动安装，仅需要设置下端口映射和环境变量，其他保持默认。</p>
<p><img src="synology/image/synology/1721887472748.png" alt="1721887472748" /></p>
<h3 id="操作"><a class="header" href="#操作">操作</a></h3>
<p>浏览器登录 <code>DSM</code>，进入 <code>Mysql</code> 容器，选择终端机，点击新增，选择新增的 <code>bash</code>（不能使用默认的控制台，需要新增一个控制台）</p>
<pre><code class="language-bash">#这里不知道为什么不能输入123，是复制的
mysql -uroot -ptzj123
</code></pre>
<p><img src="synology/%E7%BE%A4%E6%99%96%E4%BD%BF%E7%94%A8Putty/image-20220307113952416.png" alt="image-20220307113952416" /></p>
<p>使用 <code>help</code> 命令查看</p>
<h2 id="wiki"><a class="header" href="#wiki">Wiki</a></h2>
<h3 id="安装-3"><a class="header" href="#安装-3">安装</a></h3>
<p><strong>环境需求说明</strong>：2核 1G内存</p>
<p>打开Dcoker，在注册表搜索 <code>wiki</code>,找到 <code>requarks/wiki</code> ，选中后点击下载</p>
<p><img src="synology/image/synology/1721888262468.png" alt="1721888262468" /></p>
<p>下载后在映像如图</p>
<p><img src="synology/image/synology/1721888271732.png" alt="1721888271732" /></p>
<h3 id="配置mysql数据库"><a class="header" href="#配置mysql数据库">配置mysql数据库</a></h3>
<p>Mysql容器的安装参考: <a href="synology/synology.html#mysql-install">MySQL 安装</a></p>
<p>在数据库里面创建好数据库，如:wiki</p>
<h3 id="配置环境变量"><a class="header" href="#配置环境变量">配置环境变量</a></h3>
<p><a href="https://docs.requarks.io/install/docker">官方手册</a></p>
<p><strong>启动镜像</strong>：在镜像列表中选中 <code>wiki</code> ，点击<strong>启动</strong>：</p>
<p><img src="synology/image/synology/1721889057429.png" alt="1721889057429" /></p>
<p><strong>常规设置</strong>:填写容器名称，然后点击 <strong>高级设置</strong></p>
<p><img src="synology/image/synology/1721889072045.png" alt="1721889072045" /></p>
<p><strong>高级设置</strong>：启用自动重新启动，可勾选</p>
<p><img src="synology/image/synology/1721889096301.png" alt="1721889096301" /></p>
<p><strong>端口配置</strong>，<code>http：3000</code>，<code>https：3443</code>（但是目前无法使用）</p>
<p><img src="synology/image/synology/1721889115653.png" alt="1721889115653" /></p>
<p><strong>配置环境变量，根据官方手册如下</strong>：</p>
<p><img src="synology/image/synology/1721889177004.png" alt="1721889177004" /></p>
<p><strong>对应配置如下</strong>：</p>
<p><img src="synology/image/synology/1721889238900.png" alt="1721889238900" /></p>
<h3 id="配置文件启动"><a class="header" href="#配置文件启动">配置文件启动</a></h3>
<p>使用配置文件启动，需要存储空间进行挂载，让容器加载我们挂载的配置文件。</p>
<p>官网上对挂载配置文件说明，看到容器会读取 /wiki/config.yml配置文件，<a href="https://github.com/Requarks/wiki/blob/main/config.sample.yml">配置文件模板</a></p>
<p><img src="synology/image/synology/1721889365564.png" alt="1721889365564" /></p>
<p>群晖上的目录</p>
<p><img src="synology/image/synology/1721889374780.png" alt="1721889374780" /></p>
<p>编辑好配置文件后，按照下图挂载，忽略 content 的挂载</p>
<p><img src="synology/image/synology/1721889389093.png" alt="1721889389093" /></p>
<p>配置文件主要内容：</p>
<p><img src="synology/image/synology/1721889420293.png" alt="1721889420293" /></p>
<p>启动容器，使用 <code> http://你的IP地址或者域名:3000</code>访问</p>
<p>注意还不能使用https访问，这是个问题，后面会讲</p>
<h3 id="https访问"><a class="header" href="#https访问">HTTPS访问</a></h3>
<p><strong>停止容器</strong></p>
<p><strong>注</strong>：官网上说可以简单配置 <code>LETSENCRPT</code> 实现 <code>Https</code>，但是没成功，还是使用自定义密钥的方式来做</p>
<p><img src="synology/image/synology/1721890749526.png" alt="1721890749526" /></p>
<p><strong>创建证书</strong>，参看 <a href="synology/drive.html">创建证书</a></p>
<p><strong>挂载证书目录</strong>，还是看下图，我们会将证书拷贝到 docker/wiki/data/content中</p>
<p><img src="synology/image/synology/1721890845501.png" alt="1721890845501" /></p>
<p><strong>为什么是这个目录？</strong>  首先，通过 <code>docker inspect wiki</code> 查看这个目录是容器本身存在的，并且可以挂载的，我们也可以挂载其他的目录，但是必须是/wiki/...这样的。</p>
<p><strong>！！！不能直接挂载/wiki/data ！！！</strong></p>
<p><strong>下载证书</strong>，创建后下载下来，解压拷贝到群晖的文件夹下</p>
<p><img src="synology/image/synology/1721890855919.png" alt="1721890855919" /></p>
<p><strong>修改配置文件</strong></p>
<p><img src="synology/image/synology/1721890867533.png" alt="1721890867533" /></p>
<p><strong>启动容器</strong>，使用 <code>https://你的ip或者域名:3443</code> 访问</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="证书"><a class="header" href="#证书">证书</a></h1>
<h2 id="新增证书"><a class="header" href="#新增证书">新增证书</a></h2>
<p>打开 <strong>控制面板</strong> -&gt; <strong>安全性</strong> -&gt; <strong>证书</strong></p>
<p><img src="synology/image/certficate/1721890353286.png" alt="1721890353286" /></p>
<p>点击 <strong>新增</strong>，打开 <strong>创建证书</strong> 面板</p>
<p><img src="synology/image/certficate/1721890369541.png" alt="1721890369541" /></p>
<p>点击 <strong>下一步</strong></p>
<p><img src="synology/image/certficate/1721890416094.png" alt="1721890416094" /></p>
<p>选择 <strong>创建自我签署证书</strong>，点击 <strong>下一步</strong></p>
<p>后面的依次填写信息创建即可。</p>
<p>Mysql容器的安装参考: <a href="synology/synology.html#mysql-install">MySQL 安装</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drive"><a class="header" href="#drive">Drive</a></h1>
<h2 id="证书过期"><a class="header" href="#证书过期">证书过期</a></h2>
<p>选中 Nas 主机，出现 <strong>编辑连接</strong> 按钮，点击按钮输入密码即可。</p>
<p><img src="synology/image/drive/1721889904289.png" alt="1721889904289" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反向代理服务器"><a class="header" href="#反向代理服务器">反向代理服务器</a></h1>
<p><strong>应用场景</strong>：解决容器中的服务只能使用 <code>http</code> 访问问题。</p>
<p>以下描述 通过 <code>https</code> 访问Nas，通过反向代理访问容器中的 <code>http</code> 服务器。</p>
<ol>
<li>点击DSM控制面板-&gt;登录门户-&gt;高级-&gt;反向代理服务器</li>
<li>添加<strong>反向代理服务器</strong>按钮，弹出窗口，点击新增</li>
<li>填写名称</li>
<li>来源协议：选择 https</li>
<li>来源主机名：*，代表说有来源</li>
<li>来源端口：填写一个Nas未使用的端口</li>
<li>目的地协议：http</li>
<li>目的地主机名：这里填写容器所在的网关，一般为 <code>172.17.0.1</code></li>
</ol>
<p><img src="synology/assets/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/image-1.png" alt="alt text" /></p>
<ol start="9">
<li>目的地端口：容器的端口，注意这里不是容器绑定的本机端口</li>
</ol>
<p>配置完整截图</p>
<p><img src="synology/assets/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/image.png" alt="alt text" /></p>
<ol start="10">
<li>自定义标题和高级设置默认，点击保存</li>
<li>控制面板-&gt;外部访问-&gt;路由器配置中，新增-&gt;内置配置，选择反向代理（端口为8007）添加，即可访问</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-1"><a class="header" href="#windows-1">Windows</a></h1>
<h2 id="安装-4"><a class="header" href="#安装-4">安装</a></h2>
<p><strong>官网下载</strong></p>
<p><a href="https://www.microsoft.com/zh-cn/software-download/windows10">官网</a> 可以更新当前系统，以及通过下载工具下载系统制作成 U盘 或者 下载IOS文件</p>
<p>当下载工具后运行，可选择(win10和win11相同操作):</p>
<ul>
<li><strong>U盘</strong>：制作U盘</li>
<li><strong>IOS文件</strong>：保存文件</li>
</ul>
<p><strong>其他下载</strong></p>
<ul>
<li>
<p><a href="https://www.zhihu.com/search?type=content&amp;q=windows%20%E5%8E%9F%E7%89%88%E4%B8%8B%E8%BD%BD">知乎文档</a></p>
</li>
<li>
<p><a href="https://msdn.sjjzm.com/win10.html">山己几子木 下载</a></p>
</li>
<li>
<p><a href="https://www.hellowindows.cn/">HelloWindwos 下载</a></p>
</li>
<li>
<p><a href="https://link.zhihu.com/?target=https%3A//www.xitongku.com/">xitongku 下载</a></p>
</li>
</ul>
<p><strong>- 最好使用原版的安装文件，不要使用各种PE自带的系统，如韩博士的在线安装会自带很多垃圾软件、垃圾游戏、垃圾广告</strong></p>
<h2 id="设置共享"><a class="header" href="#设置共享">设置共享</a></h2>
<p>选择要共享的文件夹，打开属性，共享标签，设置为共享</p>
<p>设置可以访问的账户，如果希望无密码共享，选择Everyone，并设置权限为完全控制</p>
<p>设置网络控制中心，启用文件共享，设置所有网络无密码</p>
<h2 id="磁盘管理"><a class="header" href="#磁盘管理">磁盘管理</a></h2>
<p>进行分区等操作</p>
<p>右键 <code>WIN</code> 图标或者按下 <code>win+x</code> -&gt; 磁盘管理</p>
<h2 id="删除时找不到该项目"><a class="header" href="#删除时找不到该项目">删除时找不到该项目</a></h2>
<p>使用 <code>bat</code> 文件处理</p>
<ul>
<li>新建 <code>bat</code> 文件，内容：</li>
</ul>
<pre><code class="language-bat">:: 将要处理的文件或者文件夹拖到此命令文件上
DEL /F /A /Q \\?\%1
RD /S /Q \\?\%1
</code></pre>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/577237417?utm_id=0">知乎文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="winsw"><a class="header" href="#winsw">WinSW</a></h1>
<blockquote>
<p>Windows Service Wrapper in a permissive license</p>
<p>在 Windows 中将普通程序作为服务安装，这样开机可自动运行，避免去添加任务计划</p>
</blockquote>
<p><a href="https://github.com/winsw/winsw">github-仓库地址</a></p>
<h2 id="实例安装nginx服务"><a class="header" href="#实例安装nginx服务">实例：安装Nginx服务</a></h2>
<p><strong>普通使用模式</strong>：运行 Nginx 后，直接闪过一个控制台窗口，在任务管理器中查看 <strong>Nginx</strong> 是否运行，电脑重启后需要手动去启动，有点不方便</p>
<p><strong>使用WinSW将Nginx安装为服务</strong>：</p>
<ol>
<li>下载 Nginx并解压，假设解压后的路径为 <code>D:\nginx-1.25.4</code></li>
<li>下载 WinSW，下载后是一个 <code>WinSW-x64.exe</code> 文件，将其放到 <code>D:\nginx-1.25.4</code> 下，也就是和 <code>nginx.exe</code> 同层级</li>
<li>将 <code>WinSW-x64.exe</code>  重命名为 <code>nginx-service.exe</code></li>
<li>创建文件 <code>nginx-service.xml</code> 文件</li>
</ol>
<pre><code class="language-xml">&lt;!-- nginx-service.xml --&gt;
&lt;service&gt;
    &lt;id&gt;nginx&lt;/id&gt;
    &lt;name&gt;nginx&lt;/name&gt;
    &lt;description&gt;nginx&lt;/description&gt;
    &lt;logpath&gt;logs&lt;/logpath&gt;
    &lt;logmode&gt;roll&lt;/logmode&gt;
    &lt;depend&gt;&lt;/depend&gt;
    &lt;executable&gt;nginx.exe&lt;/executable&gt;
	&lt;arguments&gt;--service&lt;/arguments&gt;
&lt;/service&gt;
</code></pre>
<pre><code>- id: 服务id，假设启动了多个 nginx ，这里需要填一个唯一的
- name: 服务名称
- description：服务描述
- logpath：日志保存的文件夹，当前目录的logs文件夹下，这里不要填绝对路径，否则文件移动后就不对了
- logmode：日志模式，滚动
- executable：服务安装的二进制文件，这里不要填绝对路径，否则文件移动后就不对了
- arguments：服务启动时，命令行参数：如果有需要就填，这里没有需要可以不填
</code></pre>
<ol start="5">
<li>以管理员身份运行 <code>PowerShell</code></li>
<li>将目录切换到 <code>nginx.exe</code> 相同的目录
<ol>
<li>执行语句 <code>nginx-service.exe install</code> 进行服务安装，名称为：<code>nginx</code>，可通过 <code>logs/nginx-service.wrapper.log</code> 查看日志信息</li>
<li>执行语句 <code>nginx-service.exe start</code> 启动服务</li>
<li>执行语句 <code>nginx-service.exe stop</code> 停止服务</li>
<li>执行语句 <code>nginx-service.exe restart</code> 重启服务</li>
<li>执行语句 <code>nginx-service.exe uninstall</code> 卸载服务</li>
</ol>
</li>
<li>打开服务窗口里面同样可以进行相关的操作</li>
</ol>
<h2 id="服务模式下不要操作窗口句柄"><a class="header" href="#服务模式下不要操作窗口句柄">服务模式下不要操作窗口句柄</a></h2>
<p>控制台程序中不要使用和界面相关的接口，如下面这段代码将会出现获取句柄为空的错误</p>
<pre><code class="language-c#"> [DllImport("user32.dll ", EntryPoint = "RemoveMenu")]
 extern static int RemoveMenu(IntPtr hMenu, int nPos, int flags);

 private static void SetWinStyle()
 {

    /* 设置窗口样式 */

    Console.WindowWidth = 120;
    Console.BufferWidth = 220;//240 为最大值 保证可以换行
    Console.BufferHeight = 1000;

    Console.Title = title;
    //与控制台标题名一样的路径
    //  string fullPath = System.Environment.CurrentDirectory + "\\" + title + ".exe";

#if !DEBUG
    //根据控制台标题找控制台
    int WINDOW_HANDLER = FindWindow(null, Console.Title);
    Thread.Sleep(100);
    //找关闭按钮
    IntPtr CLOSE_MENU = GetSystemMenu((IntPtr)WINDOW_HANDLER, IntPtr.Zero);
    int SC_CLOSE = 0xF060;
    //关闭按钮禁用
    RemoveMenu(CLOSE_MENU, SC_CLOSE, 0x0);
#endif
    Console.CancelKeyPress += new ConsoleCancelEventHandler(CloseConsole);
}
</code></pre>
<p><strong>解决方案</strong>：</p>
<p>这里就要用到命令行参数，在 <code>xxx-service.xml</code> 文件中添加一个参数 <code>&lt;arguments&gt;--service&lt;/arguments&gt;</code> ，如果多个参数空格隔开</p>
<p>当使用服务启动时，命令行参数中将包含： <code>--service</code> 参数</p>
<pre><code class="language-c#">  //这里根据命令行参数来判断是否为服务模式启动，服务模式下不能设置窗口样式

  bool isServiceMode = args.Contains("--service");
  if (!isServiceMode)//非服务下，设置窗口样式
  {
      SetWinStyle(); 
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table ,.excel-table-c2 {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th,.excel-table-c2 th, .excel-table td,.excel-table-c2 td {
    border: 1px solid #d0d7de;
    padding: 12px;
    text-align: left;
    vertical-align: top; 
}

.excel-table th,.excel-table-c2 th  {
    background-color: #f0f3f5;
    font-weight: bold;
}

.excel-table tr:nth-child(even),.excel-table-c2 tr:nth-child(even) {
    background-color: #f9f9f9;
}

/* .excel-table tr:hover {
    background-color: #e9e9e9;
} */

.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    width: 20%;
    font-weight: bold;
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 40%;
}
.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width: 40%;
}

/*c2*/
.excel-table-c2 th:nth-child(1), .excel-table-c2 td:nth-child(1) {
    width: 50%;
    /* font-weight: bold; */
}

.excel-table-c2 th:nth-child(2), .excel-tablec-2 td:nth-child(2) {
    width: 50%;
}

</style>
<h1 id="windows-命令行"><a class="header" href="#windows-命令行">Windows 命令行</a></h1>
<h2 id="cd"><a class="header" href="#cd">cd</a></h2>
<p>更改当前目录。</p>
<p><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/cd">官网</a></p>
<h2 id="命令行语法项"><a class="header" href="#命令行语法项">命令行语法项</a></h2>
<p>下表描述用于指示命令行语法的表示法。</p>
<div class="table-container">
    <table class="excel-table-c2">
        <thead>
            <tr>
                <th>表示法</th>
                <th>说明</th>   
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>不含方括号或大括号的文本</td>
                <td>必须按所显示键入的项。</td>
            </tr>
              <tr>
                <td><code><Text inside angle brackets></code></td>
                <td>必须为其提供值的占位符。</td>
            </tr>
             <tr>
                <td><code>[Text inside square brackets]</code></td>
                <td>可选项。</td>
            </tr>
            <tr>
                <td><code>{Text inside braces}</code></td>
                <td>一组必需的项。 你必须选择一个。</td>
            </tr>
             <tr>
                <td>竖线 (|</code>)</td>
                <td>互斥项的分隔符。 你必须选择一个。</td>
            </tr>
             <tr>
                <td>省略号 (…)</td>
                <td>可重复使用多次的项。</td>
            </tr>
        </tbody>
    </table>
</div>
<h2 id="创建批处理文件"><a class="header" href="#创建批处理文件">创建批处理文件</a></h2>
<p>在Windows中，批处理文件以 <code>.bat</code>为扩展名。</p>
<p>创建一个名为 <code>hello.bat</code>的文件，并输入以下内容：</p>
<pre><code class="language-bat">echo Hello, World!
pause
</code></pre>
<p>保存文件后，双击该文件即可运行。</p>
<h2 id="执行批处理文件"><a class="header" href="#执行批处理文件">执行批处理文件</a></h2>
<p>执行一个批处理文件，可以通过双击运行，也可以右键以管理员身份运行，但他们有区别。</p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>区别项目</th>
                <th>双击运行</th>
                <th>管理员运行</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>执行目录</td>
                <td>工作目录是该<code>.bat</code>文件所在的目录</td>
                <td>工作目录是 <code>C:\Windows\System32</code>，这容易导致某些文件路径错误，解决办法，添加以下代码：<br>
                    <code>@echo off<br>cd /d %~dp0 </code>
                </td>
            </tr>
              <tr>
                <td>权限</td>
                <td>以当前用户的权限运行，如果当前用户没有管理员权限，某些操作（如修改系统文件、注册表、安装软件等）可能会失败</td>
                <td>以管理员权限运行。能够执行需要提升权限的操作</td>
            </tr>
             <tr>
                <td>环境变量</td>
                <td>使用当前用户的环境变量，有些环境变量仅加入到了系统环境变量中，可能无法访问</td>
                <td>使用系统管理员的环境变量，这可能会导致一些变量（如用户目录等）不同</td>
            </tr>
            <tr>
                <td>用户账户控制（UAC）</td>
                <td>不会触发 UAC 提示</td>
                <td>会触发 UAC 提示，要求用户确认提升权限。这是为了确保用户有意图执行管理员级别的操作。</td>
            </tr>
             <tr>
                <td>安装路径和访问权限</td>
                <td>对用户目录（如 C:\Users\Username）有完全访问权限，但对系统目录（如 C:\Windows、C:\Program Files）的访问可能受限。</td>
                <td>对所有目录都有完全访问权限，包括系统目录。</td>
            </tr>
             <tr>
                <td>操作系统保护机制</td>
                <td>受操作系统保护机制的约束较多，不能执行某些系统级操作。</td>
                <td>如果脚本涉及到计划任务，可能需要管理员权限来创建或修改计划任务。</td>
            </tr>
        </tbody>
    </table>
</div>
<p>双击 <code>hello.bat</code>文件后，会弹出一个命令行窗口，显示 <code>Hello, World!</code>，然后等待用户按下任意键后关闭窗口。</p>
<h2 id="中文编码"><a class="header" href="#中文编码">中文编码</a></h2>
<p>在文件中加入</p>
<pre><code class="language-bat">chcp 65001 &gt; nul
</code></pre>
<p>备注：<code>&gt;nul</code> ：表示将输入重定向到空设备，也就是不输出这条命令的操作信息，此处如果不加会输出一条消息：<code>Active code page:6 5001</code>，</p>
<h2 id="参考-2"><a class="header" href="#参考-2">参考</a></h2>
<h3 id="call调用批处理程序"><a class="header" href="#call调用批处理程序">call（调用批处理程序）</a></h3>
<p>从另一个批处理程序调用一个批处理程序，而不停止父批处理程序。 call 命令接受标签作为调用的目标。</p>
<p>若要从另一个批处理程序运行 checknew.bat 程序，请在父批处理程序中键入以下命令：</p>
<pre><code class="language-shell">call checknew
</code></pre>
<p>如果父批处理程序接受两个批处理参数，并且你希望它将这些参数传递给 checknew.bat，请在父批处理程序中键入以下命令：</p>
<pre><code>call checknew %1 %2
</code></pre>
<h3 id="cd同chdir显示或更改当前目录"><a class="header" href="#cd同chdir显示或更改当前目录">cd（同chdir：显示或更改当前目录）</a></h3>
<p>显示当前目录的名称或更改当前目录。 如果仅与驱动器号一起使用（例如，<code>cd C:</code>），cd 将显示指定驱动器中当前目录的名称。 如果使用时不带参数，cd 将显示当前驱动器和目录。</p>
<p>语法：</p>
<pre><code class="language-shell">cd [/d] [&lt;drive&gt;:][&lt;path&gt;]
cd [..]
chdir [/d] [&lt;drive&gt;:][&lt;path&gt;]
chdir [..]
</code></pre>
<p>参数</p>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>参数</th>
                <th>说明</th>   
            </tr>
        </thead>
        <tbody>  
              <tr>
                <td><code>/d</code></td>
                <td>更改当前驱动器以及驱动器的当前目录。</td>
            </tr>
             <tr>
                <td><code><drive>:</code></td>
                <td>指定要显示或更改的驱动器（如果与当前驱动器不同）。</td>
            </tr>
            <tr>
                <td><code><<path>></code></td>
                <td>指定要显示或更改的目录的路径。</td>
            </tr>
            <tr>
                <td><code>[..]</code></td>
                <td>指定要更改为父文件夹。</td>
            </tr>
             <tr>
                <td><code>/?</code></td>
                <td>在命令提示符下显示帮助。</td>
            </tr>  
        </tbody>
    </table>
</div>
<p><strong>注解</strong></p>
<p>如果启用了命令扩展，则以下条件适用于 cd 命令：</p>
<ul>
<li>
<p>当前目录字符串将转换为使用与磁盘上的名称相同的大小写。 例如，<code>cd c:\temp</code> 会将当前目录设置为 C:\Temp（如果磁盘上是这种大小写）。</p>
</li>
<li>
<p>系统不会将空格视为分隔符，因此 <code>&lt;path&gt;</code> 可以包含不带引号的空格。 例如：
复制</p>
<pre><code>cd username\programs\start menu
</code></pre>
<p>相当于：</p>
<p>复制</p>
<pre><code>cd "username\programs\start menu"
</code></pre>
<p>如果禁用扩展，则需要引号。</p>
</li>
<li>
<p>若要禁用命令扩展，请键入：
复制</p>
<pre><code>cmd /e:off
</code></pre>
</li>
</ul>
<p><strong>示例</strong></p>
<p>要返回到根目录，即驱动器的目录层次结构顶层：</p>
<pre><code>cd\
</code></pre>
<p>要更改与你当前所在驱动器不同的驱动器上的默认目录，请输入以下命令：</p>
<pre><code>cd [&lt;drive&gt;:[&lt;directory&gt;]]
</code></pre>
<p>若要验证对目录的更改，请键入：</p>
<pre><code>cd [&lt;drive&gt;:]
</code></pre>
<h3 id="chcp设置语言"><a class="header" href="#chcp设置语言">chcp（设置语言）</a></h3>
<p>设置代码页和语言</p>
<div class="table-wrapper"><table><thead><tr><th>代码页</th><th>国家/地区或语言</th></tr></thead><tbody>
<tr><td>437</td><td>美国</td></tr>
<tr><td>850</td><td>多语言 (拉丁文我)</td></tr>
<tr><td>852</td><td>西里尔语 （俄语）</td></tr>
<tr><td>855</td><td>西里尔语 （俄语）</td></tr>
<tr><td>857</td><td>土耳其语</td></tr>
<tr><td>860</td><td>葡萄牙语</td></tr>
<tr><td>861</td><td>冰岛语</td></tr>
<tr><td>863</td><td>加拿大法语</td></tr>
<tr><td>865</td><td>北欧</td></tr>
<tr><td>866</td><td>俄语</td></tr>
<tr><td>869</td><td>现代希腊语</td></tr>
<tr><td>936</td><td>中文（gbk）</td></tr>
<tr><td>65001</td><td>utf-8</td></tr>
</tbody></table>
</div>
<p>若要查看活动的代码页设置，请键入︰</p>
<pre><code>chcp
</code></pre>
<p>将显示类似于以下内容的消息：<code>Active code page: 437</code></p>
<p>若要将活动代码页更改为 936（中文），请键入：</p>
<pre><code>chcp 936
</code></pre>
<p>如果指定的代码页无效，将显示以下错误消息：<code>Invalid code page</code></p>
<h3 id="clean删除分区"><a class="header" href="#clean删除分区">clean（删除分区）</a></h3>
<p>从获得焦点的磁盘中删除所有分区或卷格式设置。</p>
<p>不要轻易使用</p>
<h3 id="cls清除命令窗口"><a class="header" href="#cls清除命令窗口">cls（清除命令窗口）</a></h3>
<p>清除命令提示符窗口。</p>
<p>若要清除命令提示符窗口中显示的所有信息并返回到空白窗口，请键入：</p>
<pre><code>cls
</code></pre>
<h3 id="cmd"><a class="header" href="#cmd">cmd</a></h3>
<p>启动命令解释器的新实例 Cmd.exe。 使用时如果没有参数，cmd 将显示操作系统的版本和版权信息。</p>
<h3 id="copy复制"><a class="header" href="#copy复制">copy（复制）</a></h3>
<p>将一个或多个文件从一个位置复制到另一个位置。</p>
<p><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/copy">copy 文档</a></p>
<p>若要将名为 memo.doc 的文件复制到当前驱动器中的 letter.doc，并确保文件结束字符 (CTRL+Z) 位于复制的文件的末尾，请键入：</p>
<pre><code>copy memo.doc letter.doc /a
</code></pre>
<p>若要将名为 robin.typ 的文件从当前驱动器和目录复制到驱动器 C 上名为 Birds 的现有目录，请键入：</p>
<pre><code>copy robin.typ c:\birds
</code></pre>
<blockquote>
<p>备注</p>
<p>如果 Birds 目录不存在，则会将文件 robin.typ 复制到名为 Birds 的文件中，该文件位于磁盘驱动器 C 上的根目录中。</p>
</blockquote>
<p>若要合并当前目录中的 Mar89.rpt、Apr89.rpt 和 May89.rpt，并将其放入名为 Report 的文件（也在当前目录中），请键入：</p>
<pre><code>copy mar89.rpt + apr89.rpt + may89.rpt Report
</code></pre>
<blockquote>
<p>备注</p>
<p>如果合并文件，copy 命令会使用当前日期和时间标记目标文件。 如果省略 destination，将使用列表中第一个文件的名称合并和存储文件。</p>
</blockquote>
<p>若要合并 Report 中的所有文件，当名为 Report 的文件已存在时，请键入：</p>
<pre><code>copy report + mar89.rpt + apr89.rpt + may89.rpt
</code></pre>
<p>若要将当前目录中所有文件扩展名为 .txt 的文件合并到名为 Combined.doc 的单个文件，请键入：</p>
<pre><code>copy *.txt Combined.doc
</code></pre>
<p>若要使用通配符将多个二进制文件合并为一个文件，请包含 /b。 这可以防止 Windows 将 CTRL+Z 视为文件结束字符。 例如，键入：</p>
<pre><code>copy /b *.exe Combined.exe
</code></pre>
<blockquote>
<p>注意</p>
<p>如果合并二进制文件，生成的文件可能因内部格式问题而无法使用。</p>
</blockquote>
<ul>
<li>将扩展名为 .txt 的每个文件与其相应 .ref 文件合并会创建文件名相同，但扩展名为 .doc 的文件。 Copy 命令将 file1.txt 与 file1.ref 合并成 file1.doc，然后该命令将 file2.txt 与 file2.ref 合并成 file2.doc，依此类推。 例如，键入：</li>
</ul>
<pre><code>copy *.txt + *.ref *.doc
</code></pre>
<p>若要合并扩展名为 .txt 的所有文件，然后将扩展名为 .ref 的所有文件合并为一个名为 Combined.doc 的文件，请键入：</p>
<pre><code class="language-shell">copy *.txt + *.ref Combined.doc
</code></pre>
<h3 id="create创建分区"><a class="header" href="#create创建分区">create（创建分区）</a></h3>
<p>创建分区命令</p>
<h3 id="del删除文件"><a class="header" href="#del删除文件">del（删除文件）</a></h3>
<p>删除一个或多个文件。 此命令执行与 erase 命令相同的操作。</p>
<p>del 命令还可以使用不同参数从 Windows 恢复控制台运行。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/windows-recovery-environment--windows-re--technical-reference">Windows 恢复环境 (WinRE)</a>。</p>
<blockquote>
<p>警告</p>
<p>如果使用 del 从磁盘中删除某个文件，则无法检索该文件。</p>
</blockquote>
<p>要删除驱动器 C 上名为 test 的文件夹中的所有文件，请键入以下任一命令：</p>
<pre><code>del c:\test
del c:\test\*.*
</code></pre>
<p>若要删除文件夹中名称中包含空格的所有文件，需要用双引号将完整路径括起来。 键入以下任一命令：</p>
<pre><code>del "c:\test folder\"
del "c:\test folder\*.*"
</code></pre>
<p>要从当前目录中删除文件扩展名为 .bat 的所有文件，请键入：</p>
<pre><code>del *.bat
</code></pre>
<p>要删除当前目录中的所有只读文件，请键入：</p>
<pre><code>del /a:r *.*
</code></pre>
<h3 id="delete删除分区"><a class="header" href="#delete删除分区">delete（删除分区）</a></h3>
<p>删除分区或卷。 此命令还会从磁盘列表中删除动态磁盘。</p>
<h3 id="dir显示目录"><a class="header" href="#dir显示目录">dir（显示目录）</a></h3>
<p>显示目录的文件和子目录的列表。 如果使用此命令时不带参数，则将显示磁盘的卷标和序列号，后跟磁盘上的目录和文件列表（包括其名称以及上次修改每个目录和文件的日期和时间）。 对于文件，此命令显示扩展名和大小（以字节为单位）。 此命令还显示列出的文件和目录总数、其累积大小以及磁盘上剩余的可用空间（以字节为单位）。</p>
<p>dir 命令还可以使用不同参数从 Windows 恢复控制台运行。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/windows-recovery-environment--windows-re--technical-reference">Windows 恢复环境 (WinRE)</a>。</p>
<h4 id="语法"><a class="header" href="#语法">语法</a></h4>
<pre><code>dir [&lt;drive&gt;:][&lt;path&gt;][&lt;filename&gt;] [...] [/p] [/q] [/w] [/d] [/a[[:]&lt;attributes&gt;]][/o[[:]&lt;sortorder&gt;]] [/t[[:]&lt;timefield&gt;]] [/s] [/b] [/l] [/n] [/x] [/c] [/4] [/r]
</code></pre>
<h4 id="参数"><a class="header" href="#参数">参数</a></h4>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td><code>[&lt;drive&gt;:][&lt;path&gt;]</code></td><td>指定要查看其列表的驱动器和目录。</td></tr>
<tr><td><code>[&lt;filename&gt;]</code></td><td>指定要查看其列表的特定文件或文件组。</td></tr>
<tr><td>/p</td><td>一次显示一个列表屏幕。 要查看下一个屏幕，请按任意键。</td></tr>
<tr><td>/q</td><td>显示文件所有权信息。</td></tr>
<tr><td>/w</td><td>以宽格式显示列表，每行最多包含五个文件名或目录名称。</td></tr>
<tr><td>/d</td><td>以与 /w 相同的格式显示列表，但文件按列排序。</td></tr>
<tr><td>/a[[:]<code>&lt;attributes&gt;</code>]</td><td>仅显示具有指定属性的目录和文件的名称。 如果不使用此参数，此命令将显示除隐藏文件和系统文件之外的所有文件的名称。 如果在未指定任何属性的情况下使用此参数，则此命令将显示所有文件的名称，包括隐藏文件和系统文件。 可能的属性值列表包括：* d - 目录* h - 隐藏文件* s - 系统文件* l - 重新分析点* r - 只读文件* a - 可用于存档的文件* i - 非内容索引文件你可以使用这些值的任意组合，但不要使用空格分隔值。 （可选）可以使用冒号 (:) 分隔符，或者你可以使用连字符 (-) 作为前缀来表示“非”。 例如，使用 -s 属性不会显示系统文件。</td></tr>
<tr><td>/o[[:]<code>&lt;sortorder&gt;</code>]</td><td>根据 sortorder 对输出进行排序，可以是以下值的任意组合：* n - 按名称字母顺序排列* e - 按扩展名字母顺序排列* g - 首先列出组目录* s - 按大小，最先列出最小的文件* d - 按日期/时间，最先列出最早的文件* 使用**-** 前缀可反转排序顺序多个值将按照你列出它们的顺序进行处理。 不要用空格分隔多个值，但可以选择使用冒号 (:)。如果未指定 sortorder，则 dir /o 将按字母顺序列出目录，后跟文件，这些文件也按字母顺序排序。</td></tr>
<tr><td>/t[[:]<code>&lt;timefield&gt;</code>]</td><td>指定要显示或用于排序的时间字段。 timefield 的可用值包括：* c - 创建时间* a - 上次访问时间* w - 最后写入时间</td></tr>
<tr><td>/s</td><td>列出指定目录和所有子目录中出现的指定文件名的每个匹配项。</td></tr>
<tr><td>/b</td><td>显示纯粹的目录和文件列表，不含其他信息。 /b 参数将覆盖 /w。</td></tr>
<tr><td>/l</td><td>使用小写显示未排序的目录名称和文件名。</td></tr>
<tr><td>/n</td><td>在屏幕最右侧显示带有文件名的长列表格式。</td></tr>
<tr><td>/x</td><td>显示为非 8dot3 文件名生成的短名称。 显示内容与 /n 的显示内容相同，但短名称插入到长名称之前。</td></tr>
<tr><td>/c</td><td>以千位分隔符显示文件大小。 此选项为默认行为。 使用 /-c 隐藏分隔符。</td></tr>
<tr><td>/4</td><td>以四位数格式显示年份。</td></tr>
<tr><td>/r</td><td>显示文件的备用数据流。</td></tr>
<tr><td>/?</td><td>在命令提示符下显示帮助。</td></tr>
</tbody></table>
</div>
<h4 id="注解"><a class="header" href="#注解">注解</a></h4>
<ul>
<li>
<p>若要使用多个 filename 参数，请用空格、逗号或分号分隔每个文件名。</p>
</li>
<li>
<p>可以使用通配符（***** 或 ?）来表示文件名的一个或多个字符，并显示文件或子目录的子集。</p>
</li>
<li>
<p>可以使用通配符 ***** 来替换任何字符串，例如：</p>
<ul>
<li><code>dir *.txt</code> 将列出当前目录中扩展名以 .txt 开头的所有文件，例如 .txt、.txt1、.txt_old。</li>
<li><code>dir read *.txt</code> 将列出当前目录中以 read 开头并且扩展名以 .txt 开头的所有文件，例如 .txt、.txt1 或 .txt_old。</li>
<li><code>dir read *.*</code> 将列出当前目录中以 read 开头的所有文件（无论任何扩展名）。</li>
</ul>
<p>星号通配符始终使用短文件名映射，因此你可能会得到意外的结果。 例如，以下目录包含两个文件（t.txt2 和 t97.txt）：
复制</p>
<pre><code>C:\test&gt;dir /x
Volume in drive C has no label.
Volume Serial Number is B86A-EF32

Directory of C:\test

11/30/2004  01:40 PM &lt;DIR&gt;  .
11/30/2004  01:40 PM &lt;DIR&gt; ..
11/30/2004  11:05 AM 0 T97B4~1.TXT t.txt2
11/30/2004  01:16 PM 0 t97.txt
</code></pre>
<p>你可能期望键入 <code>dir t97\*</code> 后将返回文件 t97.txt。 但是，键入 <code>dir t97\*</code> 会返回这两个文件，因为星号通配符使用其短名称映射 T97B4~1.TXT，因此会认为文件 t.txt2 与 t97.txt 匹配。 同样，键入 <code>del t97\*</code> 会删除这两个文件。</p>
</li>
<li>
<p>可以使用问号 (?) 代替名称中的单个字符。 例如，键入 <code>dir read???.txt</code> 会列出当前目录中扩展名为 .txt 的任何文件，这些文件以 read 开头，后跟最多三个字符。 这包括 Read.txt、Read1.txt、Read12.txt、Read123.txt 和 Readme1.txt，但不包括 Readme12.txt。</p>
</li>
<li>
<p>如果在 attributes 中使用 /a 和多个值，则此命令仅显示具有所有指定属性的文件的名称。 例如，如果将 /a 与 r 和 -h 一起使用作为属性（使用 <code>/a:r-h</code> 或 <code>/ar-h</code>），则此命令将仅显示未隐藏的只读文件的名称。</p>
</li>
<li>
<p>如果指定多个 sortorder 值，则此命令将首先按第一个条件对文件名进行排序，然后按第二个条件排序，依此类推。 例如，如果将 /o 与 sortorder 的 e 和 -s 参数一起使用（使用 <code>/o:e-s</code> 或 <code>/oe-s</code>），则此命令按扩展名对目录和文件的名称进行排序，首先显示最大的文件，然后显示最终结果。 按扩展名按字母顺序排序会导致首先显示没有扩展名的文件名，然后显示目录名称，然后显示带有扩展名的文件名。</p>
</li>
<li>
<p>如果使用重定向符号 (<code>&gt;</code>) 将此命令的输出发送到文件，或者使用管道符号 (<code>|</code>) 将此命令的输出发送到另一个命令，则必须使用 <code>/a:-d</code> 和 /b，以仅列出文件名。 可以将 filename 与 /b 和 /s 一起使用，以指定此命令要在当前目录及其子目录中搜索与 filename 参数匹配的所有文件名。 此命令仅列出它找到的每个文件名的驱动器号、目录名、文件名和文件扩展名（每行一个路径）。 在使用管道符号将此命令的输出发送到另一个命令之前，应首先在 Autoexec.nt 文件中设置 TEMP 环境变量。</p>
</li>
</ul>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<p>若要按字母顺序、宽格式逐个显示所有目录，并在每个屏幕后暂停，请确保根目录是当前目录，然后键入：</p>
<pre><code>dir /s/w/o/p
</code></pre>
<p>输出列出了根目录、子目录和根目录中的文件，包括扩展名。 此命令还会列出树中每个子目录中的子目录名称和文件名。</p>
<p>若要更改前面的示例，以便 dir 显示文件名和扩展名，但省略目录名称，请键入：</p>
<pre><code>dir /s/w/o/p/a:-d
</code></pre>
<p>要打印目录列表，请键入：</p>
<pre><code>dir &gt; prn
</code></pre>
<p>如果指定 prn，则目录列表将发送到连接到 LPT1 端口的打印机。 如果打印机连接到其他端口，则必须将 prn 替换为正确端口的名称。</p>
<p>还可以将 prn 替换为文件名，从而将 dir 命令的输出重定向到文件。 也可以键入路径。 例如，若要将 dir 命令的输出定向到 Records 目录中的 dir.doc 文件，请键入：</p>
<pre><code>dir &gt; \records\dir.doc
</code></pre>
<p>如果 dir.doc 不存在，dir 将创建此文件，除非 Records 目录不存在。 如果 Records 目录不存在，将显示以下消息：</p>
<pre><code>File creation error
</code></pre>
<p>若要显示驱动器 C 上所有目录中扩展名为.txt 的所有文件名的列表，请键入：</p>
<pre><code>dir c:\*.txt /w/o/s/p
</code></pre>
<p>dir 命令以宽格式显示每个目录中按字母顺序排列的匹配文件名列表，并且每次屏幕填满时都会暂停，按任意键可继续显示。</p>
<h3 id="echo打印消息和回显功能"><a class="header" href="#echo打印消息和回显功能">echo（打印消息和回显功能）</a></h3>
<p>显示消息或者打开或关闭命令回显功能。 如果不结合任何参数使用，echo 会显示当前回显设置。</p>
<p>若要显示当前的回显设置，请键入：</p>
<pre><code>echo
</code></pre>
<p>若要在屏幕上回显空白行，请键入：</p>
<pre><code>echo.
</code></pre>
<blockquote>
<p>备注</p>
<p>不要在句点前面包含空格。 否则，将显示句点而不是空白行。</p>
</blockquote>
<p>若要防止在命令提示符处回显命令，请键入：</p>
<pre><code>echo off
</code></pre>
<blockquote>
<p>备注</p>
<p>关闭回显时，命令提示符不会出现在“命令提示符”窗口中。 若要再次显示命令提示符，请键入 echo on。</p>
</blockquote>
<p>若要防止批处理文件中的所有命令（包括 echo off 命令）显示在屏幕上，请在批处理文件的第一行中键入：</p>
<pre><code>@echo off
</code></pre>
<p>可以将 <code>echo</code> 命令用作 <code>if</code> 语句的一部分。 例如，若要在当前目录中搜索文件扩展名为 .rpt 的任何文件，并在找到此类文件时回显消息，请键入：</p>
<pre><code>if exist *.rpt echo The report has arrived.
</code></pre>
<p>以下批处理文件在当前目录中搜索文件扩展名为 .txt 的文件，并显示一条消息来指示搜索结果：</p>
<pre><code>@echo off
if not exist *.txt (
echo This directory contains no text files.
) else (
   echo This directory contains the following text file^(s^):
   echo.
   dir /b *.txt
   )
</code></pre>
<p>如果运行该批处理文件时未找到 .txt 文件，则会显示以下消息：</p>
<pre><code>This directory contains no text files.
</code></pre>
<p>如果运行该批处理文件时找到 .txt 文件，则会显示以下输出（此示例假设文件 File1.txt、File2.txt 和 File3.txt 存在）：</p>
<pre><code>This directory contains the following text file(s):

File1.txt
File2.txt
File3.txt
</code></pre>
<h3 id="find搜索文本字符"><a class="header" href="#find搜索文本字符">find（搜索文本字符）</a></h3>
<p>在一个或多个文件中搜索文本字符串，并显示包含指定字符串的文本行。</p>
<h4 id="语法-1"><a class="header" href="#语法-1">语法</a></h4>
<pre><code>find [/v] [/c] [/n] [/i] [/off[line]] &lt;"string"&gt; [[&lt;drive&gt;:][&lt;path&gt;]&lt;filename&gt;[...]]
</code></pre>
<h4 id="参数-1"><a class="header" href="#参数-1">参数</a></h4>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td>/v</td><td>显示不包含指定 <code>&lt;string&gt;</code> 的所有行。</td></tr>
<tr><td>/c</td><td>对包含指定 <code>&lt;string&gt;</code> 的行进行计数，并显示总计。</td></tr>
<tr><td>/n</td><td>每行前面都有文件的行号。</td></tr>
<tr><td>/i</td><td>指定搜索不区分大小写。</td></tr>
<tr><td>/off[line]</td><td>如果文件设置了脱机属性，则不会被跳过。</td></tr>
<tr><td><code>&lt;"string"&gt;</code></td><td>必需。 指定想要搜索的字符组（用引号括起来）。</td></tr>
<tr><td><code>[&lt;drive&gt;:][&lt;path&gt;]&lt;filename&gt;</code></td><td>指定要在其中搜索指定字符串的文件的位置和名称。</td></tr>
<tr><td>/?</td><td>在命令提示符下显示帮助。</td></tr>
</tbody></table>
</div>
<p>若要显示包含字符串“pencil sharpener”的 pencil.md 中的所有行，请键入：</p>
<pre><code>find "pencil sharpener" pencil.txt
</code></pre>
<p>为了在 report.txt 文件中找到文本“科学家标明他们的论文仅供讨论，并不是最终报告。”（含引号），请键入：</p>
<pre><code>find """The scientists labeled their paper for discussion only. It is not a final report.""" &lt; report.txt
</code></pre>
<p><strong>若要搜索一组文件，可以使用通配符。 若要在当前目录中搜索扩展名为 .bat 且包含忽略大小写的字符串 PROMPT 的文件，请键入</strong>：</p>
<pre><code>find /i "PROMPT" *.bat
</code></pre>
<p>若要在包含字符串 CPU 的目录中查找文件名，请使用管道 (|) 将 dir 命令的输出定向到 find 命令，如下所示：</p>
<pre><code>dir c:\temp /s /b | find "CPU"
</code></pre>
<p>查找不包含 “agent” 的所有正在运行的进程：</p>
<pre><code>tasklist | find /v /i "agent"
</code></pre>
<p>检查服务是否正在运行：</p>
<pre><code>sc query  Winmgmt | find "RUNNING" &gt;nul 2&gt;&amp;1 &amp;&amp; (echo service is started) || (echo service is stopped)
</code></pre>
<h3 id="for遍历文件"><a class="header" href="#for遍历文件">for（遍历文件）</a></h3>
<p>为一组文件中的每个文件运行指定命令。</p>
<h4 id="语法-2"><a class="header" href="#语法-2">语法</a></h4>
<pre><code>for {%% | %}&lt;variable&gt; in (&lt;set&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
</code></pre>
<h4 id="参数-2"><a class="header" href="#参数-2">参数</a></h4>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td><code>{%% | %}&lt;variable&gt;</code></td><td>必填。 表示可替换参数。 使用单百分号 (<code>%</code>) 可在命令提示符下执行 for 命令。 使用双百分号 (<code>%%</code>) 可在批处理文件中执行 for 命令。 变量区分大小写，并且必须用字母值表示，例如 %a、%b 或 %c。</td></tr>
<tr><td>(<code>&lt;set&gt;</code>)</td><td>必需。 指定要对其运行命令的一个或多个文件、目录或文本字符串或值范围。 需要使用括号。</td></tr>
<tr><td><code>&lt;command&gt;</code></td><td>必需。 指定要对每个文件、目录或文本字符串执行的命令，或针对 set 中包含的值范围执行的命令。</td></tr>
<tr><td><code>&lt;commandlineoptions&gt;</code></td><td>指定要与指定命令一起使用的任何命令行选项。</td></tr>
<tr><td>/?</td><td>在命令提示符下显示帮助。</td></tr>
</tbody></table>
</div>
<h4 id="备注"><a class="header" href="#备注">备注</a></h4>
<ul>
<li>可以在批处理文件中使用此命令，也可以直接从命令提示符使用此命令。</li>
<li>以下属性适用于 for 命令：
<ul>
<li>此命令将 <code>% variable</code> 或 <code>%% variable</code> 替换为指定集中的每个文本字符串，直到指定的命令处理完所有文件。</li>
<li>变量名称区分大小写并且是全局性的，一次最多不能超过 52 个处于活动状态。</li>
<li>可以对变量使用任何字符，但为了避免与批处理参数 <code>%0</code> 到 <code>%9</code> 混淆，请避免使用数字 0 到 9。 对于简单的批处理文件，单个字符（如 <code>%%f</code>）将起作用。</li>
<li>可以在复杂的批处理文件中对变量使用多个值，以区分不同的可替换变量。</li>
</ul>
</li>
<li>set 参数可以表示单个文件组或多组文件。 可以使用通配符（***** 和 ?）指定文件集。 以下是有效的文件集：
复制</li>
</ul>
<pre><code>  (*.doc)
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
</code></pre>
<ul>
<li>使用此命令时，set 参数中的第一个值将替换 <code>% variable</code> 或 <code>%% variable</code>，然后指定的命令将处理此值。 这一直持续到与 set 值相对应的所有文件（或文件组）都被处理为止。</li>
<li>In 和 do 不是参数，但必须将它们与此命令一起使用。 如果省略其中任何一个关键字，则会出现错误消息。</li>
<li>如果启用了命令扩展（默认状态），则支持下列形式的 for：
<ul>
<li>
<p>仅限目录：如果 set 参数中包含通配符（***** 或 ?），则将针对与 set 参数匹配的每个目录（而不是指定目录中的一组文件）执行指定的命令。 语法为：</p>
<pre><code>for /d {%%|%}&lt;variable&gt; in (&lt;set&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
</code></pre>
</li>
<li>
<p>递归：遍历以 drive:path 为根的目录树，并在树的每个目录中执行 for 语句。 如果在 /r 之后没有指定目录，则使用当前目录作为根目录。 如果 set 参数只是一个句点 (.)，则仅枚举目录树。 语法为：</p>
<pre><code>for /r [[&lt;drive&gt;:]&lt;path&gt;] {%%|%}&lt;variable&gt; in (&lt;set&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
</code></pre>
</li>
<li>
<p>迭代值范围：使用迭代变量设置起始值 (start#)，然后逐步通过设置的值范围，直到该值超过设置的结束值 (end#)。 <strong>/l</strong> 将通过比较  <em>start</em> # 和  <em>end</em> # 来执行迭代。 如果  <em>start</em> # 小于  <em>end</em> #，则执行该命令。 当迭代变量超过 end# 时，命令 shell 退出循环。 你还可以使用 step# 来逐步减少值的范围。 例如，(1,1,5) 生成序列 1 2 3 4 5，(5,-1,1) 生成序列 5 4 3 2 1。 语法为：</p>
<pre><code>for /l {%%|%}&lt;variable&gt; in (&lt;start#&gt;,&lt;step#&gt;,&lt;end#&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
</code></pre>
</li>
<li>
<p>迭代和文件解析：使用文件解析来处理命令输出、字符串和文件内容。 使用迭代变量定义要检查的内容或字符串，并使用各种 parsingkeywords 选项进一步修改解析。 使用 parsingkeywords 标记选项来指定哪些标记应作为迭代变量传递。 如果使用时不带标记选项，/f 将只检查第一个标记。
文件解析包括读取输出、字符串或文件内容，然后将其拆分为单独的文本行，并将每一行解析为零个或多个标记。 然后调用 for 循环，并将迭代变量值设置为标记。 默认情况下，/f 传递每个文件的每一行中的第一个空白分隔标记。 空行将被跳过。
语法为：</p>
<pre><code>for /f [&lt;parsingkeywords&gt;] {%%|%}&lt;variable&gt; in (&lt;set&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
for /f [&lt;parsingkeywords&gt;] {%%|%}&lt;variable&gt; in (&lt;literalstring&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
for /f [&lt;parsingkeywords&gt;] {%%|%}&lt;variable&gt; in ('&lt;command&gt;') do &lt;command&gt; [&lt;commandlineoptions&gt;]
</code></pre>
<p>set 参数指定一个或多个文件名。 将依次打开、读取和处理每个文件，然后才会移动到 set 参数中指定的下一个文件。 要覆盖默认分析行为，请指定 parsingkeywords。 这是一个带引号的字符串，其中包含一个或多个用于指定不同分析选项的关键字。</p>
<p>如果使用 usebackq 选项，请使用以下语法之一：</p>
<pre><code>for /f [usebackq &lt;parsingkeywords&gt;] {%%|%}&lt;variable&gt; in (&lt;set&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
for /f [usebackq &lt;parsingkeywords&gt;] {%%|%}&lt;variable&gt; in ('&lt;literalstring&gt;') do &lt;command&gt; [&lt;commandlineoptions&gt;]
for /f [usebackq &lt;parsingkeywords&gt;] {%%|%}&lt;variable&gt; in (`&lt;command&gt;`) do &lt;command&gt; [&lt;commandlineoptions&gt;]
</code></pre>
<p>下表列出了可用于 parsingkeywords 的分析关键字。
展开表</p>
<div class="table-wrapper"><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody>
<tr><td>eol=<code>&lt;c&gt;</code></td><td>指定行尾字符（只有一个字符）。</td></tr>
<tr><td>skip=<code>&lt;n&gt;</code></td><td>指定文件开头要跳过的行数。</td></tr>
<tr><td>delims=<code>&lt;xxx&gt;</code></td><td>指定分隔符集。 这将替换默认分隔符集，即空格和制表符。</td></tr>
<tr><td>tokens=<code>&lt;x,y,m–n&gt;</code></td><td>指定每次迭代时要将每行中的哪些标记传递给 for 循环。 因此，会分配额外的变量名。 m-n 指定从第 m 个到第 n 个标记的范围。 如果 tokens= 字符串中的最后一个字符是星号 ( ***** )，则会分配一个额外的变量，并且会接收解析的最后一个标记之后的行上的剩余文本。</td></tr>
<tr><td>usebackq</td><td>指定将双引号字符串作为命令运行，使用单引号字符串作为文字字符串，或者对于包含空格的长文件名，允许将 <code>&lt;set&gt;</code> 中的每个文件名都括在双引号中。</td></tr>
</tbody></table>
</div></li>
<li>
<p>变量替换：下表列出了可选语法（适用于任何变量 I）：
展开表</p>
<div class="table-wrapper"><table><thead><tr><th>带修饰符的变量</th><th>说明</th></tr></thead><tbody>
<tr><td><code>%~I</code></td><td>扩展 <code>%I</code>，这将移除所有周围的引号。</td></tr>
<tr><td><code>%~fI</code></td><td>将 <code>%I</code> 扩展为完全限定的路径名。</td></tr>
<tr><td><code>%~dI</code></td><td>将 <code>%I</code> 扩展为仅包含驱动器号。</td></tr>
<tr><td><code>%~pI</code></td><td>将 <code>%I</code> 扩展为仅包含路径。</td></tr>
<tr><td><code>%~nI</code></td><td>将 <code>%I</code> 扩展为仅包含文件名。</td></tr>
<tr><td><code>%~xI</code></td><td>将 <code>%I</code> 扩展为仅包含文件扩展名。</td></tr>
<tr><td><code>%~sI</code></td><td>将路径扩展为仅包含短名称。</td></tr>
<tr><td><code>%~aI</code></td><td>将 <code>%I</code> 扩展为文件属性。</td></tr>
<tr><td><code>%~tI</code></td><td>将 <code>%I</code> 扩展为文件的日期和时间。</td></tr>
<tr><td><code>%~zI</code></td><td>将 <code>%I</code> 扩展为文件的大小。</td></tr>
<tr><td><code>%~$PATH:I</code></td><td>搜索 PATH 环境变量中列出的目录，然后将 <code>%I</code> 扩展为找到的第一个目录的完全限定名称。 如果未定义环境变量名称或搜索找不到该文件，则此修饰符将扩展为空字符串。</td></tr>
</tbody></table>
</div>
<p>下表列出了可用于获取复合结果的修饰符组合。
展开表</p>
<div class="table-wrapper"><table><thead><tr><th>带组合修饰符的变量</th><th>说明</th></tr></thead><tbody>
<tr><td><code>%~dpI</code></td><td>将 <code>%I</code> 扩展为仅包含驱动器号和路径。</td></tr>
<tr><td><code>%~nxI</code></td><td>将 <code>%I</code> 扩展为仅包含文件名和扩展名。</td></tr>
<tr><td><code>%~fsI</code></td><td>将 <code>%I</code> 扩展为仅包含短名称的完整路径名。</td></tr>
<tr><td><code>%~dp$PATH:I</code></td><td>在 PATH 环境变量中列出的目录中搜索 <code>%I</code>，然后扩展为找到的第一个目录的驱动器号和路径。</td></tr>
<tr><td><code>%~ftzaI</code></td><td>将 <code>%I</code> 扩展为类似于 dir 命令的输出行。</td></tr>
</tbody></table>
</div>
<p>在上面的示例中，可以将 <code>%I</code> 和 PATH 替换为其他有效值。 有效的 for 变量名称将结束 <strong>%~</strong> 语法。
通过使用大写的变量名（如 <code>%I</code>），可以提高代码的易读性，并避免与不区分大小写的修饰符混淆。</p>
</li>
</ul>
</li>
<li>解析字符串：你可以在直接字符串上使用解析逻辑，方法是：使用双引号（不带 usebackq）或单引号（带usebackq）--例如，(MyString) 或 ('MyString')。<code>for /f``&lt;literalstring&gt;</code> <code>&lt;literalstring&gt;</code> 被视为来自文件的单行输入。 解析用双引号括起的 <code>&lt;literalstring&gt;</code> 时，命令符号（如 <code>\ &amp; | &gt; &lt; ^</code>）被视为普通字符。</li>
<li>解析输出：可以使用 <code>for /f</code> 命令来解析命令的输出，方法是在括号之间加上反引号 <code>&lt;command&gt;</code>。 它将被视为命令行，随后传递给子 cmd.exe。 输出会捕获到内存中，并像文件一样进行解析。</li>
</ul>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<p>要在批处理文件中使用 for，请使用以下语法：</p>
<pre><code>for {%%|%}&lt;variable&gt; in (&lt;set&gt;) do &lt;command&gt; [&lt;commandlineoptions&gt;]
</code></pre>
<p>要使用可替换变量 %f 显示当前目录中扩展名为.doc 或.txt 的所有文件的内容，请键入：</p>
<pre><code>for %f in (*.doc *.txt) do type %f
</code></pre>
<p>在前面的示例中，当前目录中扩展名为 .doc 或 .txt 的每个文件都将被替换为 %f 变量，直到显示每个文件的内容。 要在批处理文件中使用此命令，请将所有出现的 %f 替换为 %%f。 否则，将忽略该变量并显示错误消息。</p>
<p>要分析文件并忽略注释行，请键入：</p>
<pre><code>for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
</code></pre>
<p>此命令将解析 myfile.txt 中的每一行。 此命令将忽略以分号开头的行，并将每行的第二个和第三个标记传递给 for 主体（标记由逗号或空格分隔）。 for 语句的主体引用 %i 以获取第二个标记，引用 %j 以获取第三个标记，引用 %k 以获取所有剩余标记。 如果你提供的文件名包含空格，请在文本两边使用引号（例如，File Name）。 要使用引号，必须使用 usebackq。 否则，引号将被解释为定义要解析的文字字符串。</p>
<p>%i 在 for 语句中显式声明。 %j 和 %k 是使用 tokens= 隐式声明的。 可以使用 <strong>tokens=</strong> 来指定最多 26 个标记，前提是不会导致尝试声明超过字母 z 或 Z 的变量。</p>
<p>要通过将 set 放在括号中来解析命令的输出，请键入：</p>
<pre><code>for /f "usebackq delims==" %i in (`set`) do @echo %i
</code></pre>
<p>要对目录中的所有文件执行递归循环（包括子目录）并回显其完整路径、上次修改时间及其文件大小，请键入：</p>
<pre><code>for /r "C:\My Dir\" %A in (*.*) do echo %~ftzA
</code></pre>
<h3 id="if条件"><a class="header" href="#if条件">if（条件）</a></h3>
<p>在批处理程序中执行条件处理。</p>
<h4 id="语法-3"><a class="header" href="#语法-3">语法</a></h4>
<pre><code>if [not] ERRORLEVEL &lt;number&gt; &lt;command&gt; [else &lt;expression&gt;]
if [not] &lt;string1&gt;==&lt;string2&gt; &lt;command&gt; [else &lt;expression&gt;]
if [not] exist &lt;filename&gt; &lt;command&gt; [else &lt;expression&gt;]
</code></pre>
<p>如果启用了命令扩展，请使用以下语法：</p>
<pre><code>if [/i] &lt;string1&gt; &lt;compareop&gt; &lt;string2&gt; &lt;command&gt; [else &lt;expression&gt;]
if cmdextversion &lt;number&gt; &lt;command&gt; [else &lt;expression&gt;]
if defined &lt;variable&gt; &lt;command&gt; [else &lt;expression&gt;]
</code></pre>
<h4 id="参数-3"><a class="header" href="#参数-3">参数</a></h4>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td>not</td><td>指定仅当条件为 false 时，才应执行该命令。</td></tr>
<tr><td>errorlevel <code>&lt;number&gt;</code></td><td>仅当由 Cmd.exe 运行的上一个程序返回等于或大于 number 的退出代码时，才指定 true 条件。</td></tr>
<tr><td><code>&lt;command&gt;</code></td><td>指定在满足上述条件时应执行的命令。</td></tr>
<tr><td><code>&lt;string1&gt;==&lt;string2&gt;</code></td><td>仅当 string1 和 string2 相同时，才指定 true 条件。 这些值可以是字符串或批处理变量（例如，<code>%1</code>）。 无需将字符串用引号括起来。</td></tr>
<tr><td>存在 <code>&lt;filename&gt;</code></td><td>如果指定的文件名存在，则指定 true 条件。</td></tr>
<tr><td><code>&lt;compareop&gt;</code></td><td>指定三字母比较运算符，包括：* EQU - 等于* NEQ - 不等于* LSS - 小于* LEQ - 小于或等于* GTR - 大于* GEQ - 大于或等于</td></tr>
<tr><td>/i</td><td>强制字符串比较忽略大小写。 可以采用 if 的 <code>string1==string2</code> 形式使用 /i。 这些比较是通用的，因为如果 string1 和 string2 仅由数字组成，则字符串将转换为数值并执行数值比较。</td></tr>
<tr><td>cmdextversion <code>&lt;number&gt;</code></td><td>仅当与 Cmd.exe 的命令扩展功能关联的内部版本号等于或大于指定的数值时，才指定 true 条件。 第一个版本为 1。 向命令扩展添加大量增强功能时，它会以 1 为增量增加。 禁用命令扩展时（默认情况下，启用命令扩展），cmdextversion 条件永远不会为 true。</td></tr>
<tr><td>defined <code>&lt;variable&gt;</code></td><td>如果定义了变量，则指定 true 条件。</td></tr>
<tr><td><code>&lt;expression&gt;</code></td><td>指定命令行命令以及要在 else 子句中传递给该命令的任何参数。</td></tr>
<tr><td>/?</td><td>在命令提示符下显示帮助。</td></tr>
</tbody></table>
</div>
<h4 id="备注-1"><a class="header" href="#备注-1">备注</a></h4>
<ul>
<li>
<p>如果 if 子句中指定的条件为 true，则执行条件后面的命令。如果条件为 false，则忽略 if 子句中的命令，并且该命令执行 else 子句中指定的任何命令。</p>
</li>
<li>
<p>程序停止时，它将返回退出代码。 若要使用退出代码作为条件，请使用 errorlevel 参数。</p>
</li>
<li>
<p>如果使用 defined，则将以下三个变量添加到环境中：%errorlevel%、%cmdcmdline% 和 %cmdextversion%。</p>
<ul>
<li>%errorlevel%：扩展为 ERRORLEVEL 环境变量的当前值的字符串表示形式。 此变量假定尚不存在名为 ERRORLEVEL 的现有环境变量。 如果存在，将获得该 ERRORLEVEL 值。</li>
</ul>
</li>
<li>
<p>%cmdcmdline%：扩展到在 Cmd.exe 进行任何处理之前传递给 Cmd.exe 的原始命令行。 这假定尚不存在名为 CMDCMDLINE 的现有环境变量。 如果存在，将获得该 CMDCMDLINE 值。</p>
</li>
<li>
<p>%cmdextversion%：扩展为 cmdextversion 的当前值的字符串表示形式。 这假定不存在名为 CMDEXTVERSION 的现有环境变量。 如果存在，将获取该 CMDEXTVERSION 值。</p>
</li>
<li>
<p>必须在 if 后面的命令所在的同一行上使用 else 子句。</p>
</li>
</ul>
<p><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/if#examples"></a>### 示例</p>
<p>若要显示消息“如果找不到文件 Product.dat ，则找不到数据文件”，请键入：</p>
<pre><code>if not exist product.dat echo Cannot find data file
</code></pre>
<p>若要在驱动器 A 中格式化磁盘并在格式化过程中发生错误时显示错误消息，请在批处理文件中键入以下行：</p>
<pre><code>:begin
@echo off
format a: /s
if not errorlevel 1 goto end
echo An error occurred during formatting.
:end
echo End of batch program.
</code></pre>
<p>若要从当前目录中删除文件 Product.dat 或在找不到 Product.dat 时显示消息，请在批处理文件中键入以下行：</p>
<pre><code>IF EXIST Product.dat (
del Product.dat
) ELSE (
echo The Product.dat file is missing.
)
</code></pre>
<p>备注</p>
<p>这些行可以组合成一行，如下所示：</p>
<pre><code>IF EXIST Product.dat (del Product.dat) ELSE (echo The Product.dat file is missing.)
</code></pre>
<p>若要在运行批处理文件后回显 ERRORLEVEL 环境变量的值，请在批处理文件中键入以下行：</p>
<pre><code>goto answer%errorlevel%
:answer1
echo The program returned error level 1
goto end
:answer0
echo The program returned error level 0
goto end
:end
echo Done!
</code></pre>
<p>若要在 ERRORLEVEL 环境变量的值小于或等于 1 时转到 ok 标签，请键入：</p>
<pre><code>if %errorlevel% LEQ 1 goto okay
</code></pre>
<h3 id="ipconfig"><a class="header" href="#ipconfig">ipconfig</a></h3>
<p>显示所有当前的 TCP/IP 网络配置值，并刷新动态主机配置协议 (DHCP) 和域名系统 (DNS) 设置。 在没有参数的情况下使用时，ipconfig 会显示 Internet 协议版本 4 (IPv4) 和 IPv6 地址、子网掩码以及所有适配器的默认网关。</p>
<h3 id="mkdir同md创建目录"><a class="header" href="#mkdir同md创建目录">mkdir（同md：创建目录）</a></h3>
<p>创建目录或子目录。 命令扩展（默认情况下启用）允许使用单个 mkdir 命令在指定路径中创建中间目录。</p>
<p>若要在当前目录中创建名为 Directory1 的目录，请键入：</p>
<pre><code>mkdir Directory1
</code></pre>
<p>若要在启用命令扩展的情况下在根目录中创建目录树 Taxes\Property\Current，请键入：</p>
<pre><code>mkdir \Taxes\Property\Current
</code></pre>
<p>若要与上一示例中一样在根目录中创建目录树 Taxes\Property\Current，但禁用命令扩展，请键入以下命令序列：</p>
<pre><code>mkdir \Taxes
mkdir \Taxes\Property
mkdir \Taxes\Property\Current
</code></pre>
<h3 id="move移动文件"><a class="header" href="#move移动文件">move（移动文件）</a></h3>
<p>将一个或多个文件从一个目录移动到另一个目录。</p>
<h4 id="语法-4"><a class="header" href="#语法-4">语法</a></h4>
<pre><code>move [{/y|-y}] [&lt;source&gt;] [&lt;target&gt;]
</code></pre>
<h4 id="参数-4"><a class="header" href="#参数-4">参数</a></h4>
<div class="table-wrapper"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody>
<tr><td>/y</td><td>停止确认是否要覆盖现有目标文件的提示。 COPYCMD 环境变量中可能预设了此参数。 可以使用 -y 参数替代此预设。 除非命令是从批处理脚本中运行，否则默认会在覆盖文件之前进行提示。</td></tr>
<tr><td>-y</td><td>启动确认是否要覆盖现有目标文件的提示。</td></tr>
<tr><td><code>&lt;source&gt;</code></td><td>指定要移动的文件的路径和名称。 若要移动或重命名目录，<em>source</em> 应为当前目录的路径和名称。</td></tr>
<tr><td><code>&lt;target&gt;</code></td><td>指定要将文件移动到的路径和名称。 若要移动或重命名目录，<em>target</em> 应为目标目录的路径和名称。</td></tr>
<tr><td>/?</td><td>在命令提示符下显示帮助。</td></tr>
</tbody></table>
</div>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<p>若要将扩展名为 .xls 的所有文件从 \Data 目录移动到 \Second_Q\Reports 目录，请键入：</p>
<pre><code>move \data\*.xls \second_q\reports\

</code></pre>
<h3 id="renrename"><a class="header" href="#renrename">ren(rename)</a></h3>
<p>重命名文件（文件夹）。</p>
<p>修改文件名示例：</p>
<pre><code class="language-bat">ren a.txt b.txt
</code></pre>
<p>若要将当前目录中的所有 .txt 文件扩展名更改为 .doc 扩展名，请键入：</p>
<pre><code class="language-bat">ren *.txt *.doc
</code></pre>
<p>若要将目录的名称从 Chap10 更改为 Part10，请键入：</p>
<pre><code class="language-bat">ren chap10 part1
</code></pre>
<p>备注</p>
<ul>
<li>
<p>重命名文件时不能指定新的驱动器或路径。 你也不能使用此命令跨驱动器重命名文件或将文件移动到不同的目录（可以使用 <code>mkdir</code> 创建文件夹，<code>move</code> 移动文件路径 ）。</p>
</li>
<li>
<p>filename2 中通配符表示的字符与 filename1 中对应的字符相同。</p>
</li>
<li>
<p>filename2 必须是唯一的文件名。 如果 filename2 与现有文件名匹配，则会显示以下消息：Duplicate file name or file not found。</p>
</li>
</ul>
<p>在mac/linux/unix系统中，重命名文件使用<code>mv</code>命令。</p>
<p>注意 <code>mv</code>可以修改文件路径</p>
<h3 id="setx设置环境变量"><a class="header" href="#setx设置环境变量">setx(设置环境变量)</a></h3>
<blockquote>
<p>若 key 或者 value 中有空格，使用双引号括起来。</p>
</blockquote>
<p>设置当前用户的环境变量</p>
<pre><code class="language-shell">setx KEY VALUE

</code></pre>
<p>设系统环境变量，后面追加 <code>/m</code></p>
<pre><code class="language-shell">setx KEY VALUE /m

</code></pre>
<h3 id="start-1"><a class="header" href="#start-1">start</a></h3>
<p>启动单独的命令提示符窗口以运行指定的程序或命令。</p>
<h2 id="样例"><a class="header" href="#样例">样例</a></h2>
<h3 id="复制文件示例"><a class="header" href="#复制文件示例">复制文件示例</a></h3>
<p>本示例描述，将指定目录下的三个文件夹复制到目标文件夹下，要求：</p>
<ul>
<li>复制所有子目录</li>
<li>覆盖现有文件而不提示</li>
</ul>
<pre><code class="language-bat">@echo off
rem 将执行目录切换到当前目录，因为以管理员运行默认为 c://Windwows/System32 目录
cd /d %~dp0
rem 中文编码，避免一些中文乱码
chcp 65001 &gt; nul
rem 设置源文件夹路径和目标文件夹路径变量
set "source_folder=TSIM.Shared"  
set "destination_folder=TSIM.Unity/Packages/TSIM.Shared"  
  
:: 确保目标文件夹存在，如果不存在则创建它  
if not exist "%destination_folder%" mkdir "%destination_folder%"  
  
:: 复制文件夹  
xcopy /E /I /Y "%source_folder%\Models" "%destination_folder%\Models"  
xcopy /E /I /Y "%source_folder%\Models_Common" "%destination_folder%\Models_Common"  
xcopy /E /I /Y "%source_folder%\Services" "%destination_folder%\Services" 


echo "复制完成！"
pause
</code></pre>
<p><strong>选项说明</strong></p>
<ul>
<li>/E：复制所有子目录，包括空的子目录。</li>
<li>/I：如果目标不存在且复制多个文件，此选项将假定目标必须是目录。这在目标目录尚未创建时尤其有用，可以避免提示确认。</li>
<li>/Y：覆盖现有的目标文件而不提示。</li>
</ul>
<h3 id="获取日期和时间作为文件名"><a class="header" href="#获取日期和时间作为文件名">获取日期和时间作为文件名</a></h3>
<p>例子：创建一个用日期和时间命名的文件夹: <code>C:\dddd-MM-dd-hhmmss</code></p>
<pre><code class="language-bat">@echo off

:: 处理时间的小时数为个位数时，出现空格(会导致认为是命令分割)。使用0补位
set t=%time:~0,2%%time:~3,2%%time:~6,2%
set t=%t: =0%


:: 定义备份目录（可以根据需要更改）
set backupDir=C:\%date:~0,4%-%date:~5,2%-%date:~8,2%-%t%
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分区mbr格式转gpt格式"><a class="header" href="#分区mbr格式转gpt格式">分区MBR格式转GPT格式</a></h1>
<p>本教程将指导您将MBR转换为GPT分区表。</p>
<h2 id="步骤"><a class="header" href="#步骤">步骤</a></h2>
<ol>
<li>打开DiskGenius，选择要转换的磁盘。</li>
<li>在左侧导航栏中，选择"分区管理"。</li>
<li>在右侧的"分区列表"中，右键单击要转换的分区，选择"转换为GPT"。</li>
<li>输入新分区的名称和大小，然后点击"确定"按钮。</li>
<li>等待转换完成。</li>
<li>重启计算机以使更改生效。</li>
</ol>
<h2 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h2>
<ol>
<li>
<p>在分区的前后没有足够的空闲空间？</p>
<ul>
<li>使用分区调整工具，前部分分区默认不变</li>
<li>后部分分区设置 8MB，使用键盘上方的数字键输入，小键盘可能无法使用。</li>
</ul>
</li>
<li>
<p>调整分区出现未使用簇的问题？</p>
<ul>
<li>首先，在开始菜单的运行中输入cmd，打开命令提示符。</li>
<li>在命令行中输入“chkdsk /f /x c:”，其中“c:”应替换为实际提示有问题的盘符（有时候显示的是F盘）。这个命令会检查并修复磁盘上的文件系统错误。</li>
<li>回车执行命令，然后根据提示进行操作。如果控制台提示在下次开机时处理，请重启电脑，并等待磁盘检查完成。</li>
<li>完成磁盘检查后，通常就可以正常地在DiskGenius等工具中进行无损调整分区操作了，此时不会再出现“$Bitmap中有标记已使用的未用簇”的提示。</li>
<li>请注意，执行这些操作前，请确保已备份重要数据，以防数据丢失。检查分区表是否已成功转换为GPT。</li>
<li>检查分区是否已成功创建。</li>
<li>尝试重新启动计算机并再次尝试使用分区。</li>
</ul>
</li>
<li>
<p>将硬盘从MBR转GPT后无法进入系统？</p>
<ul>
<li>在CMD中执行命令：<code>bcdboot F:\Windows /s F: /f uefi</code>。</li>
<li>注意 <code>F</code> 是盘符号。</li>
</ul>
</li>
<li>
<p>回到系统还是不能更新系统，出现错误</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac"><a class="header" href="#mac">Mac</a></h1>
<h2 id="使用手册-1"><a class="header" href="#使用手册-1">使用手册</a></h2>
<p><a href="https://support.apple.com/zh-cn/guide/mac-help/welcome/14.0/mac">MacOS 使用手册</a></p>
<h3 id="在-mac-上安装和卸载来自互联网或光盘的-app"><a class="header" href="#在-mac-上安装和卸载来自互联网或光盘的-app">在 Mac 上安装和卸载来自互联网或光盘的 App</a></h3>
<h4 id="安装-app"><a class="header" href="#安装-app">安装 App</a></h4>
<p>在 Mac 上，执行以下任一项操作：</p>
<p>对于从互联网下载的 App：在“下载”文件夹中，连按磁盘映像或软件包文件（外观像打开的盒子）。如果提供的安装器未自动打开，请打开安装器，然后遵循屏幕指示执行操作。</p>
<p>【注】如果看到一个警告对话框，提示正在安装无法识别的开发者开发的 App，请参阅打开来自身份不明开发者的 Mac App。</p>
<p>对于光盘上的 App：将光盘插入 Mac 上或连接到 Mac 的光盘驱动器。</p>
<p>若要重新安装从 App Store 下载的 App，请参阅安装从 App Store 购买的项目。</p>
<h3 id="卸载-app"><a class="header" href="#卸载-app">卸载 App</a></h3>
<p>你可以移除从互联网或光盘所下载并安装的 App。</p>
<p>在 Mac 上，点按程序坞中的“访达”图标 ，然后点按“访达”边栏中的“应用程序”。</p>
<p>请执行以下一项操作：</p>
<p>如果 App 位于文件夹中：打开 App 的文件夹以检查卸载器。如果看到“卸载 [App]”或“[App] 卸载器”，请连按它，然后按照屏幕指示进行操作。</p>
<p>如果 App 并非位于文件夹中或没有卸载器：将 App 从“应用程序”文件夹拖移到废纸篓（位于程序坞末端）。</p>
<p>【警告】下次你或“访达”清倒废纸篓时，该 App 会从你的 Mac 永久移除。如果你有使用该 App 创建的文件，则可能无法再次打开它们。如果决定要保留 App，请在清倒废纸篓前将其放回原处。在废纸篓中选择该 App，然后选取“文件”&gt;“放回原处”。</p>
<p>若要卸载从 App Store 下载的 App，请使用启动台。</p>
<h2 id="命令"><a class="header" href="#命令">命令</a></h2>
<h3 id="mv-重命名文件"><a class="header" href="#mv-重命名文件">mv (重命名文件)</a></h3>
<pre><code class="language-shell">mv old_name new_name
</code></pre>
<h3 id="cp-复制文件"><a class="header" href="#cp-复制文件">cp (复制文件)</a></h3>
<pre><code class="language-shell">cp old_name new_name
</code></pre>
<h3 id="rm-删除文件"><a class="header" href="#rm-删除文件">rm (删除文件)</a></h3>
<pre><code class="language-shell">rm old_name
</code></pre>
<h3 id="ls-列出文件"><a class="header" href="#ls-列出文件">ls (列出文件)</a></h3>
<pre><code class="language-shell">ls
</code></pre>
<h3 id="pwd-显示当前目录"><a class="header" href="#pwd-显示当前目录">pwd (显示当前目录)</a></h3>
<pre><code class="language-shell">pwd
</code></pre>
<h3 id="cd-切换目录"><a class="header" href="#cd-切换目录">cd (切换目录)</a></h3>
<pre><code class="language-shell">cd /path/to/directory
</code></pre>
<h3 id="mkdir-创建目录"><a class="header" href="#mkdir-创建目录">mkdir (创建目录)</a></h3>
<pre><code class="language-shell">mkdir new_directory
</code></pre>
<h3 id="rmdir-删除目录"><a class="header" href="#rmdir-删除目录">rmdir (删除目录)</a></h3>
<pre><code class="language-shell">rmdir new_directory
</code></pre>
<h3 id="cat-查看文件内容"><a class="header" href="#cat-查看文件内容">cat (查看文件内容)</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xcode"><a class="header" href="#xcode">XCode</a></h1>
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testflight"><a class="header" href="#testflight">TestFlight</a></h1>
<h2 id="某个账号无法安装测试版本"><a class="header" href="#某个账号无法安装测试版本">某个账号无法安装测试版本</a></h2>
<p>情况描述：</p>
<p>上架了某个软件，进行过 Testflight 测试，中途开发者账号终止过订阅，该软件在 Testflight 中显示失效，后面上架此软件，但是之前的账号无法收到版本更新软件，新添加的测试账号可以收到。</p>
<p>过了几天后才收到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="下载google商定apk"><a class="header" href="#下载google商定apk">下载Google商定APK</a></h1>
<p>使用梯子进入<a href="https://play.google.com/store">Googel商店</a></p>
<p>找到要下载的软件</p>
<p>赋值浏览器当前的地址</p>
<p>进入 <a href="https://apps.evozi.com/apk-downloader/">APK Downloader</a></p>
<p>粘贴之前的网址进去，解析后，如果成功，点击下载</p>
<p>注意，如果安装了迅雷会自动使用迅雷下载，会失败，使用浏览器自带的下载成功</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nginx"><a class="header" href="#nginx">Nginx</a></h1>
<h2 id="说明-3"><a class="header" href="#说明-3">说明</a></h2>
<p>一个证书对应一个域名，即可以所有的代理端口都可以使用同一个证书。</p>
<h2 id="配置unitywebgl服务器"><a class="header" href="#配置unitywebgl服务器">配置UnityWebGL服务器</a></h2>
<p>根据目录名称，访问unity 内容时，定位到 指定位置，配置和文件目录结构对比</p>
<p><img src="technology-stack/image/Nginx/1723531679363.png" alt="1723531679363" /></p>
<p><img src="technology-stack/image/Nginx/1723531697200.png" alt="1723531697200" /></p>
<p>访问001的Unity项目（443端口省略）：<a href="http://192.168.0.199/unisim/001/?NjUyNTA5N2ZmYjU1OTU1ODNlYzA2NzE4KzErNjVlMTliYjgzNjU2N2YyMjRhMjZmNjRmKzY1ZTE5YjhiMzY1NjdmMjI0YTI2ZjY0ZQ==">https://www.11training.com/unisim/001/?</a>参数</p>
<h2 id="配置证书"><a class="header" href="#配置证书">配置证书</a></h2>
<ul>
<li>配置文件：这里的7130需要在路由器上配置映射到主机，并且要重启，然后更改防火墙设置，开发7130的进出规则</li>
</ul>
<p><img src="technology-stack/image/nginx/image_xsZ7NwaAq2.png" alt="" /></p>
<ul>
<li><strong>证书的路径</strong>：相对于配置文件的，这里的cert文件夹就是和配置文件同目录的，当然可以放在外边去；</li>
<li>重启生效。</li>
</ul>
<h2 id="命令行重启勿用"><a class="header" href="#命令行重启勿用">命令行重启（勿用）</a></h2>
<p><strong>Windows</strong>:</p>
<blockquote>
<p>❌不知道什么原因，使用命令行来进行重启，要么，就是启动了多个进程，要么就是关掉了进程没重启。</p>
<p>老老实实在任务管理器中 结束任务，再重启比较靠谱</p>
</blockquote>
<pre><code class="language-重启">chcp 65001 &gt; nul
@echo off
cd /d %~dp0

nginx -s reload

echo Nginx 已重启
pause

</code></pre>
<p>关闭（有效）</p>
<pre><code class="language-shell">@echo off
cd C:/TSIM/nginx-1.25.4
nginx -s stop
timeout /t 2 /nobreak &gt;nul
pause

</code></pre>
<h2 id="实现浏览器播放音视频"><a class="header" href="#实现浏览器播放音视频">实现浏览器播放音视频</a></h2>
<p>默认情况下，将音视频放在Nginx中，在浏览器上打开触发的是下载操作</p>
<p>修改配置文件（支持单格式）</p>
<pre><code class="language-conf">server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
			# autoindex off; # 好像不能写这个
			expires 30d;
			add_header Content-Type audio/wav; # 这里配置支持wav文件，其他格式相应调整
			add_header Cache-Control "public";
            index  index.html index.htm;
        }
}
</code></pre>
<p>修改配置文件（支持多格式）</p>
<pre><code class="language-conf">server {
  listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
			# autoindex off;
			expires 30d;
			# add_header Content-Type audio/wav; # 这里配置支持wav文件，其他格式相应调整
			# add_header Cache-Control "public";
			
			types {
				# 添加音频MIME类型
				audio/mpeg mp3;
				audio/ogg ogg;
				audio/wav wav;
				audio/x-aac aac;
				audio/x-ms-wma wma;
				audio/webm webm;
			}

			# 设置默认类型为octet-stream可作为通用后备
			default_type application/octet-stream;		
            index  index.html index.htm;
        }      
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rabbitmq"><a class="header" href="#rabbitmq">RabbitMQ</a></h1>
<p><a href="https://www.rabbitmq.com/tutorials/tutorial-four-dotnet">官网教程</a></p>
<p><a href="https://gitee.com/AByte-L/csharp-dev-demo/tree/master/05RabbitMQ">案例教程</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<h2 id="退出代理导致连接失败"><a class="header" href="#退出代理导致连接失败">退出代理导致连接失败</a></h2>
<p>环境：macbook</p>
<p>现象：使用代理后，退出代理，出现无法连接仓库地址（浏览器正常），github 和 gitee都无法连接。</p>
<p>错误信息：</p>
<pre><code>fatal: unable to access 'https://github.com/benjieqiang/programmer.git/': Failed to connect to 127.0.0.1 port 7890: Connection refused
</code></pre>
<p>解决方案：</p>
<p>查看代理
git config --global --get http.proxy
git config --global --get https.proxy</p>
<p>取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy</p>
<h2 id="推送失败"><a class="header" href="#推送失败">推送失败</a></h2>
<pre><code>error: RPC failed; HTTP 400 curl 22 The requested URL returned error: 400
</code></pre>
<p>推送时出现以下错误提示</p>
<pre><code class="language-bash">
Enumerating objects: 22, done.
Counting objects: 100% (22/22), done.
Delta compression using up to 10 threads
Compressing objects: 100% (16/16), done.
Writing objects: 100% (16/16), 1019.20 KiB | 33.97 MiB/s, done.
Total 16 (delta 9), reused 0 (delta 0), pack-reused 0
error: RPC failed; HTTP 400 curl 22 The requested URL returned error: 400
send-pack: unexpected disconnect while reading sideband packet
fatal: the remote end hung up unexpectedly
Everything up-to-date

</code></pre>
<p>缓存区太小的原因：</p>
<p>设置为5大小</p>
<pre><code class="language-bash">git config --global http.postBuffer 5242880000
</code></pre>
<h2 id="在拉取中提示版本冲突"><a class="header" href="#在拉取中提示版本冲突">在拉取中提示版本冲突</a></h2>
<p>当在终端或者在VS中拉取时，提示版本冲突，此时都要回到终端来进行处理</p>
<p>当版本冲突时，会输出以下内容</p>
<pre><code class="language-bash">Hint: You have divergent branches and need to specify how to reconcile them.
Hint: You can do so by running one of the following commands sometime before
Hint: your next pull:
Hint: 
Hint:   git config pull.rebase false  # merge
Hint:   git config pull.rebase true   # rebase
Hint:   git config pull.ff only       # fast-forward only
Hint: 
Hint: You can replace "git config" with "git config --global" to set a default
Hint: preference for all repositories. You can also pass --rebase, --no-rebase,
Hint: or --ff-only on the command line to override the configured default per
Hint: invocation.
</code></pre>
<p>输出的内容给出解决方案，以下作为一个中文说明</p>
<p>这个错误提示是因为你的本地分支和远程分支之间有分歧（divergent branches），Git 需要你指定如何处理这些分歧。在拉取（pull）代码时，Git 既可以通过合并（merge）来解决分歧，也可以通过重置（rebase）来解决分歧。</p>
<p>快速解决</p>
<p>使用终端执行命令：</p>
<pre><code class="language-sh">git config pull.rebase false
</code></pre>
<p>再执行拉取命令</p>
<pre><code class="language-sh">git config pull
</code></pre>
<p>如果进入 <strong>Vim</strong> 编辑模式，如提示我们编写 commit，修改合并后的冲突文件等，请参照 <a href="technology-stack/vim.html">Vim</a> 操作</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="svn"><a class="header" href="#svn">SVN</a></h1>
<h2 id="检出指定目录"><a class="header" href="#检出指定目录">检出指定目录</a></h2>
<p>在 <code>checkout</code> 窗口，点击 <code>Choose items...</code>，选择要检出的目录</p>
<h2 id="更新检出的目录"><a class="header" href="#更新检出的目录">更新检出的目录</a></h2>
<p>在已检出的项目文件夹上，右键-&gt;SVN-&gt;Update to Revision，在打开的窗口中点击 <code>Choose items...</code> ，选择要检出的目录</p>
<div style="break-before: page; page-break-before: always;"></div><style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 12px;
    text-align: left;
    vertical-align: top; 
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.key-cell {
    background-color: #df7400;
}

/* .excel-table tr:nth-child(even) {
    background-color: #f9f9f9;
} */
/* 禁用隔行背景色不同的功能 */
.excel-table tr:nth-child(even), table tr:nth-child(odd) {
    background-color: transparent; /* 确保所有行背景色一致 */
}

.excel-table tr:hover {
    background-color: inherit;
}


.bold-first-column {
    font-weight: bold;
}
.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    /* width: 30%; */
    width:60px;
 
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 25%;
}
.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width:80px;
}

.excel-table th:nth-child(4), .excel-table td:nth-child(4) {
    width: 75%;
}
</style>
<h1 id="vim"><a class="header" href="#vim">Vim</a></h1>
<h2 id="安装-5"><a class="header" href="#安装-5">安装</a></h2>
<h3 id="windows-安装"><a class="header" href="#windows-安装">Windows 安装</a></h3>
<p>通过下载执行文件 安装 <a href="https://www.vim.org/download.php">下载地址</a></p>
<p>下载后添加环境变量，即可使用 <code>vim</code></p>
<h3 id="macos-1"><a class="header" href="#macos-1">MacOS</a></h3>
<pre><code class="language-shell">brew install vim
</code></pre>
<h2 id="快速使用"><a class="header" href="#快速使用">快速使用</a></h2>
<h3 id="vim-的基本概念"><a class="header" href="#vim-的基本概念">Vim 的基本概念</a></h3>
<p>Vim 是一种强大的文本编辑器，以其高效的编辑功能而著名。它有三种主要模式：</p>
<ul>
<li><strong>命令模式</strong>：这是默认模式，用于导航和执行命令。</li>
<li><strong>插入模式</strong>：用于输入文本。</li>
<li><strong>末行模式</strong>：用于执行复杂命令。</li>
</ul>
<p><img src="technology-stack/image/vim/1720764317950.png" alt="1720764317950" /></p>
<h3 id="操作指令"><a class="header" href="#操作指令">操作指令</a></h3>
<p>在终端中输入 vim，然后回车。你会看到一个新的 Vim 窗口。</p>
<div class="table-container">
    <table class="excel-table" id="example-table">
        <thead>
            <tr>
                <th>模式</th>
                <th>类型</th>
                <th>命令</th>
                <th>说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="bold-first-column" rowspan=12>命令模式</td>
                <td rowspan=4>移动光标</td>
                <td><code>h</td>
                <td>向左移动光标</td>
            </tr>
             <tr>
                <td><code>j</td>
                <td>向下移动光标</td>
            </tr>
            <tr>
                <td><code>k</td>
                <td>向上移动光标</td>
            </tr>
            <tr>
                <td><code>l</td>
                <td>向右移动光标</td>
            </tr>           
             <tr>
                <td rowspan="2">删除文本</td>
                <td><code>x</td>
                <td>删除光标所在的字符</td>
            </tr>
            <tr>
                <td><code>dd</td>
                <td>删除整行</td>
            </tr>
             <tr>
                <td rowspan="2">撤销和重做</td>
                <td><code>u</td>
                <td>撤销上一个操作</td>
            </tr>
            <tr>
                <td><code>Ctrl + r</td>
                <td>重做上一个操作</td>
            </tr>
             <tr>
                <td rowspan=3>进入插入模式</td>
                <td><code>i</td>
                <td>在光标前插入，进入插入模式</td>
            </tr>
             <tr>
                <td><code>a</td>
                <td>在光标后插入，进入插入模式</td>
            </tr>
             <tr>
                <td class="key-cell"><code>o</td>
                <td class="key-cell">在当前行下方打开新行并插入，进入插入模式</td>
            </tr>   
             <tr>
                <td >进入末行模式</td>
                <td class="key-cell"><code>:</td>
                <td class="key-cell">进入末行模式，并且底线输入里面显示 <code>:</code></td>
            </tr>         
              <tr>
                <td class="bold-first-column" rowspan="1">插入模式</td>
                <td>返回命令模式</td>
                <td><code>Esc</td>
                <td>返回命令模式。<br>插入模式下和普通的文本编辑一样，但是不能使用<b>Ctr + z</b> 等进行撤销，可退回到命令模式使用相关命令</td>
            </tr>
             <tr>
                <td class="bold-first-column" rowspan="6">末行模式</td>
               <td>返回命令模式</td>
                <td><code>Esc</td>
                <td>返回命令模式，注意不是退出Vim</td>
            </tr>
            <tr>
                <td>保存文件</td>
                <td><code>:w</td>
                <td>按下 <code>enter</code> 键，保存当前更改并返回命令模式</td>
            </tr>
             <tr>
                <td>另存为</td>
                <td><code>:w 文件名</td>
                <td>按下 <code>enter</code> 键，另存为指定文件名，并返回命令模式</td>
            </tr>
             <tr>
                <td>退出Vim</td>
                <td><code>:q</td>
                <td>按下 <code>enter</code> 键，退出Vim，注意如果更改了会提示执行保存操作</td>
            </tr>
             <tr>
                <td>强制退出Vim</td>
                <td><code>:q!</td>
                <td>按下 <code>enter</code> 键，强制退出</td>
            </tr>
             <tr>
                <td>保存并退出Vim</td>
                <td class="key-cell"><code>:wq</td>
                <td class="key-cell">按下 <code>enter</code> 键，保存并退出Vim <b>常用</b></td>
            </tr>
        </tbody>
    </table>
</div>
<h2 id="什么是-vim"><a class="header" href="#什么是-vim">什么是 vim？</a></h2>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p>vim 键盘图：</p>
<p><img src="technology-stack/image/vim/1720748336783.png" alt="1720748336783" /></p>
<h2 id="vim-的使用"><a class="header" href="#vim-的使用">vim 的使用</a></h2>
<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p>
<h3 id="命令模式"><a class="header" href="#命令模式">命令模式：</a></h3>
<p>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<h3 id="输入模式"><a class="header" href="#输入模式">输入模式</a></h3>
<p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li>
<li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li>
<li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<h3 id="底线命令模式"><a class="header" href="#底线命令模式">底线命令模式</a></h3>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img src="technology-stack/image/vim/1720748363917.png" alt="1720748363917" /></p>
<h2 id="vim-使用实例"><a class="header" href="#vim-使用实例">vim 使用实例</a></h2>
<h3 id="使用-vivim-进入一般模式"><a class="header" href="#使用-vivim-进入一般模式">使用 vi/vim 进入一般模式</a></h3>
<p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p>
<pre><code class="language-bash">vim runoob.txt

</code></pre>
<p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p>
<p><img src="technology-stack/image/vim/1720748407988.png" alt="1720748407988" /></p>
<h3 id="按下-i-进入输入模式也称为编辑模式开始编辑文字"><a class="header" href="#按下-i-进入输入模式也称为编辑模式开始编辑文字">按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</a></h3>
<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<p><img src="technology-stack/image/vim/1720748419445.png" alt="1720748419445" /></p>
<h3 id="按下-esc-按钮回到一般模式"><a class="header" href="#按下-esc-按钮回到一般模式">按下 ESC 按钮回到一般模式</a></h3>
<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<h3 id="在一般模式中按下-wq-储存后离开-vi"><a class="header" href="#在一般模式中按下-wq-储存后离开-vi">在一般模式中按下 :wq 储存后离开 vi</a></h3>
<p>OK，我们要存档了，存盘并离开的指令很简单，输入 :wq 即可保存离开！</p>
<p><img src="technology-stack/image/vim/1720748431371.png" alt="1720748431371" /></p>
<p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="npm"><a class="header" href="#npm">Npm</a></h1>
<h2 id="安装-6"><a class="header" href="#安装-6">安装</a></h2>
<p>通过安装 <code>Nodejs</code> 来一起安装</p>
<p><strong>Windows环境安装</strong>：下载msi文件安装</p>
<ul>
<li>
<p><a href="https://nodejs.org/zh-cn">Node.js官网地址(需要VPN)</a></p>
</li>
<li>
<p><a href="https://nodejs.org/zh-cn">Node.js中文网 有广告 但是都能下载</a></p>
</li>
<li>
<p><a href="https://npm.nodejs.cn/cli/v10/commands/npm">Npm Cli 手册</a></p>
</li>
</ul>
<h2 id="设置镜像源"><a class="header" href="#设置镜像源">设置镜像源</a></h2>
<p>国内使用 <code>npm</code> 非常慢，甚至就用不了，要么使用淘宝镜像，或者使用 <code>cnpm</code></p>
<p><a href="https://blog.csdn.net/weixin_45046532/article/details/139681731">博客文章</a></p>
<p>使用 淘宝 镜像</p>
<pre><code class="language-shell">npm config set registry https://registry.npm.taobao.org/
</code></pre>
<p>使用 <code>cnpm</code>，‌这是淘宝提供的 <code>npm</code> 镜像，‌使用 <code>cnpm</code> 安装依赖通常会比使用 <code>npm</code> 快很多。‌例如，‌通过命令 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org/</code> 来安装 <code>cnpm</code> ，‌然后使用 <code>cnpm install</code> 来安装包。‌</p>
<pre><code class="language-shell">npm install -g cnpm --registry=https://registry.npm.taobao.org/
</code></pre>
<h2 id="错误解决"><a class="header" href="#错误解决">错误解决</a></h2>
<h3 id="code-cert_has_expired"><a class="header" href="#code-cert_has_expired">code CERT_HAS_EXPIRED</a></h3>
<p>Npm 的证书过期，需要安装证书，可以创建自定义证书，但是比较麻烦，可以设置忽略证书</p>
<pre><code class="language-shell">npm config set strict-ssl false
</code></pre>
<p>恢复证书</p>
<pre><code class="language-shell">npm config set strict-ssl true
</code></pre>
<h3 id="代理导致无法访问"><a class="header" href="#代理导致无法访问">代理导致无法访问</a></h3>
<p>错误信息：</p>
<pre><code class="language-bash"> ECONNREFUSED
npm ERR! syscall connect
npm ERR! errno ECONNREFUSED
npm ERR! FetchError: request to https://registry.npmjs.org/create-tauri-app/-/create-tauri-app-3.10.0.tgz failed, reason: connect ECONNREFUSED 127.0.0.1:31181
npm ERR!     at ClientRequest.&lt;anonymous&gt; (C:\Program Files\nodejs\node_modules\npm\node_modules\minipass-fetch\lib\index.js:130:14)
npm ERR!     at ClientRequest.emit (node:events:512:28)
npm ERR!     at onerror (C:\Program Files\nodejs\node_modules\npm\node_modules\agent-base\dist\src\index.js:117:21)
npm ERR!     at callbackError (C:\Program Files\nodejs\node_modules\npm\node_modules\agent-base\dist\src\index.js:136:17)
npm ERR!     at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
npm ERR!  FetchError: request to https://registry.npmjs.org/create-tauri-app/-/create-tauri-app-3.10.0.tgz failed, reason: connect ECONNREFUSED 127.0.0.1:31181
npm ERR!     at ClientRequest.&lt;anonymous&gt; (C:\Program Files\nodejs\node_modules\npm\node_modules\minipass-fetch\lib\index.js:130:14)
npm ERR!     at ClientRequest.emit (node:events:512:28)
npm ERR!     at onerror (C:\Program Files\nodejs\node_modules\npm\node_modules\agent-base\dist\src\index.js:117:21)
npm ERR!     at callbackError (C:\Program Files\nodejs\node_modules\npm\node_modules\agent-base\dist\src\index.js:136:17)
npm ERR!     at process.processTicksAndRejections (node:internal/process/task_queues:95:5) {
npm ERR!   code: 'ECONNREFUSED',
npm ERR!   errno: 'ECONNREFUSED',
npm ERR!   syscall: 'connect',
npm ERR!   address: '127.0.0.1',
npm ERR!   port: 31181,
npm ERR!   type: 'system'
npm ERR! }
npm ERR!
npm ERR! If you are behind a proxy, please make sure that the
npm ERR! 'proxy' config is set properly.  See: 'npm help config'

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\ABYTE\AppData\Local\npm-cache\_logs\2024-10-08T01_59_58_888Z-debug-0.log
</code></pre>
<p><strong>解决方案：</strong></p>
<p>该错误信息表明 NPM 在尝试下载 create-tauri-app 包时无法连接到 127.0.0.1:31181，导致 ECONNREFUSED 错误。这意味着你的机器拒绝了连接请求。常见的原因包括代理配置问题或网络连接问题。</p>
<p>以下是一些可能的解决方案：</p>
<ol>
<li>检查代理设置：如果你在公司网络或其他需要代理服务器的网络环境中，请确保 NPM 的代理配置正确。使用以下命令查看代理配置：</li>
</ol>
<pre><code class="language-bash">npm config get proxy
npm config get https-proxy
</code></pre>
<p>如果配置了代理，但网络环境不需要代理，可以通过以下命令禁用代理：</p>
<pre><code class="language-bash">npm config delete proxy
npm config delete https-proxy
</code></pre>
<ol start="2">
<li>清除 NPM 缓存：有时缓存可能会导致下载问题，可以尝试清除缓存：</li>
</ol>
<pre><code class="language-bash">npm cache clean --force
</code></pre>
<ol start="3">
<li>检查是否运行了本地 NPM Registry</li>
</ol>
<p>错误信息中的地址 127.0.0.1 是本地回环地址，通常表示 NPM 正在尝试连接到你本机上运行的服务。如果你之前配置了本地的 NPM Registry 服务，但该服务没有启动或者端口号不正确，你可能会遇到此问题。</p>
<p>检查本地配置：</p>
<pre><code class="language-bash">npm config get registry
</code></pre>
<p>如果 registry 配置为 http://127.0.0.1:31181，但你并没有运行本地的 NPM Registry，改为默认的 NPM Registry：</p>
<pre><code class="language-bash">npm config set registry https://registry.npmjs.org/
</code></pre>
<ol start="4">
<li>检查网络连接</li>
</ol>
<p>确保你可以正常访问外网，并且没有防火墙或其他网络安全设置阻止对 registry.npmjs.org 的访问。</p>
<p>通过命令行测试连接：</p>
<pre><code class="language-bash">ping registry.npmjs.org
</code></pre>
<p>或者使用 curl 工具测试：</p>
<pre><code class="language-bash">curl -I https://registry.npmjs.org/
</code></pre>
<ol start="5">
<li>更新 NPM 版本</li>
</ol>
<p>如果以上步骤无法解决问题，尝试更新 NPM 版本以修复潜在的 bug：</p>
<pre><code class="language-bash">npm install -g npm
</code></pre>
<p>如果问题仍然存在，请告知你所处的网络环境和其他相关配置，我可以进一步帮助分析。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pip"><a class="header" href="#pip">PIP</a></h1>
<h2 id="安装-7"><a class="header" href="#安装-7">安装</a></h2>
<p><img src="https://pip.pypa.io/en/stable/installation/" alt="参考" /></p>
<p>通过 ensurepip 安装</p>
<p>Mac/Linux</p>
<pre><code class="language-bash">python3 -m ensurepip --upgrade
</code></pre>
<h3 id="windows-2"><a class="header" href="#windows-2">Windows</a></h3>
<pre><code class="language-bash">C:&gt; py -m ensurepip --upgrade
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssh"><a class="header" href="#ssh">SSH</a></h1>
<h2 id="连接步骤"><a class="header" href="#连接步骤">连接步骤</a></h2>
<p>在 <strong>Windows</strong> 上，首先安装 <code>OpenSSH</code>，然后使用 <code>PowerShell</code> 连接</p>
<p>假设服务器名称为：<code>SVRNAME</code>，域名为：<code>domain.com</code>，账户为：<code>zhangsan</code>，默认端口 <strong>22</strong> 开放</p>
<p><strong>一、连接服务器</strong></p>
<pre><code class="language-bash">ssh zhangsan@domain.com -p 22
</code></pre>
<p>若端口为 <code>22</code> ，可不写，否则要指定端口</p>
<p><strong>二、若连接成功提示如下提示输入密码，输入的密码不会显示，输入完成后按回车键（若提示连接失败，检查域名和端口是否正确，可使用IP地址等尝试）</strong></p>
<pre><code class="language-bash">zhangsan@domain.com's password:
</code></pre>
<p><strong>三、成功后进入当前账号的家目录（ <code>~</code>: 表示家目录，<code>$</code>：表示非 root 账号），登陆时都是非 root 账号类型</strong></p>
<pre><code class="language-bash">zhangsan@SVRNAME:~$ 
</code></pre>
<p>此时可以查看当前家目录下的目录结构</p>
<pre><code class="language-bash">zhangsan@SVRNAME:~$ ls
</code></pre>
<p><strong>四、切换到 <code>root</code> 账号 (只有具有管理员权限的才可以切换成功)</strong></p>
<pre><code class="language-bash">zhangsan@SVRNAME:~$ sudo -i
</code></pre>
<p><strong>五、再次输入密码</strong></p>
<pre><code class="language-bash">zhangsan@SVRNAME:~$ sudo -i
password:
</code></pre>
<p><strong>六、输入成功后，<code>zhangsan</code> 变为 <code>root</code>, <code>$</code> 变为 <code>#</code></strong></p>
<pre><code class="language-bash">root@SVRNAME:~# 
</code></pre>
<p>使用 <code>ls</code>，提示 <code>FOR SYSTEM USE ONLY. DO NOT UPLOAD FILES HERE.</code>，后面再详细讲解。</p>
<pre><code class="language-bash">root@SVRNAME:~#  ls
</code></pre>
<p><strong>七、切换到根目录，任何时候都可以使用 <code>cd /</code> 切换到根目录</strong></p>
<pre><code class="language-bash">root@SVRNAME:~# cd /
root@SVRNAME:/# 
</code></pre>
<p><strong>八、切换到家目录，任何时候都可以使用 <code>cd ~</code> 切换到家目录</strong></p>
<pre><code class="language-bash">root@SVRNAME:/# cd /
root@SVRNAME:~# 
</code></pre>
<p><strong>九、退出登陆,如果是 root 登陆状态，那么将退出到 非root账号登陆状态，再次退出才能完全退出登陆</strong></p>
<pre><code class="language-bash">exit
</code></pre>
<h2 id="拓展"><a class="header" href="#拓展">拓展</a></h2>
<h3 id="符号认知"><a class="header" href="#符号认知">符号认知</a></h3>
<ul>
<li>
<p><code>~</code> : 表示当前登录用户的 home 目录，实际就是代表一个文件夹的路径</p>
</li>
<li>
<p><code>/</code> : 表示根节点</p>
</li>
<li>
<p><code>$</code> : 非 root 账户</p>
</li>
<li>
<p><code>#</code> : root 账户</p>
</li>
</ul>
<h3 id="根目录"><a class="header" href="#根目录">根目录（/）</a></h3>
<p>根目录就是整个设备目录的最开始处，注意并不是某个存储盘的根，任何账户使用 <code>cd /</code>，都可进入根目录：</p>
<pre><code class="language-bash">bin  boot  config  dev  etc  etc.defaults  initrd  lib  lib32  lib64  lost+found  mnt  opt  proc  root  run  sbin  sys  tmp  tmpRoot  usr  var  var.defaults  volume1  volume2
</code></pre>
<ul>
<li>
<p><code>root</code> 是 root 账号的家目录，也就是 <code>~#</code> 对应的文件夹，此文件夹拒绝访问，可以看到它也是属于根目录下的一个文件夹而已</p>
</li>
<li>
<p><code>volume1</code> 是 存储盘1</p>
</li>
<li>
<p><code>volume2</code> 是 存储盘2</p>
</li>
<li>
<p><code>/$</code> : 非 <strong>root</strong> 账户在根目录下，注意 <code>/$</code> 并不是连在一起的，如 <code>/lib$</code>  表示在根目录的 <code>lib</code> 文件夹下</p>
</li>
<li>
<p><code>/#</code> : <strong>root</strong> 账户在根目录下。</p>
</li>
</ul>
<blockquote>
<p>路径以 "<strong>/</strong>" 开头代表从根目录开始的绝对路径</p>
</blockquote>
<h3 id="家目录"><a class="header" href="#家目录">家目录（~）</a></h3>
<p>每个账户都有自己的 <strong>home</strong> 目录，它实际上也是对应了一个以根开始的目录，只是用 <code>~</code> 来代替根目录到家文件夹这段路径，使用 <code>cd ~</code>，都可进入根目录.</p>
<p>简要而言：<code>~</code>  代表一个以用户的名称命名的文件夹路径，root 账号代表 <code>/root</code> 文件夹，非 root 账号代表 <code>/某个盘/homes/账号名称</code> 文件夹路径</p>
<p>如 <code>root</code> 的家目录</p>
<pre><code class="language-text">~# 等价于 /root
</code></pre>
<p>如 <code>zhangsan</code> 的家目录</p>
<pre><code class="language-text">~$ 等价于 /volume1/homes/zhangsan

注意：这里的家目录是设置在 volume1 存储盘上，其他可能不同
</code></pre>
<h3 id="常用命令-2"><a class="header" href="#常用命令-2">常用命令</a></h3>
<ul>
<li><code>sudo -i</code> 切换到 <strong>root</strong> 登陆</li>
<li><code>cd /</code> 进入根目录</li>
<li><code>cd ~</code> 进入家目录</li>
<li><code>cd ..</code> 进入上级目录</li>
<li><code>cd ../..</code> 进入上级的上级目录，依次...</li>
<li><code>exit</code> 退出登陆,如果是 <strong>root</strong> 登陆状态，那么将退出到 非 <strong>root</strong> 账号登陆状态，再次退出才能完全退出登陆</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p><a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/lTKfePfP">B站博主的网站-Docker 快速入门</a></p>
<h2 id="连接服务器"><a class="header" href="#连接服务器">连接服务器</a></h2>
<p>连接Docker所在的服务器：<a href="technology-stack/ssh.html#ssh">前往</a>，连接成功后即可使用 <code>docker</code> 命令</p>
<h2 id="命令-1"><a class="header" href="#命令-1">命令</a></h2>
<p><a href="https://www.runoob.com/docker/docker-container-usage.html">Docker-菜鸟教程</a></p>
<h2 id="文件路径"><a class="header" href="#文件路径">文件路径</a></h2>
<p>当使用某个文件时，除非使用绝对路径（以 根目录<code>/</code>开头的路径），都是以执行 <code>docker</code> 命令的目录开始查找。</p>
<p>以配置 <strong>bagetter</strong> 为例，使用了一个环境变量配置文件 <code>bagetter.env</code>，和文件夹的挂载 <code>/vulome2/docker/bagetter/8008/data</code></p>
<p>目录结构如下：</p>
<pre><code class="language-text">/vulome2/docker/bagetter/8008/
    + data
    - bagetter.env
</code></pre>
<p><strong>使用绝对路径</strong></p>
<pre><code class="language-bash">docker run -d --rm --name nuget-server -p 8008:8008 --env-file /vulome2/docker/bagetter/8008/bagetter.env -v "/vulome2/docker/bagetter/8008/data:/data" bagetter/bagetter:latest
</code></pre>
<p><strong>使用相对路径，此时假设在 <code>/vulome2/docker/bagetter/8008</code> 下执行的 <code>docker</code></strong></p>
<pre><code class="language-bash">docker run -d --rm --name nuget-server -p 8008:8008 --env-file bagetter.env -v "data:/data" bagetter/bagetter:latest
</code></pre>
<ul>
<li>注意 <code>docker-compose</code>，在官网上写的是 <code>docker compose</code> 无法执行。</li>
</ul>
<h2 id="实例-bagetter"><a class="header" href="#实例-bagetter">实例-BaGetter</a></h2>
<h3 id="搭建包管理器"><a class="header" href="#搭建包管理器">搭建包管理器</a></h3>
<p>搭建私有 <strong>Nuget</strong> 仓库，<a href="https://github.com/bagetter/BaGetter">BaGetter-github</a></p>
<p>以下流程基于群晖的 <strong>Docker</strong> 进行部署。</p>
<p><strong>一、<a href="technology-stack/ssh.html#ssh">连接Docker所在的服务器</a></strong></p>
<p><strong>二、创建外部挂载的文件夹 <code>/volume2/docker/bagetter/8008/data</code>，如果不创建会报错找不到文件夹</strong></p>
<blockquote>
<p>备注：这里根据自己设定文件夹的位置</p>
</blockquote>
<p>切换到根目录</p>
<pre><code class="language-bash">cd /
</code></pre>
<p>创建目录(使用 <code>-p</code> 可创建多层)</p>
<pre><code class="language-bash">mkdir -p /volume2/docker/bagetter/8008/data
</code></pre>
<p>切换到8008目录，这样比较方便</p>
<pre><code class="language-bash">cd volume2/docker/bagetter/8008
</code></pre>
<p><strong>三、在 <code>/volume2/docker/bagetter/8008</code>下创建环境变量配置文件 <code>bagetter.env</code>，并添加如下内容：</strong></p>
<pre><code class="language-ini"># The following config is the API Key used to publish packages.
# You should change this to a secret value to secure your server.
ApiKey=NUGET-SERVER-API-KEY

Storage__Type=FileSystem
Storage__Path=/data
Database__Type=Sqlite
Database__ConnectionString=Data Source=/data/db/bagetter.db
Search__Type=Database

# 这个需要在环境变量中进行配置，否则无效
ASPNETCORE_HTTP_PORTS=8008
</code></pre>
<p>主要点：</p>
<ul>
<li>自定义一个ApiKey，方便后期发布包时使用，若未配置会出现警告，但是也能上传包，若配置了必须携带key才能发布</li>
<li>设置 <code>ASPNETCORE_HTTP_PORTS</code>否则端口映射失败</li>
</ul>
<p><strong>四、使用配置文件运行并创建容器，</strong></p>
<pre><code class="language-bash">docker run -d --rm --name nuget-server -p 8008:8008 --env-file bagetter.env -v "data:/data" bagetter/bagetter:latest
</code></pre>
<blockquote>
<p>注意使用 <code>-d</code> 设置为后台运行，否则终端退出后，容器会移除。</p>
</blockquote>
<p>此命令会检查本地是否存在镜像，若不处存在会先拉去，再创建。也可以先拉取。</p>
<p>搜索镜像</p>
<pre><code class="language-bash">docker search bagetter
</code></pre>
<p>拉取镜像</p>
<pre><code class="language-bash">docker pull bagetter/bagetter:latest
</code></pre>
<p><strong>五、浏览包</strong></p>
<p>如果在主机的windows或者linux系统上的docker环境，通过访问 <code>http://你的域名:8008</code></p>
<p>如果在群晖上，还需要将开放 <code>8008</code> 端口，使用群晖的域名和 <code>8008</code> 端口访问.</p>
<p><strong>六、通过反向代理实现https访问</strong></p>
<p>无论是在浏览器中还是在 <code>vs</code> 中使用  <code>http</code>，都会显示很多警告，甚至出现无法访问的问题。所以最好配置 <code>https</code>。</p>
<p><a href="technology-stack/../synology/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.html#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">群晖中配置反向代理</a></p>
<h3 id="发布包-1"><a class="header" href="#发布包-1">发布包</a></h3>
<p><strong>一、设置包属性</strong></p>
<p><strong>包ID</strong>：在部署的仓库中必须是唯一的，设置好后，就不要更改了</p>
<p><strong>标题</strong>：与ID相同即可</p>
<p><strong>包版本</strong>：每次打包必须更新版本号，不能存在相同的版本号，<a href="https://learn.microsoft.com/zh-cn/nuget/concepts/package-versioning?tabs=semver20sort">版本规范</a>，特定版本号的格式为 Major.Minor.Patch[-Suffix]，其中的组件具有以下含义：</p>
<ul>
<li>主要：重大更改</li>
<li>次要：新增功能，但可向后兼容</li>
<li>补丁：仅可向后兼容的 bug 修复</li>
<li>-Suffix（可选）：连字符后跟字符串，表示预发布版本（遵循语义化版本控制或 SemVer 约定）。</li>
</ul>
<p>排序：</p>
<pre><code class="language-text">1.0.1
1.0.1-zzz
1.0.1-rc.10
1.0.1-rc.2
1.0.1-open
1.0.1-beta
1.0.1-alpha2
1.0.1-alpha10
1.0.1-aaa
</code></pre>
<p><strong>作者、公司</strong>：自定义</p>
<p><strong>产品</strong>：默认</p>
<p><strong>说明（Description）</strong>：包的简要说明</p>
<p><strong>发行说明(PackageReleaseNotes)</strong>：包的版本更新日志，可以直接填写文本，也可以从一个文件中去读取，在项目文件中进行配置</p>
<pre><code class="language-xml">&lt;PropertyGroup&gt;
  &lt;ChangeLogFile&gt;$(MSBuildProjectDirectory)\CHANGELOG.md&lt;/ChangeLogFile&gt;
  &lt;PackageReleaseNotes&gt;$([System.IO.File]::ReadAllText($(ChangeLogFile)))&lt;/PackageReleaseNotes&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p><strong>二、设置许可证</strong></p>
<p><strong>许可证</strong>：可选择许可证表达式、填写MIT</p>
<p><strong>二、打包</strong></p>
<p>右键项目-&gt;打包，输出窗口查看打包信息，打包文件默认在: <code>bin/Release/xxx.nuget</code></p>
<p><strong>三、发布包</strong></p>
<p>在 <code>vs</code> 中打开 <code>powershell</code> 终端，使用命令发布，将 <code>NUGET-SERVER-API-KEY</code> 替换为自己的Key（若搭建的库中没配置key，不需要key），<code>package.1.0.0.nupkg</code> 替换为实际的包名（注意路径）</p>
<pre><code class="language-bash">dotnet nuget push -s http://xxxx:8008/v3/index.json -k NUGET-SERVER-API-KEY package.1.0.0.nupkg

</code></pre>
<p><strong>四、删除包</strong></p>
<blockquote>
<p>注意：使用命令删除包，仅仅是将版本标记为 <strong>未列出</strong> 状态，也就是包的信息还在服务器的数据库中，这就导致无法再上传同名的包，由于bagetter没有提供管理界面，所以目前能想到的办法就是直接操作数据库文件进行修改。</p>
</blockquote>
<p>打开 <code>powershell</code> 终端（注意：使用vs中的powershell会出现无法输入 y/n 的情况，因为删除的时候要求确认）。</p>
<p>假设打包的文件为：test-pkg.1.0.0.nupkg, 那么删除此版本的命令为：</p>
<pre><code class="language-bash">dotnet nuget delete text-pkg 1.0.0 -s http://xxxx:8008/v3/index.json -k NUGET-SERVER-API-KEY 

</code></pre>
<p>先备份数据文件夹</p>
<p>将docker共享文件夹设置为可以在网上邻居上显示</p>
<p>使用sqlitestudio 连接数据库文件 bagetter.db</p>
<p>可以将 Packages 表中对应版本号的数据的版本号 改为一个测试版本号，也就是不删除，这样可以保持数据完整性，同时又可以重复上传同名的版本号</p>
<h3 id="使用包"><a class="header" href="#使用包">使用包</a></h3>
<ul>
<li>在VS工具栏：工具-&gt;Nuget 包管理器-&gt;程序包管理器设置，打开设置窗口</li>
<li>选择：程序包源标签</li>
<li>点击右上角的 <strong>+</strong>
<ul>
<li>名称：自定义</li>
<li>源：<code>http://xxxx:8008/v3/index.json</code> （警告要求使用 <code>https</code> 很烦，可通过 <a href="technology-stack/../synology/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.html#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">反向代理服务器</a> 实现https访问）</li>
<li>点击更新保存</li>
</ul>
</li>
<li>使用时切换程序包源即可。</li>
</ul>
<h3 id="注意事项-4"><a class="header" href="#注意事项-4">注意事项</a></h3>
<ul>
<li>
<p>需要在环境变量中配置 <code>ASPNETCORE_HTTP_PORT=8008</code> 或者在群晖的界面设置中更改,否则在运行命令中设置的端口无效</p>
</li>
<li>
<p>很多容器中的服务都不支持 <code>https</code>，通过群晖的反向代理来实现</p>
</li>
<li>
<p>如果配置了 <code>ApiKey</code>， 发布包时要携带 <code>Key</code></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h1>
<h2 id="使用正则替换"><a class="header" href="#使用正则替换">使用正则替换</a></h2>
<p>使用正则表达式匹配字符串 <code>[MemoryPackOrder(0)]</code>，其中的 <code>0</code> 可能是其他的数字</p>
<pre><code class="language-css">\[MemoryPackOrder\(\d+\)\]
</code></pre>
<p>这个正则表达式的各部分解释如下：</p>
<ul>
<li><code>\[ 和 \]</code>：匹配方括号（因为方括号在正则表达式中是特殊字符，所以需要用反斜杠转义）。</li>
<li><code>MemoryPackOrder</code>：匹配这个具体的字符串。</li>
<li><code>\( 和 \)</code>：匹配圆括号，同样需要转义。</li>
<li><code>\d+</code>：匹配一个或多个数字。</li>
</ul>
<p>如果你需要支持负数或其他形式的数字，可以根据需要调整表达式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阿里云"><a class="header" href="#阿里云">阿里云</a></h1>
<h2 id="域名和证书"><a class="header" href="#域名和证书">域名和证书</a></h2>
<ul>
<li>购买域名：根据官网来操作，可以个人/企业方式购买，购买域名后还需要认证（可能之前没认证过需要验证）</li>
<li>云解析：将域名和云主机绑定，添加记录时，把 <code>@（主域名,如 baidu.com）</code> 和 <code>wwww（www前缀的域名，如www.baidu.com）</code> 都添加上。</li>
</ul>
<p><strong>购买免费证书:</strong></p>
<ul>
<li>先购买免费证书（一年20个免费的）</li>
<li>创建证书</li>
<li>填写域名，并根据提示设置，自动Dns验证等</li>
<li>提交审核，注意这里点击下验证，是否成功，可以看到 需要填写 TXT 记录（注意这里有可能是CNAME记录），在我们的云解析里面看下是否有相关的一条 记录，没有就加上，我第一次操作的时候没自动加上，审核失败，然后第二次看这里自动多了条记录。如下图：</li>
</ul>
<p><img src="cloud-service/assets/ali-cloud/image_RKRrhCkBWt.png" alt="" /></p>
<ul>
<li><strong>审核通过</strong> 后出现了下载按钮，可根据选项下载</li>
</ul>
<p><img src="cloud-service/assets/ali-cloud/image_22eoF1qt5u.png" alt="" /></p>
<ul>
<li><strong>证书的更新</strong> ：免费证书仅3个月的有效期，在将要过期前，我们可以再申请一个证书，替换将要过期的证书。</li>
</ul>
<h2 id="云服务器ecs"><a class="header" href="#云服务器ecs">云服务器（ECS）</a></h2>
<h3 id="配置nginx"><a class="header" href="#配置nginx">配置Nginx</a></h3>
<p><a href="https://help.aliyun.com/zh/ssl-certificate/user-guide/installation-overview?spm=a2c4g.11186623.0.0.7e0a3359kkfStu" title=" 如何下载并在服务器上安装SSL证书_数字证书管理服务（原SSL证书）(SSL Certificate)-阿里云帮助中心 通过数字证书管理服务购买并签发SSL证书后，您需要将已签发的SSL证书安装至服务器，才能使SSL证书生效。本文介绍如何下载及安装SSL证书。 https://help.aliyun.com/zh/ssl-certificate/user-guide/installation-overview?spm=a2c4g.11186623.0.0.7e0a3359kkfStu"> 如何下载并在服务器上安装SSL证书_数字证书管理服务（原SSL证书）(SSL Certificate)-阿里云帮助中心 通过数字证书管理服务购买并签发SSL证书后，您需要将已签发的SSL证书安装至服务器，才能使SSL证书生效。本文介绍如何下载及安装SSL证书。 https://help.aliyun.com/zh/ssl-certificate/user-guide/installation-overview?spm=a2c4g.11186623.0.0.7e0a3359kkfStu</a></p>
<p>详细看文档，注意以下几点：</p>
<ul>
<li>设置安全组，注意这里一定要选择地域，之前找不到这个地域在哪里，看半天才看到。</li>
</ul>
<p><img src="cloud-service/assets/ali-cloud/image_M-t0SM94cS.png" alt="" /></p>
<ul>
<li>主机的防护墙可以关闭</li>
</ul>
<h3 id="访问失败"><a class="header" href="#访问失败">访问失败</a></h3>
<p><strong>部署环境</strong></p>
<ul>
<li>Nginx 代理</li>
<li>阿里云ECS</li>
<li>阿里云上的域名</li>
<li>阿里云云解析</li>
<li>阿里云上申请的免费证书</li>
</ul>
<p><strong>问题现象：</strong></p>
<p>有的浏览器能访问，有的不能，偶尔能，偶尔不能。</p>
<p><strong>售后回复</strong></p>
<p>由于网站未备案导致，访问被拦截，详细内容：</p>
<p>网站托管在中国内地（大陆）的服务器上，您需根据所在省市的管局规则进行备案申请。当您使用阿里云中国内地（大陆）节点服务器时，您可以在PC端或移动端的阿里云ICP代备案系统中提交ICP备案申请，审核通过便可开通网站访问服务。</p>
<p><a href="https://help.aliyun.com/document_detail/61819.html">ICP备案流程</a></p>
<h2 id="云存储oss"><a class="header" href="#云存储oss">云存储（OSS）</a></h2>
<h3 id="配置访问凭证"><a class="header" href="#配置访问凭证">配置访问凭证</a></h3>
<p><a href="https://help.aliyun.com/zh/oss/developer-reference/configure-access-credentials?spm=5176.smartservice_service_create_ticket_step_2.0.0.31d077e2SPdvF6#5d6da9395f3tm">官方文档</a></p>
<p>官网中存在多种访问凭证，此处介绍两种：<strong>使用AK</strong>(开发调试时使用)和<strong>使用ECSRAMRole</strong>（部署到阿里云ECS上后使用）</p>
<h4 id="使用ak"><a class="header" href="#使用ak">使用AK</a></h4>
<blockquote>
<p>⚠️ 警告 阿里云账号拥有资源的全部权限，AK一旦泄露，会给系统带来巨大风险，不建议使用。推荐使用最小化授权的RAM用户的AK。</p>
</blockquote>
<p>如果您的应用程序部署运行在安全、稳定且不易受外部攻击的环境中，需要长期访问您的OSS，且不能频繁轮转凭证时，您可以使用阿里云主账号或RAM用户的AK（Access Key ID、Access Key Secret）初始化凭证提供者。需要注意的是，该方式需要您手动维护一个AK，存在安全性风险和维护复杂度增加的风险。如何获取AK，请参见<a href="https://help.aliyun.com/zh/ram/developer-reference/api-ims-2019-08-15-createaccesskey?spm=a2c4g.11186623.0.0.4de87787xx3cMl">CreateAccessKey - 创建主账号或RAM用户访问密钥</a>。</p>
<p><strong>步骤:</strong></p>
<ol>
<li>
<p>创建用户：进入<a href="https://ram.console.aliyun.com/users">RAM 访问控制</a></p>
</li>
<li>
<p>添加创建用户，填写登录名称，访问方式必须勾选 “OpenAPI调用访问”</p>
</li>
<li>
<p>若勾选了“控制台访问”，会出现“设置密码”等多个选项（此处可不勾选）</p>
</li>
<li>
<p>确定有弹出安全验证，要求输入手机验证码</p>
</li>
<li>
<p>验证通过后，显示账号，记录ID和Sercret(后面将不会再显示)</p>
</li>
<li>
<p>如果使用失败，给账户添加访问OSS的权限</p>
</li>
</ol>
<p><strong>SDK使用示例：</strong></p>
<pre><code class="language-c#">using Aliyun.OSS;
using Aliyun.OSS.Common;
using Aliyun.OSS.Common.Authentication;

// 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量ALIBABA_CLOUD_ACCESS_KEY_ID和ALIBABA_CLOUD_ACCESS_KEY_SECRET。
var accessKeyId = Environment.GetEnvironmentVariable("ALIBABA_CLOUD_ACCESS_KEY_ID");
var accessKeySecret = Environment.GetEnvironmentVariable("ALIBABA_CLOUD_ACCESS_KEY_SECRET");

var credentialsProvider = new DefaultCredentialsProvider(new DefaultCredentials(accessKeyId, accessKeySecret, ""));

//  填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。
const string endpoint = "https://oss-cn-hangzhou.aliyuncs.com";

// 填写Bucket所在地域对应的Region。以华东1（杭州）为例，Region填写为cn-hangzhou。
const string region = "cn-hangzhou";

var conf = new ClientConfiguration();

var client = new OssClient(endpoint, credentialsProvider, conf);
client.SetRegion(region);
</code></pre>
<h4 id="使用使用ecsramrole"><a class="header" href="#使用使用ecsramrole">使用使用ECSRAMRole</a></h4>
<p>如果您的应用程序运行在ECS实例、ECI实例、容器服务Kubernetes版的Worker节点中，建议您使用ECSRAMRole初始化凭证提供者。该方式底层实现是STS Token。ECSRAMRole允许您将一个角色关联到ECS实例、ECI实例或容器服务 Kubernetes 版的Worker节点，实现在实例内部自动刷新STS Token。该方式无需您提供一个AK或STS Token，消除了手动维护AK或STS Token的风险。如何获取ECSRAMRole，请参见CreateRole - 创建角色。</p>
<p><strong>创建角色步骤:</strong></p>
<ol>
<li>
<p>创建角色，打开<a href="https://ram.console.aliyun.com/roles">RAM 访问控制-角色</a></p>
</li>
<li>
<p>点击“创建角色”，选择“阿里云服务”，下一步</p>
</li>
<li>
<p>选择“普通服务角色”，填写角色名称、备注（可选）、选择受信服务为：“云服务器”，点击完成</p>
</li>
<li>
<p>在角色列表，点击新增的角色名称，在授权管理中，点击新增授权，添加“AliyunOSSFullAccess”和“
AliyunECSFullAccess”的授权，创建角色完成。</p>
</li>
</ol>
<p><strong>授予实例RAM角色给ECS实例：</strong></p>
<ol>
<li>
<p>登录<a href="https://ecs.console.aliyun.com/?spm=a2c4g.11186623.0.0.50b674b2edu4Ke">ECS管理控制台</a>。</p>
</li>
<li>
<p>在左侧导航栏，选择实例与镜像 &gt; 实例。</p>
</li>
<li>
<p>在页面左侧顶部，选择目标资源所在的资源组和地域。地域</p>
<p><img src="cloud-service/assets/ali-cloud/image-%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90%E6%89%80%E5%9C%A8%E7%9A%84%E8%B5%84%E6%BA%90%E7%BB%84%E5%92%8C%E5%9C%B0%E5%9F%9F.png" alt="alt text" /></p>
</li>
<li>
<p>找到要操作的ECS实例，选择图标 &gt; 实例设置 &gt; 授予/收回RAM角色。</p>
<p><img src="cloud-service/assets/ali-cloud/image-%E6%8E%88%E4%BA%88%E6%94%B6%E5%9B%9ERAM%E8%A7%92%E8%89%B2.png" alt="alt text" /></p>
</li>
<li>
<p>在对话框中，选择创建好的实例RAM角色，单击确定。</p>
<p><img src="cloud-service/assets/ali-cloud/image-%E9%80%89%E6%8B%A9RAM%E8%A7%92%E8%89%B2.png" alt="alt text" /></p>
</li>
</ol>
<p><strong>SDK 使用示例</strong></p>
<pre><code class="language-c#">
using Aliyun.OSS;
using Aliyun.OSS.Common;
using Aliyun.OSS.Common.Authentication;

class CredentialsProviderWrapper : ICredentialsProvider
{
    private Aliyun.Credentials.Client client;
    public CredentialsProviderWrapper(Aliyun.Credentials.Client client)
    {
        this.client = client;
    }

    public ICredentials GetCredentials()
    {
        var accessKeyId = client.GetAccessKeyId();
        var accessKeySecret = client.GetAccessKeySecret();
        var token = client.GetSecurityToken();
        return new DefaultCredentials(accessKeyId, accessKeySecret, token);
    }

    public void SetCredentials(ICredentials creds)
    {
    }
};

var config = new Aliyun.Credentials.Models.Config()
{
    Type = "ecs_ram_role",
    // 选填，该ECS角色的角色名称，不填会自动获取，但是建议加上以减少请求次数
    RoleName = "&lt;RoleName&gt;"     
};
var credentialsClient = new Aliyun.Credentials.Client(config);

var credentialsProvider = new CredentialsProviderWrapper(credentialsClient);

//  填写Bucket所在地域对应的Endpoint。以华东1（杭州）为例，Endpoint填写为https://oss-cn-hangzhou.aliyuncs.com。
const string endpoint = "https://oss-cn-hangzhou.aliyuncs.com";

// 填写Bucket所在地域对应的Region。以华东1（杭州）为例，Region填写为cn-hangzhou。
const string region = "cn-hangzhou";

var conf = new ClientConfiguration();

var client = new OssClient(endpoint, credentialsProvider, conf);
client.SetRegion(region);
</code></pre>
<p>总参考：<a href="https://help.aliyun.com/zh/ecs/user-guide/attach-an-instance-ram-role-to-an-ecs-instance#f70b99c15efar">通过ECS实例RAM角色授权ECS访问其他云资源</a></p>
<h3 id="oss绑定自定义域名"><a class="header" href="#oss绑定自定义域名">OSS绑定自定义域名</a></h3>
<blockquote>
<p>绑定自己的域名</p>
</blockquote>
<p>默认域名仅能下载，无法预览，也就是是无法在线查看图片，播放视频（原因是默认的链接头部强制性的定义了触发下载操作）。通过绑定自定义域名来实现预览图片或者播放视频。</p>
<h4 id="创建域名并绑定"><a class="header" href="#创建域名并绑定">创建域名并绑定</a></h4>
<ol>
<li>
<p>说明域名必须备案，一个域名只能绑定一个 Bucket，假设为 名为 “mybucket” 的Bucket绑定域名</p>
</li>
<li>
<p>如果使用了阿里云的 ECS 云服务器，那么可以使用 ECS 云服务器的域名，来解析一个二级域名，比如当前注册的域名为 yuming.com,目前可以通过 <code>yuming.com</code> 或者 <code>www.yuming.com</code> 访问 ECS 云服务器上部署的网站，同时可以添加解析 <code>abc.yuming.com</code> 来绑定 oss 的 bucket.</p>
</li>
<li>
<p>在域名控制台添加解析，这里选择 <code>CNAME</code>，并添加一个二级域名 <code>abc</code>（这步优先在OSS绑定域名）</p>
<p><img src="cloud-service/assets/ali-cloud/%E6%B7%BB%E5%8A%A0%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="alt text" /></p>
</li>
<li>
<p>OSS 绑定域名 <code>abc.yuming.com</code>，注意不是绑定 <code>yuming.com</code>（现在域名控制台添加解析后，再操作这步）</p>
<p><img src="cloud-service/assets/ali-cloud/image_oss-band-domain.png" alt="alt text" /></p>
</li>
<li>
<p>为资源设定 自有域名，然后通过URL地址可预览，注意只有在公共读的权限下才可以使用这个地址预览，否则要使用签名</p>
<p><img src="cloud-service/assets/ali-cloud/image_oss-%E8%B5%84%E6%BA%90%E8%AF%A6%E6%83%85.png" alt="alt text" /></p>
</li>
<li>
<p>关于签名获取地址，通过 <a href="https://help.aliyun.com/zh/oss/developer-reference/ddd-signatures-to-urls?spm=a2c4g.11186623.0.0.15c93bb91D6GFD#section-4lx-3kk-upk">官网文档</a> 获取各语言的接口</p>
</li>
</ol>
<h4 id="设置https证书"><a class="header" href="#设置https证书">设置Https证书</a></h4>
<blockquote>
<p>现在的网站都是需要 <code>https</code>  来访问，如果不配置，将无法获取到资源，并提示： <code>net::ERR_CERT_COMMON_NAME_INVALID</code></p>
</blockquote>
<ol>
<li>
<p>先在“证书管理页面”,选择“个人测试证书”</p>
</li>
<li>
<p>点击 “创建证书”，填写域名名称，这里填写 <code>OSS</code> 下 指定 <code>Bucket</code> 的域名，如：<code>abc.domain.com</code>，勾选“快捷签发”，选择所在地，选择你的服务所在的区域，提交审核，一般1分钟左右就通过了</p>
</li>
<li>
<p>回到OSS的“域名管理页面”，点击“证书托管”，点击“证书名称”下拉框选择证书，选择当前创建的证书即可。</p>
</li>
<li>
<p>注意证书有效期3个月，到期后，再来申请更新</p>
</li>
</ol>
<h3 id="设置防盗链禁止使用链接下载"><a class="header" href="#设置防盗链禁止使用链接下载">设置防盗链（禁止使用链接下载）</a></h3>
<p><strong>使用场景</strong></p>
<ul>
<li>
<p>禁止未经授权的使用：保护图片、视频、音频等敏感或有版权的文件不被未经授权的网站下载或访问。</p>
</li>
<li>
<p>节省带宽和资源消耗：通过防止盗链，避免其他网站直接链接到自己的资源文件，减少了非法访问带来的带宽消耗和服务器资源压力。</p>
</li>
<li>
<p>付费内容保护：在提供付费内容的场景中，防盗链可以确保只有购买者才能访问和使用付费内容，防止非法传播和盗版。</p>
</li>
<li>
<p>合作伙伴授权访问：某些情况下，需要与合作伙伴网站共享资源或数据，通过防盗链可以限制只有特定合作伙伴可以访问和使用共享资源。</p>
</li>
<li>
<p><a href="https://help.aliyun.com/zh/oss/user-guide/hotlink-protection/?spm=a2c4g.11186623.0.0.45a6415dGUVXSc">aliyun-oss-防盗链操作指南</a></p>
</li>
<li>
<p>备注：若配置了防盗链，在 “Referer” 中添加本地 <code>localhost:port</code> 来调试</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自建服务器"><a class="header" href="#自建服务器">自建服务器</a></h1>
<p>本文介绍自己搭建服务器步骤。</p>
<h2 id="服务器主机"><a class="header" href="#服务器主机">服务器主机</a></h2>
<p>准备一台主机作为服务器，开发的程序在这个主机上运行，然后通过公网IP访问，如果在访问量不大的情况下，可将服务程序、数据库等都运行到此主机上。</p>
<h2 id="域名"><a class="header" href="#域名">域名</a></h2>
<p>可以在网上找一些免费域名来使用，也可以在阿里云等网站上购买域名，购买域名后，需要将域名解析到公网IP，这样就可以通过域名来访问服务器了。此处介绍通过公云获取免费域名，并配置域名动态解析的过程。</p>
<h3 id="获取公云上的免费域名"><a class="header" href="#获取公云上的免费域名">获取公云上的免费域名</a></h3>
<p><a href="https://www.pubyun.com/user/" title="管理页面-公云pubyun">管理页面-公云pubyun</a></p>
<ul>
<li>提供免费域名</li>
<li>提供动态域名解析</li>
<li>在华为路由器中可使用3322的动态域名解析功能</li>
<li>我们可以根据这个来创建自签名证书（开发），这个证书在访问时会提示警告，甚至禁止访问</li>
</ul>
<p><strong>缺点</strong></p>
<p>不能使用它来创建 生产证书，因为需要 在域名的控制台添加 TXT 记录解析，这个免费的无法访问控制台。因此在访问的时候有警告提示。</p>
<h3 id="在路由器上配置公云的dns"><a class="header" href="#在路由器上配置公云的dns">在路由器上配置公云的DNS</a></h3>
<p>根据使用的解析服务商，使用注册它们的用户，可以使用它们的免费域名，但是无法通过它们的域名生产证书，因为无法进入域名控制台配置解析记录</p>
<p><strong>新增</strong></p>
<p><img src="cloud-service/assets/self-built-server/image_I2EhGQ_mKL.png" alt="" /></p>
<p><strong>列表</strong></p>
<p><img src="cloud-service/assets/self-built-server/image_i9l8pdqZ9c.png" alt="" /></p>
<h3 id="路由器配置虚拟服务器"><a class="header" href="#路由器配置虚拟服务器">路由器配置虚拟服务器</a></h3>
<p>配置端口映射，配置完成后需要 <strong>重启</strong>！</p>
<p><img src="cloud-service/assets/self-built-server/image_b05kzKxZzb.png" alt="" /></p>
<h3 id="nat-dmz"><a class="header" href="#nat-dmz">NAT-DMZ</a></h3>
<p>设置哪些主机（IP）对外开放</p>
<p><img src="cloud-service/assets/self-built-server/image_SQ2bSN50xm.png" alt="" /></p>
<h3 id="upnp"><a class="header" href="#upnp">UPnP</a></h3>
<p>这个要打开，群晖Nas要使用到。</p>
<h2 id="nginx-作为代理服务器"><a class="header" href="#nginx-作为代理服务器">Nginx 作为代理服务器</a></h2>
<p>详细见: <a href="cloud-service/../technology-stack/nginx.html#nginx">Nginx</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lets-encrypt-申请免费证书"><a class="header" href="#lets-encrypt-申请免费证书">Let's Encrypt 申请免费证书</a></h1>
<p><a href="https://letsencrypt.org/zh-cn/getting-started/" title="入门指南 - Let&#39;s Encrypt - 免费的SSL/TLS证书 (letsencrypt.org)">入门指南 - Let's Encrypt - 免费的SSL/TLS证书 (letsencrypt.org)</a></p>
<h2 id="安装-8"><a class="header" href="#安装-8">安装</a></h2>
<p><a href="https://certbot.eff.org/" title="https://certbot.eff.org/">https://certbot.eff.org/</a></p>
<ol>
<li>选择运行环境和操作系统，如下图，运行在Windows的Nginx 上，往下拉找到相关的下载链接</li>
</ol>
<p><img src="cloud-service/assets/let-s-encrypt/image_5QAyncrJVT.png" alt="" /></p>
<p><img src="cloud-service/assets/let-s-encrypt/image_YZxP3Ey8md.png" alt="" /></p>
<ol>
<li>安装说明：Windows 只能获取证书，而不能直接安装到服务器上，配置还需要自己来操作，安装和运行都需要管理员权限，如果开始没使用管理员权限，再使用管理员权限安装一遍。</li>
<li>cmd 和 power shell都支持运行</li>
<li>可以在非运行我的服务器的其他电脑上 运行 Certbot，获取证书后，再拷贝过去即可</li>
</ol>
<h2 id="运行"><a class="header" href="#运行">运行</a></h2>
<ul>
<li>管理员打开<code>PowerShell</code> 复制命令 ，将域名改为自己的，回车运行，这个命令是手动验证DNS，自动验证的方式经常失败，就按照这个来就好了</li>
</ul>
<pre><code class="language-powershell"> certbot certonly -d "域名例子.com" --manual --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory
</code></pre>
<ul>
<li>执行上面的，出现以下图示内容，需要添加 DNS TXT 记录，然后 回车继续，注意先要添加了才回车</li>
</ul>
<p><img src="cloud-service/assets/let-s-encrypt/image_U8Q_PuZtJ8.png" alt="" /></p>
<ul>
<li> 阿里云给<code>域名解析</code> 添加记录，注意这里我们在网上找的那些 免费域名 （如：公云或者花生壳这些）无法添加记录，因为我们无法控制它门，需要进入控制台的 </li>
</ul>
<p><a href="https://dns.console.aliyun.com/#/dns/setting/" title="   https://dns.console.aliyun.com/#/dns/setting/">   https://dns.console.aliyun.com/#/dns/setting/</a></p>
<ul>
<li>点击添加记录</li>
</ul>
<p><img src="cloud-service/assets/let-s-encrypt/image_DzhKLy1DV6.png" alt="" /></p>
<ul>
<li>填写记录配置，这里要根据上面的信息来配置，下面两个图对应好即可，点击确定，然后再shell上点回车继续即可。当我们获取到证书后，这个记录值好像是可以删除的。</li>
</ul>
<p><img src="cloud-service/assets/let-s-encrypt/image_9wtx2Jt0Dh.png" alt="" /></p>
<p><img src="cloud-service/assets/let-s-encrypt/image__lqYB_hz4K.png" alt="" /></p>
<ul>
<li>回车后应该准确的获取到证书了</li>
</ul>
<p><img src="cloud-service/assets/let-s-encrypt/image_2Q5vPHS-ay.png" alt="" /></p>
<p>证书位置：</p>
<p>c:\Certbot\live\abytesh.cn\下的对应两个文件。</p>
<h2 id="待解决的问题"><a class="header" href="#待解决的问题">待解决的问题</a></h2>
<p>自动更新问题，因为上述的方式是手动的，所以不会自动更新，后续再研究。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typora"><a class="header" href="#typora">Typora</a></h1>
<h2 id="mac版本激活"><a class="header" href="#mac版本激活">Mac版本激活</a></h2>
<p><a href="https://blog.csdn.net/enhenglhm/article/details/128980979">csdn博客</a></p>
<ul>
<li>
<p>首先去官网选择mac版本下载安装 <a href="https://www.typoraio.cn/">typora下载 </a></p>
</li>
<li>
<p>然后打开typora包内容找到 <code>/Applications/Typora.app/Contents/Resources/TypeMark/</code></p>
</li>
<li>
<p>编辑器打开上面文件夹，这里我拉到vscode，找到 <code>page-dist/static/js/Licen..</code> 如下图</p>
</li>
</ul>
<p><img src="softs/image/typora/1717637565532.png" alt="1717637565532" /></p>
<ul>
<li>
<p>输入 <code>hasActivated="true"==e.hasActivated</code> 搜索，将它改为 <code>hasActivated="true"=="true"</code></p>
</li>
<li>
<p>重新打开typora，看到成功激活：</p>
<p><img src="softs/image/typora/1717637552044.png" alt="1717637552044" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xournal"><a class="header" href="#xournal">Xournal++</a></h1>
<p>数位板手写程序，适合网课等讲解。</p>
<p><a href="https://xournalpp.github.io/">官网</a></p>
<p><img src="softs/assets/xournalpp/image.png" alt="alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bulk-rename-utility"><a class="header" href="#bulk-rename-utility">Bulk Rename Utility</a></h1>
<p>批量文件重命名工具</p>
<p><a href="https://www.bulkrenameutility.co.uk/">官网</a></p>
<p>完全免费！！！</p>
<p>命令行版本的 Bulk Rename Utiltiy (例如用于脚本)，请到我们的网站下载 Bulk Rename Command</p>
<p>64 位版本的 WIndows (XP/2003/Vista)，那么你将受益于 64 位版本的 Bulk Rename Utility</p>
<p>如果你扫描一个很大的文件夹遇到错误时想取消，请按 escape 键。</p>
<p>批量重命名实用程序允许您根据极其灵活的标准轻松重命名文件和整个文件夹，添加日期/时间戳、替换数字、插入文本、转换大小写、添加自动编号、处理文件夹和子文件夹......还有更多！</p>
<p><img src="softs/assets/bulk-rename-utility/image.png" alt="alt text" /></p>
<h2 id="案例-3"><a class="header" href="#案例-3">案例</a></h2>
<p>文件名: <code>1.漫步人生路-邓丽君(Av268167852,P1).mp3</code> ,</p>
<ol>
<li>去除后面的括号和括号里面的</li>
</ol>
<p>在正则替换选项下，输入下面的表达式，替换保留空，注意，检查表达式是否有空格之类的，在网上复制的时候可能带有空格，导致匹配失败</p>
<pre><code>\([^\)]*\)
</code></pre>
<ol>
<li>去除前面的编号</li>
</ol>
<p>正则表达式：</p>
<pre><code>^\d+\.
</code></pre>
<p>有时候是有点扯拐，总是匹配不上</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exiftool"><a class="header" href="#exiftool">ExifTool</a></h1>
<p><a href="https://exiftool.org/">官网</a></p>
<p>照片元数据编辑命令行工具，比较冷门</p>
<p>ExifTool 是一个独立于平台的Perl 库，外加一个命令行应用程序，用于读取、写入和编辑各种 文件中的元信息。ExifTool 支持许多不同的元数据格式，包括 EXIF、 GPS、 IPTC、 XMP、 JFIF、 GeoTIFF、 ICC Profile、 Photoshop IRB、 FlashPix、 AFCP和 ID3、 Lyrics3，以及佳能、 卡西欧、 大疆 、 FLIR 、富士、 通用电气、 GoPro 、惠普 、 JVC /Victor、 柯达、 Leaf、 美能达/柯尼卡美能达、 摩托罗拉、 尼康、 任天堂、奥林巴斯/爱普生、 松下/徕卡、 宾得/朝日、 飞思、 Reconyx 、理 光、 三星、 三洋、 适马/Foveon和 索尼等品牌 的许多数码相机的制造 商说明。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telegram"><a class="header" href="#telegram">Telegram</a></h1>
<h2 id="在mac上无法登录问题"><a class="header" href="#在mac上无法登录问题">在Mac上无法登录问题</a></h2>
<p>电脑端的应用在登录时二维码一直刷新，且代理已经开启了全局模式，仍然无法连接，点Log in by phone Number也显示连接失败。</p>
<p><img src="softs/image/telegram/image-1.png" alt="alt text" /></p>
<p>打开蓝猫软件的控制台，在设置中找到端口号（一般是7890，若是Verge，端口为：7897）。</p>
<p>Clash X</p>
<p><img src="softs/image/telegram/image-2.png" alt="Clash X" /></p>
<p>Clash Verge
<img src="softs/image/telegram/image-3.png" alt="Clash Verge" /></p>
<p>打开TG，点击扫码登录界面的右上角的盾牌标签</p>
<p><img src="softs/image/telegram/image-4.png" alt="add proxy" /></p>
<p>点击 <code>Done</code>后，等待连接成功，若代理一直再转圈，调整下Clash的相关设置看看</p>
<p>最后返回登录界面进行登录。</p>
<p><a href="https://blog.csdn.net/galaxyview/article/details/132487680">参考文章</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="excel"><a class="header" href="#excel">Excel</a></h1>
<h2 id="定义选项列表"><a class="header" href="#定义选项列表">定义选项列表</a></h2>
<p>需要配置一个用户表，并导入数据库，在用户表中，“性别列” 希望通过下拉组合框来选取，当选择 “男” 和 “女” 选项，导入数据库时将其转换为对应的ID（1或2）。</p>
<h3 id="使用隐藏列推荐"><a class="header" href="#使用隐藏列推荐">使用隐藏列（推荐）</a></h3>
<p>当前两个工作表 <code>Sheet1</code> 和 <code>Sheet2</code>，在 <code>Sheet2</code> 中定义序列，在 <code>Sheet1</code>中使用。</p>
<p>在 <code>Sheet2</code> 中定义序列</p>
<p><img src="softs/image/excel/1722309632314.png" alt="1722309632314" /></p>
<p>选中 <code>A1</code> 到 <code>A2</code> (不要选中 <code>B</code> 列)，工具栏：选择 <strong>公式</strong>-&gt;<strong>定义名称</strong>，输入 <code>GenderList</code>，然后点击<strong>确定</strong></p>
<p><img src="softs/image/excel/1722309864171.png" alt="1722309864171" /></p>
<p>回到 <code>Sheet1</code> ，选中整个 <code>A</code> 列，工具栏：<strong>数据</strong>-&gt;<strong>数据验证</strong>-&gt;在 “允许” 下拉菜单中选择 “序列”，在 “来源” 框中输入 =GenderList，点击 “确定”。</p>
<p><img src="softs/image/excel/1722310224441.png" alt="1722310224441" /></p>
<p>为了将选项转换为ID，可以使用 <code>VLOOKUP</code> 公式。假设你在 <code>Sheet1</code> 中使用下拉选项在 <code>A1:A10</code>，你可以在 <code>B1</code> 输入以下公式：</p>
<pre><code class="language-vbnet">=VLOOKUP(A1, Sheet2!$A$1:$B$2, 2, FALSE) //注意这里因为只有“男”、“女”两个选项，如果有5个选项，应该为 =VLOOKUP(A1, Sheet2!$A$1:$B$5, 2, FALSE)
</code></pre>
<p><code>B</code> 列的其他项通过复制 <code>B1</code> 单元格（鼠标按住下拉），然后将 <strong>B</strong> 列隐藏，在配置时比较简洁</p>
<p><img src="softs/image/excel/1722310717241.png" alt="1722310717241" /></p>
<p>导入数据库，导入数据库时使用 <strong>B</strong> 列数据，不要使用 A 列数据。</p>
<h3 id="使用宏进行转换"><a class="header" href="#使用宏进行转换">使用宏进行转换</a></h3>
<p>你可以使用VBA宏在导入数据库前将“男”和“女”转换为对应的ID。</p>
<p>打开VBA编辑器</p>
<p>按 <code>Alt + F11</code> 打开VBA编辑器，在VBA编辑器中，点击 "插入" &gt; "模块"。</p>
<p>输入宏代码</p>
<pre><code class="language-vbnet">Sub ConvertGenderToID()
    Dim ws As Worksheet
    Dim lastRow As Long
    Dim i As Long
  
    Set ws = ThisWorkbook.Sheets("Sheet1") ' 替换为你的工作表名称
    lastRow = ws.Cells(ws.Rows.Count, "B").End(xlUp).Row
  
    For i = 1 To lastRow
        Select Case ws.Cells(i, "B").Value
            Case "男"
                ws.Cells(i, "C").Value = 1
            Case "女"
                ws.Cells(i, "C").Value = 2
        End Select
    Next i
End Sub
</code></pre>
<p>运行宏，按 <code>F5</code> 运行宏，它会将B列中的性别选项转换为C列中的ID。</p>
<p>导入数据库，导入 <strong>C</strong> 列中的数据到数据库。这样，你可以在Excel中显示“男”和“女”，但在导入数据库时将其转换为对应的ID。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio"><a class="header" href="#visual-studio">Visual Studio</a></h1>
<h2 id="移动文件时启用命名空间更新"><a class="header" href="#移动文件时启用命名空间更新">移动文件时启用命名空间更新</a></h2>
<p>这个功能默认是启用的，但是某些情况下，不希望这个功能。</p>
<p>设置：菜单-&gt;工具-&gt;选项-&gt;项目和解决方案：移动文件时启用命名空间更新</p>
<h2 id="包管理器"><a class="header" href="#包管理器">包管理器</a></h2>
<h3 id="中文乱码"><a class="header" href="#中文乱码">中文乱码</a></h3>
<p>CSDN：<a href="https://gitee.com/link?target=https://blog.csdn.net/Michael_fchou/article/details/104349977">https://blog.csdn.net/Michael_fchou/article/details/104349977</a></p>
<p><strong>第一种情况：</strong></p>
<p>VS的输出编码更改为UTF-8，按照图示安装UTF-8插件，若未解决问题，进行第二种操作</p>
<p><img src="softs/image/visual-studio/1722582982618.png" alt="1722582982618" /></p>
<hr />
<p><strong>第二种情况：</strong></p>
<p>如果已经装了UTF-8插件但是控制台输出的中文仍然是乱码。</p>
<ol>
<li>打开电脑的控制面板</li>
</ol>
<p><img src="softs/image/visualstudio/1717636919260.png" alt="1717636919260" /></p>
<ol start="2">
<li>选择“时钟和区域”</li>
</ol>
<p><img src="softs/image/visual-studio/1722583533082.png" alt="1722583533082" /></p>
<ol start="3">
<li>选择“区域”</li>
</ol>
<p><img src="softs/image/visual-studio/1722583560162.png" alt="1722583560162" /></p>
<ol start="4">
<li>选择“管理”标签</li>
</ol>
<p><img src="softs/image/visual-studio/1722583584907.png" alt="1722583584907" /></p>
<ol start="5">
<li>选择“更改系统区域设置”</li>
</ol>
<p><img src="softs/image/visual-studio/1722583601644.png" alt="1722583601644" /></p>
<ol start="6">
<li>勾选“Beta版：使用 Unicode UTF-8 提供全球语言支持(U)”</li>
<li>最后重启电脑就ok了</li>
</ol>
<h2 id="entity-framework"><a class="header" href="#entity-framework">Entity Framework</a></h2>
<p>在VS包控制台执行 <code>dotnet ef</code>错误</p>
<pre><code class="language-shell">dotnet : 无法执行，因为找不到指定的命令或文件。
所在位置 行:1 字符: 1
+ dotnet ef dbcontext scaffold "server=192.168.1.236;database=JzErp;uid ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (无法执行，因为找不到指定的命令或文件。:String) [], RemoteException
    + FullyQualifiedErrorId : NativeCommandError
 
可能的原因包括:
  *内置的 dotnet 命令拼写错误。
  *你打算执行 .NET 程序，但 dotnet-ef 不存在。
  *你打算运行全局工具，但在路径上找不到具有此名称且前缀为 dotnet 的可执行文件。

</code></pre>
<p><strong>原因：</strong></p>
<p>从 3.0 起，EF Core 命令列工具 (dotnet ef) 不在 .NET Core SDK 里面，需另装。命令如下：</p>
<pre><code class="language-shell">dotnet tool install --global dotnet-ef
</code></pre>
<p>安装成功如下</p>
<pre><code class="language-shell">PM&gt; dotnet tool install --global dotnet-ef
可使用以下命令调用工具: dotnet-ef
已成功安装工具“dotnet-ef”(版本“6.0.2”)

</code></pre>
<p>参考：<a href="http://www.manongjc.com/detail/28-rmfcuflorcnbrte.html">http://www.manongjc.com/detail/28-rmfcuflorcnbrte.html</a></p>
<h3 id="迁移"><a class="header" href="#迁移">迁移</a></h3>
<p>先创建迁移文件</p>
<pre><code class="language-shell">dotnet ef migrations add xxxx
</code></pre>
<p>然后更新数据库</p>
<pre><code class="language-shell">dotnet ef database update
</code></pre>
<h2 id="项目文件加载异常"><a class="header" href="#项目文件加载异常">项目文件加载异常</a></h2>
<p>当出现以下问题时，通过删除 <code>.vs</code> 文件处理：</p>
<ul>
<li>解决方案加载异常</li>
<li>项目文件加载异常</li>
<li>Asp.net.core 中，@page 名称正确，无法路由</li>
</ul>
<h2 id="查找替换功能失效"><a class="header" href="#查找替换功能失效">查找替换功能失效</a></h2>
<p>删除文件:</p>
<pre><code class="language-text">C：\Program Files\Microsoft Visual Studio\2022[Enterprise/Pro/Community]\Common7\IDE\CommonExtensions\Microsoft\Editor\ServiceHub\Indexing.servicehub.service.json
</code></pre>
<p>并重新启动Visual Studio</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vs-code"><a class="header" href="#vs-code">VS CODE</a></h1>
<p><a href="https://code.visualstudio.com/docs/languages">VS CODE 各语言的使用支持</a></p>
<h2 id="下载"><a class="header" href="#下载">下载</a></h2>
<ul>
<li>下载地址：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></li>
<li>选择下载的版本，最好下载system版本</li>
<li>国内加速下载方法，在浏览器中打开下载内容页面，选中下载的VsCode，右键选择复制下载地址，将地址中的 <code>vscode.cdn.azure.cn</code> 替换 <code>az764295.vo.msecnd.net</code>，使用新地址下载。</li>
</ul>
<h2 id="插件"><a class="header" href="#插件">插件</a></h2>
<h3 id="gbktoutf8"><a class="header" href="#gbktoutf8">GBKtoUTF8</a></h3>
<p>自动将 GBK格式转化为UTF-8格式。进行Unity开发，开始用的VS，VS强大，但是太臃肿，用起来自身就占用了7-8个G，每次编译Uniyt 很耗时，换成 vscode,但是出现中文乱码，此插件解决此问题。</p>
<h2 id="markdown"><a class="header" href="#markdown">Markdown</a></h2>
<h3 id="边界和预览切换"><a class="header" href="#边界和预览切换">边界和预览切换</a></h3>
<p><code>ctrl+shift+v</code></p>
<h3 id="设置-markdown-中粘贴图片的位置"><a class="header" href="#设置-markdown-中粘贴图片的位置">设置 Markdown 中粘贴图片的位置</a></h3>
<ul>
<li>
<p>在 <strong>VS Code</strong> 中，按下 <code>Ctrl + ,</code> ，打开设置界面。</p>
</li>
<li>
<p>在搜索框中输入 <code>markdown.copy</code> , 找到 <code>Markdown&gt; Copy Files:Destination</code></p>
</li>
<li>
<p>新增配置项 key 为 <code>**/*.md</code> , value 为 你的目标路径,比如我想将图片放在 <code>assets</code> 目录下markdown文件同名的目录下，那么我就可以设置为 <code>assets/${documentBaseName}/${fileName}</code>， 其中 <code>${documentBaseName}</code>代表markdown文件的文件名，<code>${fileName}</code> 代表图片的文件名。</p>
</li>
<li>
<p>可选择要为 <strong>当前用户</strong> 设置还是为 <strong>当前工作空间</strong> 设置 保存设置即可</p>
</li>
</ul>
<h3 id="创建指向另一个文件中的标题的链接"><a class="header" href="#创建指向另一个文件中的标题的链接">创建指向另一个文件中的标题的链接</a></h3>
<p>需要链接到另一个 Markdown 文档中的标题，但不记得或不想输入完整的文件路径？尝试使用工作区标题补全！首先，只需输入##Markdown 链接即可查看当前工作区中所有 Markdown 标题的列表：</p>
<p><img src="softs/assets/visual-studio-code/image.png" alt="针对当前工作区中所有 Markdown 标题的建议" /></p>
<p>接受以下某个补全操作即可插入该标题的完整链接，即使该链接位于另一个文件中：</p>
<p><img src="softs/assets/visual-studio-code/image-1.png" alt="alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>版本：2023.1.3</p>
<h1 id="使用教程-1"><a class="header" href="#使用教程-1">使用教程</a></h1>
<ol>
<li>官网下载软件，安装</li>
<li>激活</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 15px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 12px;
    text-align: left;
    vertical-align: top; 
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.key-cell {
    background-color: #df7400;
}

/* .excel-table tr:nth-child(even) {
    background-color: #f9f9f9;
} */
/* 禁用隔行背景色不同的功能 */
.excel-table tr:nth-child(even), table tr:nth-child(odd) {
    background-color: transparent; /* 确保所有行背景色一致 */
}

.excel-table tr:hover {
    background-color: inherit;
}


.bold-first-column {
    font-weight: bold;
}
.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    /* width: 30%; */
    width:40px;
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 30%;
}
.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width:70%;
}



</style>
<h2 id="播放器"><a class="header" href="#播放器">播放器</a></h2>
<div class="table-container">
    <table class="excel-table" id="example-table">
        <thead>
            <tr>
                <th>编号</th>
                <th>软件</th>
                <th>说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td><a href="https://potplayer.daum.net">视频播放器：potplayer</a></td>
                <td>外网访问</td>
            </tr>
             <tr>
                <td>2</td>
                <td><a href="https://obsproject.com">录屏软件：OBS Studio</a></td>
                <td>开源，免费，可选择录屏来源，如某个程序，下载时有点慢，可以在群晖上下载</td>
            </tr>
        </tbody>
    </table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="markdown-1"><a class="header" href="#markdown-1">Markdown</a></h1>
<h2 id="设置字体风格"><a class="header" href="#设置字体风格">设置字体风格</a></h2>
<p>代码：</p>
<pre><code class="language-markdown">&gt; ⚠️ &lt;span style="color:red;font-weight:bold;"&gt;这是一条红色粗体的警告信息&lt;/span&gt;
</code></pre>
<p>显示：</p>
<blockquote>
<p>⚠️ <span style="color:red;font-weight:bold;">这是一条红色粗体的警告信息</span></p>
</blockquote>
<h2 id="表格"><a class="header" href="#表格">表格</a></h2>
<p>嵌入 <code>Html</code> 自定义表格（横向拉伸，固定每列的比列，设置为excel样式等）</p>
<p>代码</p>
<pre><code class="language-markdown">&lt;style&gt;
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 12px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局  这样可实现表格第一列固定宽度，剩下的按比例自动拉伸*/
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 8px;
    text-align: left;
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.excel-table tr:nth-child(even) {
    background-color: #f9f9f9;
}

.excel-table tr:hover {
    background-color: #e9e9e9;
}

.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    width: 30%;
    /*  width: 100px; 固定第一列宽度 */
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 20%;
}

.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width: 50%;
}
&lt;/style&gt;

&lt;div class="table-container"&gt;
    &lt;table class="excel-table"&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;列1&lt;/th&gt;
                &lt;th&gt;列2&lt;/th&gt;
                &lt;th&gt;列3&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;a href="https://example.com"&gt;链接1&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;&lt;a href="https://example.com"&gt;链接2&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;&lt;a href="https://example.com"&gt;链接3&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;a href="https://example.com"&gt;链接4&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;&lt;a href="https://example.com"&gt;链接5&lt;/a&gt;&lt;/td&gt;
                &lt;td&gt;&lt;a href="https://example.com"&gt;链接6&lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;

</code></pre>
<p>效果</p>
<style>
.table-container {
    display: flex;
    justify-content: center;
    width: 100%;
}

.excel-table {
    width: 100%;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    font-size: 14px; /* 设置字体大小 */
    table-layout: fixed; /* 固定表格布局 */
}

.excel-table th, .excel-table td {
    border: 1px solid #d0d7de;
    padding: 8px;
    text-align: left;
}

.excel-table th {
    background-color: #f0f3f5;
    font-weight: bold;
}

.excel-table tr:nth-child(even) {
    background-color: #f9f9f9;
}

.excel-table tr:hover {
    background-color: #e9e9e9;
}

.excel-table th:nth-child(1), .excel-table td:nth-child(1) {
    /* width: 30%; */
      width: 100px; /*固定第一列宽度 */
}

.excel-table th:nth-child(2), .excel-table td:nth-child(2) {
    width: 40%;
}

.excel-table th:nth-child(3), .excel-table td:nth-child(3) {
    width: 60%;
}
</style>
<div class="table-container">
    <table class="excel-table">
        <thead>
            <tr>
                <th>列1(宽100)</th>
                <th>列2(宽40%)</th>
                <th>列3(宽60%)</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td><a href="https://example.com">链接1</a></td>
               <td>
                   <ol>
                        <li>有序</li>
                        <li>有序</li>
                    </ol>
                </td>
            </tr>
            <tr>
                <td>2</td>
                <td>内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容</td>
                <td>
                    <ul>
                        <li>无序</li>
                        <li>无序</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
</div>
<h2 id="图标"><a class="header" href="#图标">图标</a></h2>
<h3 id="通过代码转换"><a class="header" href="#通过代码转换">通过代码转换</a></h3>
<p>在 <a href="https://www.unicode.org/emoji/charts/full-emoji-list.html">图标网站</a> 上查找要使用的图标，如 🍎 的 <strong>Unicode</strong> 编码为 <code>U+1F34E</code>，则与此表情对应的 code 为 <code>1F34E</code>，在 Markdown 文档中对应的代码为 <code>&amp;#x{code};</code>  既在 Markdown 文档中输入 <code>&amp;#x1F34E;</code> 即可显示为 🍎。</p>
<h3 id="常用图标"><a class="header" href="#常用图标">常用图标</a></h3>
<p>复制即可使用</p>
<p>⚠️❗❓❕❔❎❌ ❗ ‼️ ⁉️ ⭕✔️✅</p>
<p>❤️ ✨⭐ ❗❓❕❔ ✊✌️ ✋✋ ☝️</p>
<p>☀️ ☔ ☁️ ❄️ ⛄ ⚡ ⛅</p>
<p>☎️ ☎️ ⌛ ⏳ ⏰ ⌚ ➿ ✉️ ✉️ ✂️ ✒️ ✏️ ⚽ ⚾️ ⛳ ♠️ ♥️ ♣️ ♦️ ☕</p>
<p>⛪ ⛺ ⛲ ⛵ ⛵ ⚓ ✈️ ⛽ ⚠️ ♨️</p>
<p>1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 0️⃣ #️⃣ ◀️ ⬇️ ▶️ ⬅️ ↙️ ↘️ ➡️ ⬆️ ↖️ ↗️ ⏬ ⏫ ⤵️ ⤴️ ↩️ ↪️ ↔️ ↕️ ⏪ ⏩ ℹ️ ️ ️ ️ ♿ ㊙️ ㊗️ Ⓜ️ ⛔ ✳️ ❇️ ✴️ ♈ ♉ ♊ ♋ ♌ ♍ ♎ ♏ ♐ ♑ ♒ ♓ ⛎ ❎ ️ ️ ️ ♻️ ©️ ®️ ™️ ❌ ❗ ‼️ ⁉️ ⭕ ✖️ ➕ ➖ ➗ ✔️ ☑️ ➰ 〰️ 〽️ ▪️ ▫️ ◾ ◽ ◼️ ◻️ ⬛ ⬜ ✅ ⚫ ⚪</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        <script src="assets/custom3.js"></script>
        <script src="assets/fzf.umd.js"></script>
        <script src="assets/elasticlunr.js"></script>
        <script src="assets/mermaid.min.js"></script>
        <script src="assets/import-html.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>